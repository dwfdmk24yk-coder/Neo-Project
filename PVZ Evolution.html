<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Mini PvZ — Upgraded</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{ --panel:#0f4122; --panel-2:#153d24; --accent:#ffd166 }
    /* Level transition animations */
    @keyframes popIn { from{ transform:scale(0.7); opacity:0 } to{ transform:scale(1); opacity:1 } }
    #levelOverlay.show #levelCard{ animation: popIn 420ms cubic-bezier(.2,.9,.3,1); }
    #levelCard h2{ margin:0; font-size:28px; }
    #levelCard p{ margin:8px 0 0 0 }
    body{ margin:0; font-family:Segoe UI, Roboto, Arial; background:#2b7a3a; display:flex; align-items:center; justify-content:center; height:100vh }
    #wrap{ width:1460px; background:linear-gradient(#0f3d1e,#0b2f18); padding:14px; border-radius:12px; box-shadow:0 20px 60px rgba(0,0,0,0.6); color:#fff; position:relative }
    #top{ display:flex; align-items:center; gap:12px; margin-bottom:10px }
    #seedBar{ display:flex; gap:8px; padding:8px; background:rgba(0,0,0,0.08); border-radius:8px }
    .seedCard{ position:relative; width:96px; height:64px; background:linear-gradient(180deg,#1d5b2f,#174a27); border-radius:8px; padding:6px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.03); cursor:pointer; display:flex; align-items:center; gap:8px }
    .seedCard.disabled{ opacity:0.4; cursor:default }
    .seedIcon{ width:48px; height:48px; border-radius:6px; overflow:hidden; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,0.03) }
    .seedInfo{ font-size:13px }
    .seedCost{ position:absolute; bottom:6px; right:8px; background:rgba(0,0,0,0.25); padding:2px 6px; border-radius:6px; font-weight:700 }
    .cooldownMask{ position:absolute; left:0; top:0; width:100%; height:100%; background:linear-gradient(to top, rgba(0,0,0,0.55), rgba(0,0,0,0.2)); transform-origin: bottom; pointer-events:none }
    #controls{ margin-left:auto; display:flex; gap:8px; align-items:center }
    button{ padding:6px 10px; border-radius:6px; border:0; cursor:pointer; background:#fff; color:#111 }
    #gameWrap{ margin-top:8px; background:linear-gradient(#2f7c3f,#23602b); border-radius:8px; padding:14px }
    #game{ display:block; background:transparent; border-radius:6px; width:100%; height:620px; }
    #hud{ margin-top:8px }
    /* Menu overlay */
    #menuOverlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); z-index:40 }
    #menuCard{ width:520px; padding:28px; background:linear-gradient(#163d22,#0f2d16); border-radius:12px; text-align:center }
    #menuCard h1{ margin:0 0 12px 0 }
    #menuCard p{ color:rgba(255,255,255,0.85) }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="top">
      <div id="seedBar"></div>
      <div id="controls">
        <div>Sun: <span id="sun">200</span></div>
        <button id="start">Start</button>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
      </div>
    </div>

    <div id="gameWrap">
      <canvas id="game"></canvas>
      <div id="hud">Cây: 0 — Zombie: 0</div>
    </div>

    <div id="menuOverlay">
      <div id="menuCard">
        <h1>Garden Defense</h1>
        <p>Bấm Play để vào trận</p>
        <div style="margin-top:14px">
          <button id="playBtn">Play</button>
          <button id="menuHow" style="margin-left:8px">How to</button>
        </div>
      </div>
    </div>
    <div id="levelOverlay" style="display:none; position:absolute; inset:0; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); z-index:50">
      <div id="levelCard" style="width:420px; padding:20px; background:linear-gradient(#163d22,#0f2d16); border-radius:10px; text-align:center">
        <h2 id="levelTitle">Level complete</h2>
        <p id="levelText">Ready for next level?</p>
        <div style="margin-top:12px"><button id="nextLevelBtn">Next Level</button></div>
      </div>
    </div>
  </div>

  <script>
  // Upgraded: PVZ-like seed bar with cooldown, pre-game menu, and wider grid
  console.log('game.html script start');
  // small visual marker to show script executed
  try{ document.getElementById('hud').textContent = 'Initializing...'; }catch(e){}
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const ROWS = 5, COLS = 14; // increased columns
  const LOGICAL_W = 1400, LOGICAL_H = 620; // canvas logical size
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = LOGICAL_W * DPR; canvas.height = LOGICAL_H * DPR;
  canvas.style.width = LOGICAL_W + 'px'; canvas.style.height = LOGICAL_H + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  const W = LOGICAL_W, H = LOGICAL_H;
  const CW = W / COLS, CH = H / ROWS;
  // spawn / difficulty tuning
  const SPAWN_INTERVAL = 2800; // base ms between zombie spawns
  const MAX_ACTIVE_ZOMBIES = 6; // cap simultaneous zombies
  // global speed scale for zombies (lower = slower)
  // Reduced further to slow all zombies a bit more
  const ZOMBIE_SPEED_SCALE = 0.16;

  const seedBar = document.getElementById('seedBar');
  const sunEl = document.getElementById('sun');
  const hud = document.getElementById('hud');
  const btnStart = document.getElementById('start');
  const btnPause = document.getElementById('pause');
  const btnReset = document.getElementById('reset');
  const menuOverlay = document.getElementById('menuOverlay');
  const playBtn = document.getElementById('playBtn');

  // sprites (SVG data URLs)
  function svgToDataURL(svg){ return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg); }
  const sprites = {
    sunflower: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><defs><radialGradient id='g0' cx='40%' cy='30%'><stop offset='0' stop-color='#fff9c4'/><stop offset='1' stop-color='#f2b705'/></radialGradient><radialGradient id='g1' cx='30%' cy='30%'><stop offset='0' stop-color='#fff'/><stop offset='1' stop-color='#6b3b00'/></radialGradient></defs><g transform='translate(80,80)'><g id='petals' fill='#ffd75a' stroke='#c57b00' stroke-width='2'>
        <ellipse rx='52' ry='20' transform='rotate(0)'/>
        <ellipse rx='52' ry='20' transform='rotate(30)'/>
        <ellipse rx='52' ry='20' transform='rotate(60)'/>
        <ellipse rx='52' ry='20' transform='rotate(90)'/>
        <ellipse rx='52' ry='20' transform='rotate(120)'/>
        <ellipse rx='52' ry='20' transform='rotate(150)'/>
      </g>
      <circle r='30' fill='url(#g0)' stroke='#9a5b00' stroke-width='3'/>
      <circle r='10' fill='url(#g1)'/></g></svg>`),
    peashooter: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><defs><linearGradient id='pg' x1='0' x2='0' y1='0' y2='1'><stop offset='0' stop-color='#89e9a9'/><stop offset='1' stop-color='#2e7d32'/></linearGradient></defs><g transform='translate(80,80)'>
      <ellipse rx='34' ry='22' fill='url(#pg)' stroke='#145d2a' stroke-width='3'/>
      <rect x='8' y='-6' width='28' height='18' rx='9' fill='#2a9fb2' stroke='#0f6c73' stroke-width='2'/>
      <rect x='-12' y='26' width='24' height='46' rx='8' fill='#2e7d32'/>
      <circle cx='20' cy='-2' r='6' fill='#0b5f64'/>
    </g></svg>`),
    wallnut: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'>
      <ellipse rx='36' ry='30' fill='#c79b6b' stroke='#6a3f24' stroke-width='3'/>
      <path d='M-26 6 q26 20 52 0' fill='#b88a5f' opacity='0.6'/>
      <circle cx='-10' cy='-6' r='4' fill='#6a4528'/><circle cx='10' cy='-6' r='4' fill='#6a4528'/>
    </g></svg>`),
    cherry: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'>
      <circle cx='-10' cy='0' r='14' fill='#ff3b3b' stroke='#cc1f1f' stroke-width='2'/>
      <circle cx='12' cy='-2' r='13' fill='#ff1f1f' stroke='#c21a1a' stroke-width='2'/>
      <path d='M-4 -8 q6 -12 18 -6' stroke='#2e7d32' stroke-width='3' fill='none'/>
    </g></svg>`),
    icepea: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'>
      <ellipse rx='34' ry='22' fill='#7fe8ff' stroke='#3bb3c8' stroke-width='3'/>
      <rect x='-12' y='26' width='24' height='46' rx='8' fill='#2e7d32'/>
      <circle cx='18' cy='-6' r='6' fill='#4bc4d8'/>
    </g></svg>`),
    sunshroom: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'>
      <ellipse rx='30' ry='18' fill='#ffd27a' stroke='#e0a84a' stroke-width='2'/>
      <rect x='-8' y='22' width='16' height='34' rx='6' fill='#2e7d32'/>
    </g></svg>`)
  };
  // extra plant sprites
  sprites.tallnut = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'><rect x='-36' y='-20' width='72' height='72' rx='12' fill='#b57f4a' stroke='#6a3f24' stroke-width='3'/><ellipse cx='0' cy='-24' rx='18' ry='10' fill='#8b5a2b' opacity='0.6'/></g></svg>`);
  sprites.gatling = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'><rect x='-14' y='-26' width='36' height='40' rx='8' fill='#3aa66a' stroke='#174a27' stroke-width='2'/><rect x='18' y='-10' width='32' height='12' rx='6' fill='#2a9fb2' stroke='#0f6c73'/></g></svg>`);
  sprites.pumpkin = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'><ellipse rx='44' ry='34' fill='#f39c12' stroke='#a85a00' stroke-width='3'/><path d='M-8 -36 v-8' stroke='#2e7d32' stroke-width='3'/></g></svg>`);
  sprites.magnet = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'><path d='M-28 -6 a28 28 0 0 0 56 0 v18 a46 46 0 0 1 -56 0 z' fill='#c6d8ff' stroke='#6b7fb3' stroke-width='3'/><rect x='-10' y='-26' width='20' height='16' rx='4' fill='#a3c1ff'/></g></svg>`);
  sprites.spiker = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'><g transform='translate(80,80)'><rect x='-18' y='0' width='36' height='20' rx='4' fill='#6b3b1f' stroke='#3b1f0f' stroke-width='2'/><path d='M-12 0 L-6 -18 L0 0 L6 -18 L12 0' fill='#d94b2b'/></g></svg>`);
  // preload Image objects to avoid creating new Image every frame
  const spriteImages = {};
  Object.keys(sprites).forEach(k=>{ const im = new Image(); im.src = sprites[k]; spriteImages[k]=im; });
  // lawnmower sprite
  sprites.lawnmower = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 32'><rect x='0' y='6' width='56' height='14' rx='4' fill='#f2c94c'/><circle cx='12' cy='24' r='4' fill='#333'/><circle cx='44' cy='24' r='4' fill='#333'/></svg>`);
  // add zombie sprite
  sprites.zombie = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <g transform='translate(80,80)'>
      <defs>
        <filter id='bg' x='-50%' y='-50%' width='200%' height='200%'>
          <feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#001' flood-opacity='0.4'/>
        </filter>
      </defs>
      <ellipse rx='28' ry='24' fill='#4b6f6b' stroke='#1f352f' stroke-width='3' filter='url(#bg)' />
      <path d='M-26 8 q26 -18 52 0 q-14 18 -52 0' fill='#3f5a56' opacity='0.7'/>
      <rect x='-22' y='18' width='44' height='40' rx='6' fill='#516e6a' />
      <g id='face'>
        <ellipse cx='-8' cy='-6' rx='6' ry='5' fill='#120000'/>
        <ellipse cx='8' cy='-6' rx='6' ry='5' fill='#120000'/>
        <circle cx='-8' cy='-6' r='2' fill='#ff2b2b'/>
        <circle cx='8' cy='-6' r='2' fill='#ff2b2b'/>
        <path d='M-10 2 q10 8 20 0' fill='#fff' stroke='#a00' stroke-width='1'/>
      </g>
      <path d='M-18 46 q18 -8 36 0' fill='#3a564f' opacity='0.9'/>
      <path d='M6 -2 q8 -8 18 -4' stroke='#8b0000' stroke-width='2' fill='none' opacity='0.9'/>
      <path d='M-20 0 q6 12 24 6' stroke='#6b2b1b' stroke-width='2' fill='none' opacity='0.8'/>
    </g>
  </svg>`);

  // ensure newly-added sprites have corresponding Image objects
  spriteImages.lawnmower = new Image(); spriteImages.lawnmower.src = sprites.lawnmower;
  spriteImages.zombie = new Image(); spriteImages.zombie.src = sprites.zombie;

  // Card definitions with cooldown (ms)
  const CARDS = [
    { id:'sunflower', name:'Sunflower', cost:50, cooldown:6000 },
    { id:'peashooter', name:'Peashooter', cost:100, cooldown:2800 },
    { id:'wallnut', name:'Wall-nut', cost:75, cooldown:15000 },
    { id:'cherry', name:'Cherry Bomb', cost:150, cooldown:20000 },
    { id:'icepea', name:'Ice Pea', cost:125, cooldown:4500 },
    { id:'sunshroom', name:'Sunshroom', cost:25, cooldown:8000 }
  ];

  // extra plants to unlock each level (will be appended to `CARDS` after each level)
  const EXTRA_CARDS = [
    { id:'tallnut', name:'Tall-nut', cost:120, cooldown:18000 },
    { id:'gatling', name:'Gatling Pea', cost:200, cooldown:10000 },
    { id:'pumpkin', name:'Pumpkin', cost:90, cooldown:16000 },
    { id:'magnet', name:'Magnet Shroom', cost:140, cooldown:18000 },
    { id:'spiker', name:'Spikerock', cost:180, cooldown:20000 }
  ];

  const cardState = {};

  const INITIAL_SUN = 200;
  let sun = INITIAL_SUN;
  let selected = null;
  let plants = [];
  let zombies = [];
  let bullets = [];
  let particles = [];
  let lawnmowers = [];
  let running = false;
  let last = 0;
  let spawnAcc = 0;
  // track when the current run started (ms) to apply early-game modifiers
  let gameStartTime = 0;
  // level progression
  let currentLevel = 1;
  let levelTarget = 20; // zombies to kill this level
  let levelSpawned = 0;
  let levelKilled = 0;
  // audio / global effects
  let zombieMoanOsc = null;
  let zombieMoanGain = null;
  let zombieMoanPlaying = false;

  function buildSeedBar(){
    seedBar.innerHTML = '';
    CARDS.forEach(def=>{
      const card = document.createElement('div'); card.className='seedCard'; card.dataset.id = def.id;
      const icon = document.createElement('div'); icon.className='seedIcon'; const img = new Image(); img.src = sprites[def.id]; img.style.width='48px'; img.style.height='48px'; icon.appendChild(img);
      const info = document.createElement('div'); info.className='seedInfo'; info.innerHTML = `<div style="font-weight:800">${def.name}</div><div style='font-size:12px;color:#cde6c8'>${def.cost} Sun</div>`;
      const cost = document.createElement('div'); cost.className='seedCost'; cost.textContent = def.cost;
      const mask = document.createElement('div'); mask.className='cooldownMask'; mask.style.transform = 'scaleY(0)'; mask.style.display='none';
      card.appendChild(icon); card.appendChild(info); card.appendChild(cost); card.appendChild(mask);
      card.onclick = ()=>{
        const st = cardState[def.id]; const now = performance.now();
        if(st.cooldownUntil > now) return; if(sun < def.cost) return;
        // select
        document.querySelectorAll('.seedCard').forEach(c=>c.classList.remove('selected'));
        card.classList.add('selected'); selected = def.id;
      };
      seedBar.appendChild(card);
      cardState[def.id] = { def, el:card, mask, cooldownUntil:0 };
    });
    updateSeedUI();
  }

  function updateLevelUI(){
    // update HUD displayed later via updateUI
    // keep placeholder if needed
  }

  function initLawnmowers(){ lawnmowers = []; for(let r=0;r<ROWS;r++){ lawnmowers.push({ row:r, x:-0.6, active:true, moving:false, speed:0.9 }); } }

  function updateSeedUI(){
    Object.values(cardState).forEach(s=>{
      const now = performance.now();
      const disabled = (s.cooldownUntil > now) || (sun < s.def.cost);
      s.el.classList.toggle('disabled', disabled);
      if(s.cooldownUntil > now){ s.mask.style.display='block'; const pct = (s.cooldownUntil - now)/s.def.cooldown; s.mask.style.transform = `scaleY(${Math.max(0, pct)})`; } else { s.mask.style.display='none'; s.mask.style.transform='scaleY(0)'; }
    });
  }

  function spawnPlantParticles(x,y,color,count=12){ for(let i=0;i<count;i++){ const ang=Math.random()*Math.PI*2; const sp=0.5+Math.random()*1.6; particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp, life:500+Math.random()*400, t:0, color}); } }
  function particleStep(dt){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.t+=dt; p.x+=p.vx*dt/16; p.y+=p.vy*dt/16; p.vy+=0.01*dt/16; if(p.t>=p.life) particles.splice(i,1); } }

  // gore / blood splatter particles for zombie deaths
  function spawnGoreParticles(x,y,count=18){ const choices = ['#8b0000','#ff3b3b','#6b2b1b','#c72b2b']; for(let i=0;i<count;i++){ const ang = Math.random()*Math.PI*2; const sp = 0.6 + Math.random()*2.2; const color = choices[Math.floor(Math.random()*choices.length)]; particles.push({ x, y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, life: 600 + Math.random()*500, t:0, color, size: 2 + Math.random()*4 }); } }

  function updateUI(){ sunEl.textContent = String(sun); const remaining = Math.max(0, levelTarget - levelKilled); hud.textContent = `Cây: ${plants.length} — Zombie: ${zombies.length} — Level: ${currentLevel} — Remaining: ${remaining}`; updateSeedUI(); }
  

  // planting
  document.getElementById('gameWrap').addEventListener('click', (e)=>{});
  canvas.addEventListener('click', (e)=>{
    if(!selected || !running) return;
    const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
    const col = Math.floor(x / CW), row = Math.floor(y / CH);
    if(col<0||col>=COLS||row<0||row>=ROWS) return;
    // prevent planting where a mower rests (left-most cell) if mower present and not used
    const mowerHere = lawnmowers.find(m=>m.row===row && m.active && !m.moving);
    if(mowerHere && col === 0) return;
    if(plants.some(p=>p.row===row && p.col===col)) return;
    const def = CARDS.find(c=>c.id===selected); if(!def) return; if(sun < def.cost) return;
    sun -= def.cost;
    // set hp and special fields per plant type
    let maxHp = 12;
    if(def.id === 'sunflower') maxHp = 16;
    else if(def.id === 'wallnut') maxHp = 140;
    else if(def.id === 'cherry') maxHp = 1;
    else if(def.id === 'sunshroom') maxHp = 8;
    else if(def.id === 'peashooter' || def.id === 'icepea') maxHp = 12;
    else if(def.id === 'tallnut') maxHp = 260;
    else if(def.id === 'gatling') maxHp = 16;
    else if(def.id === 'pumpkin') maxHp = 220;
    else if(def.id === 'magnet') maxHp = 28;
    else if(def.id === 'spiker') maxHp = 10;
    const p = { id:Date.now()+Math.random(), row, col, type:def.id, hp: maxHp, maxHp, fireAcc:0, spawnT:performance.now(), scale:0 };
    // type-specific flags
    if(def.id === 'gatling'){ p.gatling = true; p.gatlingRate = 420; }
    if(def.id === 'spiker'){ p.spike = true; p.spikeDamage = 1.2; }
    if(def.id === 'tallnut' || def.id === 'pumpkin'){ p.tank = true; }
    if(def.id === 'magnet'){ p.magnet = true; }
    if(def.id === 'cherry'){ // cherry: invulnerable immediately and fuse = 0.5s
      p.invulnerable = true;
      p.explodeAt = performance.now() + 500;
    }
    plants.push(p);
    spawnPlantParticles((col+0.5)*CW, (row+0.5)*CH, def.id==='sunflower'?'#ffd166':'#7fffd4', 18);
    // start cooldown
    const st = cardState[def.id]; st.cooldownUntil = performance.now()+def.cooldown; st.mask.style.display='block'; st.el.classList.add('disabled');
      // play place SFX
      try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playPlace(); } catch(e){}
    selected = null; document.querySelectorAll('.seedCard').forEach(s=>s.classList.remove('selected'));
    updateUI();
  });

  function spawnZombie(){ if(levelSpawned >= levelTarget) return; const row = Math.floor(Math.random()*ROWS); const maxHp = 14;
    // slow early spawns for the first 20s of the run
    const elapsed = performance.now() - (gameStartTime || performance.now());
    const earlyMult = elapsed < 20000 ? 0.6 : 1.0; // 40% slower for first 20s
    const base = (0.004 + Math.random()*0.01) * earlyMult;
    // assign lower attack power for the smaller/slower zombies
    const attackBase = 0.045;
    const attackMult = base < 0.006 ? 0.6 : 1.0; // slow/small zombies do less damage over time

    // If this is a boss level (every 5th) and this is the last spawn for the level, make a boss
    let isBoss = false;
    if(currentLevel % 5 === 0 && levelSpawned === levelTarget - 1){
      isBoss = true;
    }

    if(isBoss){
      const bhp = maxHp * 3; // boss HP 3x a regular small zombie
      const bossSpeed = base * 0.9; // slightly slower movement base but overall still scaled by global
      const bossAttack = (attackBase * 1.6); // boss attacks faster/stronger
      zombies.push({ id:Date.now()+Math.random(), row, x: COLS + 1, hp:bhp, maxHp:bhp, speedBase: bossSpeed, attack: bossAttack, slowUntil:0, walkPhase: Math.random()*10, attacking:false, boss:true });
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playBeep(220,'square',0.18,0.18); playZombieGroan(); }catch(e){}
    } else {
      zombies.push({ id:Date.now()+Math.random(), row, x: COLS + 1, hp:maxHp, maxHp, speedBase: base, attack: attackBase * attackMult, slowUntil:0, walkPhase: Math.random()*10, attacking:false });
      // play short spawn cue so player notices new zombie
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playZombieGroan(); }catch(e){}
    }
    levelSpawned++; }

  // WebAudio simple SFX generator
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playBeep(freq=440, type='sine', time=0.08, gain=0.12){ try{ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value = gain; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + time); } catch(e){} }
  function playPlace(){ playBeep(520,'sine',0.06,0.08); }
  function playShoot(){ playBeep(860,'sawtooth',0.06,0.12); }
  function playDeath(){ playExplosion(); }

  // Explosion (white-noise burst)
  function playExplosion(){ try{ const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate); const data = buf.getChannelData(0); for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * (1 - i/data.length); } const src = audioCtx.createBufferSource(); src.buffer = buf; const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.6, audioCtx.currentTime + 0.01); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.28); src.connect(g); g.connect(audioCtx.destination); src.start(); } catch(e){} }

  // richer death SFX: pitch drop + noise
  function playDeathSFX(){ try{
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); const f0 = 220 + Math.random()*80;
      o.type = 'sawtooth'; o.frequency.setValueAtTime(f0, now); o.frequency.exponentialRampToValueAtTime(40, now + 0.5);
      g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.25, now + 0.02); g.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
      const hp = audioCtx.createBiquadFilter(); hp.type='lowpass'; hp.frequency.setValueAtTime(1200, now); hp.frequency.exponentialRampToValueAtTime(200, now + 0.6);
      const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate); const data = noiseBuf.getChannelData(0); for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * (1 - i/data.length); }
      const nsrc = audioCtx.createBufferSource(); nsrc.buffer = noiseBuf; const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.18, now); ng.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      o.connect(hp); hp.connect(g); g.connect(audioCtx.destination); nsrc.connect(audioCtx.destination); o.start(now); o.stop(now + 0.6); nsrc.start(now); nsrc.stop(now + 0.22);
    } catch(e){} }

  function playZombieGroan(){ try{ if(!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value = 40 + Math.random()*30; g.gain.value = 0.02 + Math.random()*0.02; const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 220 + Math.random()*160; o.connect(bp); bp.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ try{ o.stop(); }catch(e){} }, 800 + Math.random()*700); }catch(e){} }

  // zombie moan: low drone while any zombies present
  function startZombieMoan(){ try{ if(zombieMoanPlaying) return; zombieMoanOsc = audioCtx.createOscillator(); zombieMoanGain = audioCtx.createGain(); const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 600; zombieMoanOsc.type = 'sawtooth'; zombieMoanOsc.frequency.value = 60 + Math.random()*10; zombieMoanGain.gain.value = 0.0001; zombieMoanOsc.connect(lp); lp.connect(zombieMoanGain); zombieMoanGain.connect(audioCtx.destination); zombieMoanOsc.start(); zombieMoanGain.gain.linearRampToValueAtTime(0.035, audioCtx.currentTime + 0.25); zombieMoanPlaying = true; }catch(e){} }
  function stopZombieMoan(){ try{ if(!zombieMoanPlaying) return; zombieMoanGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.25); setTimeout(()=>{ try{ zombieMoanOsc.stop(); zombieMoanOsc.disconnect(); zombieMoanGain.disconnect(); }catch(e){} zombieMoanOsc = null; zombieMoanGain = null; zombieMoanPlaying = false; }, 300); }catch(e){} }

  // Mower rumble
  function playMower(){ try{ const o1 = audioCtx.createOscillator(); const o2 = audioCtx.createOscillator(); const g = audioCtx.createGain(); const f = 120; o1.type='sawtooth'; o2.type='sine'; o1.frequency.value = f; o2.frequency.value = f*1.4; g.gain.value = 0.08; const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 800; o1.connect(lp); o2.connect(lp); lp.connect(g); g.connect(audioCtx.destination); o1.start(); o2.start(); setTimeout(()=>{ o1.stop(); o2.stop(); }, 220); } catch(e){} }

  // simple background music loop (uses playBeep)
  let musicSeq = [440,0,523,0,659,0,784,0]; let musicIndex = 0; let musicInterval = null;
  function startMusic(){ if(musicInterval) return; musicIndex = 0; musicInterval = setInterval(()=>{ const f = musicSeq[musicIndex % musicSeq.length]; if(f>0){ try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(f,'sine',0.12,0.04); }catch(e){} } musicIndex++; }, 300); }
  function stopMusic(){ if(musicInterval){ clearInterval(musicInterval); musicInterval = null; } }

  function rowHasZombieAhead(row, col){ return zombies.some(z=> z.row===row && z.x > col + 0.2); }

  function update(dt){ particleStep(dt); const now = performance.now();
    // audio: start/stop moan depending on zombies present
    if(zombies.length > 0){ startZombieMoan(); } else { stopZombieMoan(); }
    for(const p of plants){ p.scale = Math.min(1, (now - (p.spawnT||0))/300);
      if(p.type==='sunflower'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 4000){ p.fireAcc = 0; sun += 25; spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, '#ffd166', 6); } }
      else if(p.type==='peashooter'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 900){ if(rowHasZombieAhead(p.row,p.col)){ p.fireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.6), speed:0.45, dmg:3, trail:[], slow:false }); p.lastShoot = now; } } }
      else if(p.type==='gatling'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > (p.gatlingRate || 500)){ if(rowHasZombieAhead(p.row,p.col)){ p.fireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.6), speed:0.65, dmg:4, trail:[], slow:false }); bullets.push({ row:p.row, x: (p.col+0.6), speed:0.65, dmg:4, trail:[], slow:false }); p.lastShoot = now; try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playShoot(); }catch(e){} } } }
      else if(p.type==='icepea'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 900){ if(rowHasZombieAhead(p.row,p.col)){ p.fireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.6), speed:0.45, dmg:2, trail:[], slow:true }); p.lastShoot = now; } } }
      else if(p.type==='cherry'){ if(!p.explodeAt) p.explodeAt = now + 2000; if(now >= p.explodeAt){ // explode
          spawnPlantParticles((p.col+0.5)*CW,(p.row+0.5)*CH,'#ff7b7b',36);
          for(let zi=zombies.length-1; zi>=0; zi--){ const z=zombies[zi]; if(z.row===p.row && Math.abs(z.x - p.col) < 2.2){ z.hp -= 9; } }
          try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playDeath(); } catch(e){}
          plants = plants.filter(pp=>pp!==p);
        }
      else if(p.type==='sunshroom'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 6000){ p.fireAcc = 0; sun += 15; spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, '#fff3b0', 8); } }
    }

    // trigger lawnmower when zombie reaches leftmost cell
    for(const z of zombies){ if(Math.floor(z.x) <= 0){ const mower = lawnmowers.find(m=>m.row===z.row && m.active && !m.moving); if(mower){ mower.moving = true; mower.active = false; mower.x = 0; try{ if(audioCtx.state==='suspended') audioCtx.resume(); playMower(); }catch(e){} } } }

    for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; b.x += b.speed * dt/16; b.trail.push({x:b.x,y:b.row,t:0}); if(b.trail.length>6) b.trail.shift(); if(b.x > COLS+1) bullets.splice(i,1); else { for(let j=0;j<zombies.length;j++){ const z = zombies[j]; if(z.row===b.row && Math.abs(z.x - b.x) < 0.5){ z.hp -= b.dmg; if(b.slow){ z.slowUntil = performance.now() + 2000; } spawnPlantParticles((b.x)*CW, (b.row+0.5)*CH, '#fff', 10); try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playShoot(); } catch(e){} bullets.splice(i,1); break; } } } }

    for(let i=zombies.length-1;i>=0;i--){ const z = zombies[i]; const now2 = performance.now(); const speedFactor = (z.slowUntil && z.slowUntil > now2) ? 0.5 : 1;
      // only move if not currently attacking a plant
      if(!z.attacking){ z.x -= (z.speedBase || z.speed) * speedFactor * ZOMBIE_SPEED_SCALE * dt/16; }
      if(Math.floor(z.x) <= 0){ // zombie reached left edge — check mower
        const mowerAvail = lawnmowers.find(m=>m.row===z.row && (m.moving || m.active));
        if(!mowerAvail || (!mowerAvail.moving && !mowerAvail.active)){ running = false; alert('Zombies win'); return; }
        if(mowerAvail && mowerAvail.moving){ /* mower will handle kill */ }
      }
      const col = Math.floor(z.x);
      // magnets slow nearby zombies
      for(const mp of plants){ if(mp.magnet && mp.row===z.row && Math.abs(z.x - mp.col) < 2.2){ z.slowUntil = Math.max(z.slowUntil || 0, performance.now() + 1200); } }
      const plant = plants.find(p=>p.row===z.row && p.col===col);
      if(plant){
        if(plant.type === 'spiker'){
          // spiker damages zombies but does not block them
          const spikeD = (plant.spikeDamage || 1.2) * dt/16;
          z.hp -= spikeD;
          // occasional particles to indicate spike hit
          if(Math.random() < 0.08) spawnPlantParticles((z.x)*CW, (z.row+0.5)*CH, '#ffb3b3', 4);
          z.attacking = false; // ensure it does not stop
        } else {
          // zombie is attacking this plant; apply this zombie's attack DPS
          const dmg = (z.attack || 0.045) * dt/16;
          plant.hp -= dmg;
          z.attacking = true;
          // prevent zombie from moving into the plant's tile
          z.x = Math.max(z.x, plant.col + 0.6);
          if(plant.hp<=0) plants = plants.filter(p=>p!==plant);
        }
      } else { z.attacking = false; }
      // advance walkPhase for animation
      z.walkPhase = (z.walkPhase || 0) + dt*0.02;
        if(z.hp<=0 && !z.dead){ // enter death/ragdoll phase
            z.dead = true; z.deathTimer = 0; z.deathDur = 1000 + Math.random()*700; z.vx = -0.08 - Math.random()*0.06; z.ry = 0; z.rot = 0; z.alpha = 1;
            spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#f88',10);
            spawnGoreParticles(z.x*CW,(z.row+0.5)*CH, 20 + Math.floor(Math.random()*12));
            try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playDeathSFX(); playBeep(120,'square',0.12,0.14); playZombieGroan(); } catch(e){}
            levelKilled++;
          }
          if(z.dead){ // animate dead body sliding/falling
            z.deathTimer += dt; z.x += (z.vx || -0.06) * dt/16; z.ry += 0.008 * dt/16; z.rot = Math.min(1.6, z.rot + 0.02 * dt/16); z.alpha = Math.max(0, 1 - (z.deathTimer / z.deathDur));
            if(z.deathTimer >= z.deathDur){ zombies.splice(i,1); }
          }
          // if all zombies for this level have spawned and all are killed -> level complete
          if(levelSpawned >= levelTarget && levelKilled >= levelTarget){
            // pause and show overlay
            running = false;
            document.getElementById('levelTitle').textContent = `Level ${currentLevel} Complete`;
            document.getElementById('levelText').textContent = `You cleared ${levelTarget} zombies.`;
            document.getElementById('levelOverlay').style.display = 'flex';
          }
        } }

    // lawnmowers moving across row: destroy zombies in path and remove when off-screen
    for(let mi = lawnmowers.length - 1; mi >= 0; mi--){
      try{
        const m = lawnmowers[mi];
        if(!m) continue;
        if(m.moving){
          m.x += (m.speed || 0.9) * dt/16;
          for(let zi = zombies.length - 1; zi >= 0; zi--){
            const z = zombies[zi];
                if(z && z.row === m.row && z.x <= m.x + 0.6){
              spawnPlantParticles((m.x) * CW, (m.row + 0.5) * CH, '#ffb86b', 12);
              try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playMower(); }catch(e){}
                  // count mower kills toward level progress
                  levelKilled++;
                  zombies.splice(zi, 1);
            }
          }
          if(m.x > COLS + 1){ lawnmowers.splice(mi, 1); }
        }
      }catch(err){ console.error('Lawnmower loop error', err); }
    }

    spawnAcc += dt;
    // dynamic spawn cap based on elapsed run time
    const _elapsedForCap = performance.now() - (gameStartTime || performance.now());
    // early game: fewer simultaneous zombies; increase at 40s and 70s
    // keep cap at 3 for first 40s, 5 for 40-70s, and keep 5 thereafter (no further increase)
    const earlyCap = _elapsedForCap < 40000 ? 3 : 5;
    // spawn only if under cap; add a bit of jitter to interval
    if(spawnAcc > SPAWN_INTERVAL + Math.random()*1200){ spawnAcc = 0; if(zombies.length < earlyCap) spawnZombie(); }
    updateUI();
  }

  // global runtime error display so users can see exceptions in-page
  window.addEventListener('error', (ev)=>{
    try{ const msg = ev.message + ' at ' + ev.filename + ':' + ev.lineno; hud.textContent = 'ERROR: ' + msg; running = false; menuOverlay.style.display = 'flex'; document.getElementById('menuCard').innerHTML = `<h1>Runtime Error</h1><pre style="text-align:left;white-space:pre-wrap;max-height:240px;overflow:auto">${msg}</pre><button id="reloadBtn">Reload</button>`; document.getElementById('reloadBtn').onclick=()=>location.reload(); }catch(e){}
  });
  window.addEventListener('unhandledrejection', (ev)=>{ try{ const msg = (ev.reason && ev.reason.message) || String(ev.reason); hud.textContent = 'Promise Rejection: '+msg; running=false; menuOverlay.style.display='flex'; }catch(e){} });

  function render(){ ctx.clearRect(0,0,W,H); const grd = ctx.createLinearGradient(0,0,0,H); grd.addColorStop(0,'#4e8b45'); grd.addColorStop(1,'#2f6b2f'); ctx.fillStyle=grd; ctx.fillRect(0,0,W,H); ctx.strokeStyle='rgba(0,0,0,0.12)'; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ ctx.strokeRect(c*CW+1, r*CH+1, CW-2, CH-2); }

    // (screen shake removed)
    ctx.save();

    for(const p of particles){ const alpha = 1 - p.t/p.life; ctx.fillStyle = p.color; ctx.globalAlpha = alpha; ctx.beginPath(); const size = p.size || Math.max(1,4*(1-alpha)); ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }

    // draw lawnmowers (icons on the left or moving across)
    for(const m of lawnmowers){ const mx = m.moving ? m.x*CW : 0.28*CW; const my = (m.row + 0.5)*CH; const img = spriteImages.lawnmower; const mw = CW*0.5, mh = CH*0.4; ctx.save(); ctx.translate(mx, my); if(m.moving){ ctx.globalAlpha = 1; ctx.rotate(Math.sin(performance.now()/60 + m.row)*0.04); } else { ctx.globalAlpha = 0.9; } ctx.drawImage(img, -mw/2, -mh/2, mw, mh); ctx.restore(); }

    for(const p of plants){ const x=(p.col+0.5)*CW,y=(p.row+0.5)*CH; const img = spriteImages[p.type] || spriteImages.sunflower; const w=CW*0.6,h=CH*0.8; const now = performance.now(); const bob = Math.sin(now/400 + p.col)*3; ctx.save();
      // subtle breathing / pulse
      const pulse = 1 + 0.04 * Math.sin(now/300 + (p.col+p.row)*0.7);
      // peashooter recoil when shooting
      let recoil = 0; if(p.lastShoot && now - p.lastShoot < 180) recoil = 6 * (1 - (now - p.lastShoot)/180);
      ctx.translate(x + recoil, y + bob);
      ctx.shadowColor='rgba(0,0,0,0.45)'; ctx.shadowBlur=10; ctx.drawImage(img, -w/2 * p.scale, -h/2 * p.scale, w*p.scale, h*p.scale);
      // redraw with pulse (overlay draw to simulate subtle scale)
      ctx.drawImage(img, -w/2 * p.scale * pulse, -h/2 * p.scale * pulse, w*p.scale*pulse, h*p.scale*pulse);
      // extra type-specific visual flourishes
      if(p.type === 'sunflower'){
        // rotating petal highlight
        ctx.save(); ctx.globalAlpha = 0.9; ctx.fillStyle = 'rgba(255,230,120,0.9)'; ctx.translate(w*0.12, -h*0.28); ctx.rotate((now/600 + p.col)*0.08); ctx.beginPath(); ctx.ellipse(0,0,w*0.12,h*0.06,0,0,Math.PI*2); ctx.fill(); ctx.restore();
      }
      if(p.type === 'peashooter' || p.type === 'icepea'){
        // draw animated muzzle to suggest firing
        const muzzleSize = 6 + (p.lastShoot && now - p.lastShoot < 200 ? 6*(1 - (now - p.lastShoot)/200) : 0);
        ctx.fillStyle = p.type==='icepea' ? '#8fe6ff' : '#dfffdc'; ctx.globalAlpha = 0.95; ctx.beginPath(); ctx.arc(w*0.35, -h*0.08, muzzleSize, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
        if(p.type==='icepea'){ ctx.fillStyle='#cfefff'; ctx.globalAlpha=0.6; ctx.beginPath(); ctx.arc(w*0.32, -h*0.08, muzzleSize*1.6,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
      }
      // small muzzle flash for shooters
      if((p.type==='peashooter' || p.type==='icepea') && recoil>0){ ctx.fillStyle = p.type==='icepea' ? '#bfefff' : '#dfffdc'; ctx.globalAlpha = 0.9; ctx.beginPath(); ctx.arc(w*0.35, -h*0.08, 6 + recoil*0.6, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
      ctx.restore(); const hpPct = Math.max(0, p.hp / (p.maxHp || 12)); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(x - w*0.4, y - h*0.6, w*0.8, 6); ctx.fillStyle='#ff6b6b'; ctx.fillRect(x - w*0.4, y - h*0.6, w*0.8 * hpPct, 6); }

    for(const b of bullets){ for(const t of b.trail){ ctx.globalAlpha=0.18; ctx.fillStyle=b.slow? '#bfefff' : '#dfffdc'; ctx.beginPath(); ctx.arc(t.x*CW,(t.y+0.5)*CH,6,0,Math.PI*2); ctx.fill(); } ctx.globalAlpha=1; ctx.fillStyle=b.slow? '#9fe8ff' : '#e0ffd4'; ctx.beginPath(); ctx.arc(b.x*CW,(b.row+0.5)*CH,6,0,Math.PI*2); ctx.fill(); }

    ctx.font='28px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; for(const z of zombies){ const x=z.x*CW,y=(z.row+0.5)*CH; const img = spriteImages.zombie; const wobble = Math.sin((z.walkPhase || 0) + performance.now()/300) * 4;
      // scale boss size visually
      const bossScale = z.boss ? 3 : 1;
      const zw = CW*0.6 * bossScale, zh = CH*0.9 * bossScale;
      if(z.dead){ // corpse lying / sliding animation
        ctx.save(); ctx.globalAlpha = z.alpha !== undefined ? z.alpha : 1; ctx.translate(x, y + wobble + (zh*0.12)); ctx.rotate(1.2 + (z.rot || 0)); ctx.drawImage(img, -zw/1.2, -zh*0.18, zw*1.1, zh*0.6); ctx.restore();
      } else {
        ctx.save(); // body sway + stagger
        const sway = Math.sin((z.walkPhase||0) * 1.4 + performance.now()/380) * 0.06;
        ctx.translate(x, y + wobble);
        ctx.rotate(sway);
        // draw main body
        ctx.drawImage(img, -zw/2, -zh/2, zw, zh);
        // red glowing eyes overlay
        ctx.fillStyle = '#ff4545'; ctx.globalAlpha = 0.95; const eyeY = -zh*0.28; const eyeXOff = zw*0.16; ctx.beginPath(); ctx.ellipse(-eyeXOff, eyeY, zw*0.06, zh*0.06, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(eyeXOff, eyeY, zw*0.06, zh*0.06, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
        // wounds: blotches
        ctx.fillStyle = 'rgba(120,20,20,0.45)'; ctx.beginPath(); ctx.ellipse(-zw*0.08, -zh*0.02, zw*0.08, zh*0.06, -0.4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(zw*0.18, zh*0.05, zw*0.06, zh*0.04, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
      const barW=CW*0.6; ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(x-barW/2,y-CH*0.4,barW,8); const maxZ = z.maxHp || 12; ctx.fillStyle='#ff6b6b'; ctx.fillRect(x-barW/2,y-CH*0.4,barW*Math.max(0,z.hp)/maxZ,8);
    }

    // vignette overlay for mood
    ctx.save(); const vg = ctx.createRadialGradient(W*0.5, H*0.5, H*0.2, W*0.5, H*0.5, H*0.9); vg.addColorStop(0, 'rgba(0,0,0,0)'); vg.addColorStop(1, 'rgba(0,0,0,0.25)'); ctx.fillStyle = vg; ctx.fillRect(0,0,W,H); ctx.restore();
    ctx.restore();
  }

  function loop(ts){ if(!running) return; const dt = ts - last; last = ts; update(dt); render(); requestAnimationFrame(loop); }
  // debug: log when loop starts
  const _oldLoop = loop;
  function loopWrapper(ts){ console.log('loop called, running=', running); return _oldLoop(ts); }
  // replace loop with wrapper so requestAnimationFrame(loop) logs
  loop = loopWrapper;

  // controls
      btnStart.onclick = ()=>{ if(!running){ initLawnmowers();
        // treat a fresh start (no spawned/killed yet) as new game and reset to level 1
        if(levelSpawned === 0 && levelKilled === 0){ currentLevel = 1; }
        levelSpawned = 0; levelKilled = 0; levelTarget = 20 + (currentLevel-1)*10; spawnAcc = 0;
          running=true; gameStartTime = performance.now(); last=performance.now(); console.log('btnStart clicked — starting loop'); try{ menuOverlay.style.display='none'; menuOverlay.classList.remove('show'); }catch(e){} requestAnimationFrame(loop); try{ startMusic(); }catch(e){} } };
  btnPause.onclick = ()=>{ running = !running; if(running){ last = performance.now(); requestAnimationFrame(loop); try{ startMusic(); }catch(e){} } else { try{ stopMusic(); }catch(e){} } };
  btnReset.onclick = ()=>{ sun=200; plants=[]; zombies=[]; bullets=[]; particles=[]; running=false; initLawnmowers(); updateUI(); menuOverlay.style.display='flex'; try{ stopMusic(); }catch(e){};
    // reset level progression
    currentLevel = 1; levelTarget = 20; levelSpawned = 0; levelKilled = 0; spawnAcc = 0;
    try{ stopZombieMoan(); }catch(e){}
  };
  playBtn.onclick = ()=>{ initLawnmowers(); // ensure level counters start fresh when entering from menu
    levelSpawned = 0; levelKilled = 0; currentLevel = 1; levelTarget = 20; spawnAcc = 0;
    console.log('playBtn clicked — starting game'); try{ menuOverlay.style.display='none'; menuOverlay.classList.remove('show'); }catch(e){} running=true; gameStartTime = performance.now(); last=performance.now(); requestAnimationFrame(loop); try{ startMusic(); }catch(e){} };

  // next level button
  const nextLevelBtn = document.getElementById('nextLevelBtn');
  function clearPlantsAndResetUI(){ plants = []; bullets = []; particles = []; zombies = []; initLawnmowers(); // reset cooldowns
    Object.values(cardState).forEach(s=>{ s.cooldownUntil = 0; s.mask.style.display='none'; s.el.classList.remove('disabled'); });
    sun = INITIAL_SUN; updateUI(); }

  function doLevelTransition(){ const overlay = document.getElementById('levelOverlay'); const title = document.getElementById('levelTitle'); const text = document.getElementById('levelText');
    // show animated overlay
    title.textContent = `Level ${currentLevel+1}`;
    text.textContent = `Preparing level ${currentLevel+1}...`;
    overlay.style.display = 'flex'; setTimeout(()=> overlay.classList.add('show'), 30);
    // play small fanfare
    try{ if(audioCtx.state==='suspended') audioCtx.resume(); playBeep(880,'sine',0.12,0.06); setTimeout(()=>playBeep(660,'sine',0.12,0.06),140); }catch(e){}
    setTimeout(()=>{
      // advance level state
      currentLevel++;
      levelTarget = 20 + (currentLevel-1)*10;
      levelSpawned = 0; levelKilled = 0; spawnAcc = 0;
      // unlock a new plant (if available)
      try{
        if(EXTRA_CARDS.length > 0){ const next = EXTRA_CARDS.shift(); CARDS.push(next); buildSeedBar(); hud.textContent = `Unlocked: ${next.name}`; setTimeout(()=>updateUI(), 200); }
      }catch(e){}
      // reset garden: plants, sun, cooldowns
      clearPlantsAndResetUI();
      // hide overlay and resume
      overlay.classList.remove('show'); overlay.style.display='none';
      running = true; last = performance.now(); requestAnimationFrame(loop);
    }, 1000);
  }

  nextLevelBtn.onclick = doLevelTransition;

  window.addEventListener('keydown', e=>{ if(e.key==='r'||e.key==='R') btnReset.click(); });

  // init
  buildSeedBar(); updateUI(); initLawnmowers();
  // safety: ensure overlays and level state are consistent on load
  try{
    const lvlOverlay = document.getElementById('levelOverlay'); if(lvlOverlay) lvlOverlay.style.display = 'none';
    const nb = document.getElementById('nextLevelBtn'); if(nb) nb.onclick = doLevelTransition;
  }catch(e){}
  // reset core state to a clean start
  running = false; currentLevel = 1; levelTarget = 20; levelSpawned = 0; levelKilled = 0; spawnAcc = 0; sun = INITIAL_SUN; updateUI();

  // end of script
  </script>
</body>
</html>