<!DOCTYPE html>
<script>window.devNoCd = false;</script>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Garden Defense</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{ --panel:#0f4122; --panel-2:#153d24; --accent:#ffd166 }
    /* Level transition animations */
    @keyframes popIn { from{ transform:scale(0.7); opacity:0 } to{ transform:scale(1); opacity:1 } }
    #levelOverlay.show #levelCard{ animation: popIn 420ms cubic-bezier(.2,.9,.3,1); }
    #levelCard h2{ margin:0; font-size:28px; }
    #levelCard p{ margin:8px 0 0 0 }
    #body, html { width: 100vw; height: 100vh; margin: 0; padding: 0; background: #2b7a3a; font-family: 'Inter', Arial, sans-serif; overflow: hidden; }
    #wrap {
      max-width: 100vw;
      max-height: 100vh;
      background:linear-gradient(#0f3d1e,#0b2f18);
      padding:14px;
      border-radius:12px;
      box-shadow:0 20px 60px rgba(0,0,0,0.6);
      color:#fff;
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(var(--game-scale));
      transform-origin: center center;
      will-change: transform;
      z-index: 1;
      overflow: visible;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
        // Safe area
        this.applySafeAreaInsets();
        if (this.onResizeCallback) {
          this.onResizeCallback({
            scale: this.scale,
            dpr: this.dpr,
            viewportW,
            viewportH,
            offsetX: 0,
            offsetY: 0
          });
        }
      }
      border-radius: 14px;
      /* lighter wood tones + very subtle grain overlay */
      background:
        linear-gradient(180deg, #a86a43 0%, #d79b66 25%, #ba8357 50%, #e0a26b 75%, #8b5630 100%),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.01) 0 2px, rgba(0,0,0,0.02) 2px 6px);
      box-shadow: 0 8px 18px rgba(0,0,0,0.35), inset 0 4px 10px rgba(255,255,255,0.05);
      border: 2px solid rgba(0,0,0,0.10);
      z-index: -1;
    }
    #top::after{
      content: '';
      position: absolute;
      left: 6px; right: 6px; top: 6px; bottom: 6px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.045), rgba(0,0,0,0.03));
      box-shadow: inset 0 1px 4px rgba(0,0,0,0.12);
      z-index: 0;
      pointer-events: none;
      mix-blend-mode: multiply;
      opacity: 0.94;
    }
    #seedBar{ display:flex; gap:4px; padding:4px; background:rgba(0,0,0,0.06); border-radius:8px; align-items:center; flex-wrap:wrap; min-width:0; overflow-x:auto; }
    .seedCard{ position:relative; width:60px; height:48px; background:linear-gradient(180deg,#1d5b2f,#174a27); border-radius:8px; padding:4px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.03); cursor:pointer; display:flex; align-items:center; gap:4px; font-size:11px }
    /* Thin wooden border for seed cards (subtle grain + thin rim) */
    .seedCard{
      border: 1.2px solid rgba(0,0,0,0.18);
      background-image: linear-gradient(180deg,#1d5b2f,#174a27), repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0 2px, rgba(0,0,0,0.03) 2px 6px);
      background-blend-mode: overlay;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.03), 0 6px 14px rgba(0,0,0,0.18);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .seedCard:active, .seedCard.selected{ transform: translateY(1px); box-shadow: inset 0 1px 0 rgba(255,255,255,0.03), 0 4px 10px rgba(0,0,0,0.2); }
    .seedCard.disabled{ opacity:0.55; cursor:default }
    .seedIcon{ width:32px; height:32px; border-radius:8px; overflow:hidden; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,0.03); }
    .seedIcon img {
      display: block;
      margin: 0 auto;
      position: static !important;
      top: 0 !important;
      transform: translateY(0) !important;
      max-height: 44px;
      max-width: 44px;
    }
    .seedInfo{ font-size:12px; line-height:1 }
    .seedCost{ background: var(--accent); color: #111; padding:3px 7px; border-radius:8px; font-weight:800; font-size:12px; display:inline-block; margin-top:5px }
    /* Sun tile inside seed bar */
    .sunTile{ width:84px; height:64px; background: linear-gradient(180deg,var(--accent), #f6c24a); border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:#111; font-weight:800; box-shadow: 0 6px 18px rgba(0,0,0,0.25); margin-right:6px }
    .sunTile .sunNum{ font-size:16px; line-height:1 }
    .sunTile .sunLabel{ font-size:11px; opacity:0.95 }
    .ctrlStack{ display:flex; flex-direction:column; gap:6px; margin-left:auto; align-items:flex-end }
    .ctrlStack button{ padding:6px 8px; width:72px; text-align:center }
    /* Thin wooden rim for toolbar / control buttons (subtle) */
    .ctrlStack button, #controls > button, #rightControls button, .lang-btn {
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 8px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.03), 0 4px 10px rgba(0,0,0,0.12);
      background-image: repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0 2px, rgba(0,0,0,0.03) 2px 6px);
      background-blend-mode: multiply;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .ctrlStack button:active, #controls > button:active, #rightControls button:active { transform: translateY(1px); box-shadow: inset 0 1px 0 rgba(255,255,255,0.03), 0 2px 6px rgba(0,0,0,0.14); }
    .cooldownMask{ position:absolute; left:0; top:0; width:100%; height:100%; background:linear-gradient(to top, rgba(0,0,0,0.55), rgba(0,0,0,0.2)); transform-origin: bottom; pointer-events:none }
    #controls{ margin-left:auto; display:flex; gap:6px; align-items:center }
    button{ padding:4px 8px; border-radius:6px; border:0; cursor:pointer; background:#fff; color:#111; font-size:13px }
    #gameWrap{ margin-top:8px; background:linear-gradient(#2f7c3f,#23602b); border-radius:8px; padding:14px; position:relative }
    /* Inner wooden inset around the play field */
    #gameWrap::before{
      content: '';
      position: absolute;
      inset: -8px;
      border-radius: 12px;
      background: linear-gradient(135deg,#8a5331 0%, #b27244 30%, #7d4a2a 60%, #b07a45 100%);
      z-index: -1;
      box-shadow: inset 0 4px 10px rgba(0,0,0,0.35);
    }
    #gameWrap::after{
      content: '';
      position: absolute;
      left: 10px; right: 10px; top: 10px; bottom: 10px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
      z-index: 0;
      pointer-events: none;
    }
    #game{ display:block; background:transparent; border-radius:6px; width:100%; height:660px; transform: translateX(-12px); }
    #hud{ margin-top:8px }
    /* Animated 2D Menu overlay */
    #menuOverlay{ 
      position:absolute; inset:0; 
      display:flex; align-items:center; justify-content:center; 
      background: linear-gradient(180deg, #1a3a2a 0%, #0d1f15 100%);
      z-index:40; 
      overflow: visible;
    }
    /* Animated background elements */
    .menu-bg {
      position: absolute; inset: 0; pointer-events: none; overflow: hidden;
      z-index: 1;
    }
    .menu-sun {
      position: absolute; top: 40px; right: 80px;
      width: 120px; height: 120px;
      background: radial-gradient(circle, #fff9c4 0%, #ffeb3b 30%, #ff9800 60%, transparent 70%);
      border-radius: 50%;
      animation: sunPulse 3s ease-in-out infinite;
      box-shadow: 0 0 60px 30px rgba(255,235,59,0.4), 0 0 100px 60px rgba(255,152,0,0.2);
      pointer-events: none;
    }
    @keyframes sunPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.9; }
    }
    .menu-cloud {
      position: absolute; background: rgba(255,255,255,0.15);
      border-radius: 50px; filter: blur(2px);
      pointer-events: none;
    }
    .cloud1 { top: 60px; left: -100px; width: 200px; height: 60px; animation: cloudMove1 25s linear infinite; }
    .cloud2 { top: 120px; left: -150px; width: 180px; height: 50px; animation: cloudMove2 30s linear infinite; animation-delay: 5s; }
    .cloud3 { top: 180px; left: -80px; width: 150px; height: 45px; animation: cloudMove3 35s linear infinite; animation-delay: 10s; }
    @keyframes cloudMove1 { from { left: -200px; } to { left: 110%; } }
    @keyframes cloudMove2 { from { left: -180px; } to { left: 110%; } }
    @keyframes cloudMove3 { from { left: -150px; } to { left: 110%; } }
    .menu-grass {
      position: absolute; bottom: 0; left: 0; right: 0; height: 180px;
      background: linear-gradient(to bottom, #2d5a1e 0%, #1e4a12 50%, #153a0d 100%);
      pointer-events: none;
    }
    .grass-blade {
      position: absolute; bottom: 0; width: 8px; 
      background: linear-gradient(to top, #2d5a1e, #4caf50);
      border-radius: 4px 4px 0 0;
      transform-origin: bottom center;
      animation: grassSway 2s ease-in-out infinite;
    }
    @keyframes grassSway {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }
    .menu-flower {
      position: absolute; bottom: 20px;
      animation: flowerBob 2s ease-in-out infinite;
    }
    @keyframes flowerBob {
      0%, 100% { transform: translateY(0) rotate(-2deg); }
      50% { transform: translateY(-5px) rotate(2deg); }
    }
    .menu-zombie {
      position: absolute; bottom: 60px; right: 100px;
      font-size: 80px; animation: zombieWalk 8s linear infinite;
      filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.5));
      pointer-events: none;
    }
    @keyframes zombieWalk {
      0%, 100% { transform: translateX(0) rotate(-3deg); }
      25% { transform: translateX(-10px) rotate(3deg); }
      50% { transform: translateX(0) rotate(-3deg); }
      75% { transform: translateX(10px) rotate(3deg); }
    }
    .menu-plant {
      position: absolute; bottom: 50px; left: 120px;
      font-size: 70px; animation: plantIdle 1.5s ease-in-out infinite;
      filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.5));
      pointer-events: none;
    }
    @keyframes plantIdle {
      0%, 100% { transform: scale(1) rotate(-2deg); }
      50% { transform: scale(1.05) rotate(2deg); }
    }
    /* Floating particles */
    .menu-particle {
      position: absolute; border-radius: 50%;
      animation: particleFloat 6s ease-in-out infinite;
      pointer-events: none;
    }
    @keyframes particleFloat {
      0%, 100% { transform: translateY(0) scale(1); opacity: 0.6; }
      50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
    }
    /* Menu card styling */
    #menuCard{ 
      width:520px; padding:40px; 
      background: linear-gradient(145deg, rgba(30,70,45,0.95), rgba(15,45,25,0.98));
      border-radius:20px; text-align:center;
      border: 3px solid rgba(100,180,100,0.3);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
      position: relative; z-index: 20;
      backdrop-filter: blur(10px);
      pointer-events: auto;
    }
    #menuCard h1{ 
      margin:0 0 8px 0; 
      font-size: 48px;
      background: linear-gradient(180deg, #8bc34a 0%, #4caf50 50%, #2e7d32 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      filter: drop-shadow(2px 3px 3px rgba(0,0,0,0.4));
    }
    #menuCard .subtitle {
      color: #a5d6a7; font-size: 16px; margin-bottom: 25px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    #menuCard p{ color:rgba(255,255,255,0.85) }
    .menu-btn {
      padding: 14px 40px; font-size: 18px; font-weight: bold;
      border: none; border-radius: 30px; cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase; letter-spacing: 1px;
      pointer-events: auto !important;
      position: relative;
      z-index: 100;
    }
    .menu-btn.primary {
      background: linear-gradient(180deg, #66bb6a 0%, #43a047 50%, #2e7d32 100%);
      color: white;
      box-shadow: 0 6px 20px rgba(76,175,80,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
    }
    .menu-btn.primary:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 10px 30px rgba(76,175,80,0.5);
    }
    .menu-btn.secondary {
      background: linear-gradient(180deg, #455a64 0%, #37474f 100%);
      color: #b0bec5;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .menu-btn.secondary:hover {
      transform: translateY(-2px);
      color: white;
    }
    /* Decorative elements */
    .menu-leaves {
      position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
      font-size: 40px; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
    }
    .version-tag {
      position: absolute; top: 15px; right: 20px;
      background: rgba(0,0,0,0.3); padding: 4px 12px; border-radius: 10px;
      font-size: 12px; color: #81c784;
    }
    /* Language selector */
    .lang-selector {
      position: absolute; top: 20px; left: 20px; z-index: 15;
    }
    .lang-btn {
      display: flex; align-items: center; gap: 8px;
      padding: 10px 16px; background: rgba(0,0,0,0.4);
      border: 2px solid rgba(100,180,100,0.4); border-radius: 25px;
      color: #a5d6a7; font-size: 14px; cursor: pointer;
      transition: all 0.3s ease;
    }
    .lang-btn:hover { background: rgba(0,0,0,0.6); border-color: rgba(100,180,100,0.7); }
    .lang-dropdown {
      display: none; position: absolute; top: 50px; left: 0;
      background: rgba(20,40,30,0.95); border: 2px solid rgba(100,180,100,0.4);
      border-radius: 12px; overflow: hidden; min-width: 150px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      pointer-events: none;
    }
    .lang-dropdown.show { display: block; pointer-events: auto; }
    .lang-option {
      display: flex; align-items: center; gap: 10px;
      padding: 12px 16px; color: #c8e6c9; cursor: pointer;
      transition: all 0.2s ease; border: none; background: transparent;
      width: 100%; text-align: left; font-size: 14px;
    }
    .lang-option:hover { background: rgba(76,175,80,0.3); }
    .lang-option.active { background: rgba(76,175,80,0.5); color: white; }
    .lang-flag { font-size: 20px; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="top">
      <div id="seedBar">
          <div class="ctrlStack">
            <button id="pause">Pause</button>
            <button id="reset">Reset</button>
          </div>
      </div>
      <div id="controls">
        <button id="speedBtn" style="margin-left:10px; background:#ff6b6b; color:#fff">âš¡ 1x</button>
        <button id="skipLevel" style="margin-left:10px; background:#ffd166; color:#111">Skip Level</button>
      </div>
    </div>

    <div id="gameWrap">
      <canvas id="game"></canvas>
      <div id="hud"></div>
    </div>

    <div id="menuOverlay">
      <!-- Menu Card - placed FIRST for z-order -->
      <div id="menuCard">
        <div class="menu-leaves">ğŸŒ¿ğŸƒğŸŒ¿</div>
        <div class="version-tag">v2.0</div>
        <h1>ğŸŒ± Garden Defense ğŸŒ±</h1>
        <p class="subtitle">Báº£o vá»‡ khu vÆ°á»n khá»i báº§y zombie!</p>

        <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
          <button id="playBtn" class="menu-btn primary" onclick="startGame()">ğŸ® ChÆ¡i Ngay</button>
          <button id="menuHow" class="menu-btn secondary" onclick="showHowToPlay()">ğŸ“– HÆ°á»›ng Dáº«n</button>
        </div>
        <p style="margin-top: 25px; font-size: 12px; color: rgba(255,255,255,0.5);">ğŸŒ Thu tháº­p náº¯ng â€¢ ğŸŒº Trá»“ng cÃ¢y â€¢ ğŸ’€ TiÃªu diá»‡t zombie</p>
      </div>
      
      <!-- Language Selector -->
      <div class="lang-selector">
        <div class="lang-btn" id="langBtn">
          <span class="lang-flag" id="currentFlag">ğŸ‡»ğŸ‡³</span>
          <span id="currentLang">Tiáº¿ng Viá»‡t</span>
          <span>â–¼</span>
        </div>
        <div class="lang-dropdown" id="langDropdown">
          <button class="lang-option active" data-lang="vi">
            <span class="lang-flag">ğŸ‡»ğŸ‡³</span>
            <span>Tiáº¿ng Viá»‡t</span>
          </button>
          <button class="lang-option" data-lang="en">
            <span class="lang-flag">ğŸ‡ºğŸ‡¸</span>
            <span>English</span>
          </button>
        </div>
      </div>
      
      <!-- Animated Background (behind everything) -->
      <div class="menu-bg">
        <div class="menu-sun"></div>
        <div class="menu-cloud cloud1"></div>
        <div class="menu-cloud cloud2"></div>
        <div class="menu-cloud cloud3"></div>
        <div class="menu-grass"></div>
        <div class="menu-particle" style="left:10%; top:30%; width:8px; height:8px; background:#fff9c4; animation-delay:0s;"></div>
        <div class="menu-particle" style="left:20%; top:50%; width:6px; height:6px; background:#c5e1a5; animation-delay:1s;"></div>
        <div class="menu-particle" style="left:80%; top:40%; width:10px; height:10px; background:#fff59d; animation-delay:2s;"></div>
        <div class="menu-particle" style="left:70%; top:60%; width:5px; height:5px; background:#a5d6a7; animation-delay:3s;"></div>
        <div class="menu-particle" style="left:30%; top:70%; width:7px; height:7px; background:#dcedc8; animation-delay:4s;"></div>
        <div class="menu-plant">ğŸŒ»</div>
        <div class="menu-zombie">ğŸ§Ÿ</div>
      </div>
    </div>
    <div id="howOverlay" style="display:none; position:fixed; inset:0; align-items:center; justify-content:center; background:rgba(0,0,0,0.85); z-index:100">
      <div id="howCard" style="width:500px; padding:30px; background:linear-gradient(145deg, rgba(30,70,45,0.98), rgba(15,45,25,0.99)); border-radius:20px; text-align:center; border: 3px solid rgba(100,180,100,0.4); box-shadow: 0 20px 60px rgba(0,0,0,0.7);">
        <h2 id="howTitle" style="margin-bottom:20px; color:#ffd166; font-size:28px;">ğŸ“– HÆ°á»›ng Dáº«n ChÆ¡i</h2>
        <p id="howText" style="margin-bottom:15px; color:#fff;">Trá»“ng cÃ¢y vÃ  báº£o vá»‡ nhÃ  báº¡n khá»i lÅ© zombie</p>
        <div style="text-align:left; color:#fff; font-size:16px; line-height:1.8;">
          <p id="howTip1" style="margin-bottom:15px;"></p>
          <p id="howTip2" style="margin-bottom:15px;"></p>
          <p id="howTip3" style="margin-bottom:15px;"></p>
          <p id="howTip4" style="margin-bottom:15px;"></p>
          <p id="howTip5" style="margin-bottom:15px;"></p>
          <p id="howTipHammer" style="margin-bottom:15px;"></p>
          <p id="howTip6" style="margin-bottom:15px;"></p>
        </div>
        <div style="margin-top:25px"><button id="howBackBtn" class="menu-btn primary" style="padding:12px 40px;">â† Quay láº¡i</button></div>
      </div>
    </div>
    <div id="levelOverlay" style="display:none; position:absolute; inset:0; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); z-index:50">
      <div id="levelCard" style="width:420px; padding:20px; background:linear-gradient(#163d22,#0f2d16); border-radius:10px; text-align:center">
        <h2 id="levelTitle">Level complete</h2>
        <p id="levelText">Ready for next level?</p>
        <div style="margin-top:12px"><button id="nextLevelBtn">Next Level</button></div>
      </div>
    </div>
    <!-- Win Overlay -->
    <div id="winOverlay" style="display:none; position:absolute; inset:0; align-items:center; justify-content:center; background:rgba(0,0,0,0.8); z-index:100">
      <div id="winCard" style="width:450px; padding:40px; background:linear-gradient(145deg, #1b5e20, #388e3c); border-radius:20px; text-align:center; border: 3px solid #ffd166; box-shadow: 0 20px 60px rgba(0,0,0,0.7);">
        <div style="font-size:80px; margin-bottom:20px;">ğŸ†</div>
        <h2 id="winTitle" style="margin:0 0 10px 0; font-size:36px; color:#ffd166;">You Win!</h2>
        <p id="winText" style="font-size:20px; color:#fff; margin-bottom:30px;">Thank you for playing!</p>
      </div>
    </div>
    <!-- Game Over Overlay -->
    <div id="gameOverOverlay" style="display:none; position:absolute; inset:0; align-items:center; justify-content:center; background:rgba(0,0,0,0.8); z-index:55">
      <div id="gameOverCard" style="width:450px; padding:40px; background:linear-gradient(145deg, rgba(80,20,20,0.95), rgba(40,10,10,0.98)); border-radius:20px; text-align:center; border: 3px solid rgba(200,50,50,0.4); box-shadow: 0 20px 60px rgba(0,0,0,0.7);">
        <div style="font-size:80px; margin-bottom:20px;">ğŸ’€</div>
        <h2 id="gameOverTitle" style="margin:0 0 10px 0; font-size:36px; color:#ff6b6b;">Game Over!</h2>
        <p id="gameOverText" style="font-size:18px; color:#ffab91; margin-bottom:30px;">Zombie Ä‘Ã£ xÃ¢m nháº­p!</p>
        <p id="tryAgainText" style="font-size:24px; color:#fff; margin-bottom:20px;">Thá»­ láº¡i?</p>
        <button id="restartBtn" style="padding:15px 50px; font-size:20px; font-weight:bold; background:linear-gradient(180deg, #ef5350 0%, #c62828 100%); color:white; border:none; border-radius:30px; cursor:pointer; box-shadow: 0 6px 20px rgba(239,83,80,0.4); transition: all 0.3s ease;">ğŸ”„ ChÆ¡i Láº¡i</button>
      </div>
    </div>
    <script>
    // Disable all buttons except reset when game over overlay is shown
    function showGameOverOverlay() {
      document.getElementById('gameOverOverlay').style.display = 'flex';
      // Remove all buttons except the restart button, and ensure restart works
      const overlay = document.getElementById('gameOverOverlay');
      const buttons = overlay.querySelectorAll('button');
      buttons.forEach(btn => {
        if (btn.id !== 'restartBtn') {
          btn.remove();
        }
      });
      // Ensure reset button is enabled and wired up
      const restartBtn = overlay.querySelector('#restartBtn');
      if (restartBtn) {
        restartBtn.disabled = false;
        restartBtn.style.opacity = 1;
        restartBtn.style.pointerEvents = 'auto';
        restartBtn.onclick = function() {
          // Trigger the toolbar reset (keeps styles separate) if present
          const toolbarReset = document.getElementById('reset');
          if (toolbarReset) toolbarReset.click();
          try{ stopMusic(); }catch(e){}
          try{ stopZombieMoan(); }catch(e){}
          document.getElementById('gameOverOverlay').style.display = 'none';
        };
      }
    }
    // Replace any other button logic that shows game over with showGameOverOverlay
    </script>
  </div>

  <script>
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GLOBAL FLAGS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let gameInitialized = false;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GLOBAL FUNCTIONS (must be defined early for onclick handlers)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function startGame() {
    document.getElementById('menuOverlay').style.display = 'none';
    document.getElementById('playBtn').blur();
  }
  
  function showHowToPlay() {
    document.getElementById('howOverlay').style.display = 'flex';
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LANGUAGE / TRANSLATION SYSTEM
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let currentLanguage = 'vi';
  
  const translations = {
    vi: {
      // Menu
      gameTitle: 'ğŸŒ± Garden Defense ğŸŒ±',
      subtitle: 'Báº£o vá»‡ khu vÆ°á»n khá»i báº§y zombie!',
      playBtn: 'ğŸ® ChÆ¡i Ngay',
      howBtn: 'ğŸ“– HÆ°á»›ng Dáº«n',
      menuTips: 'ğŸŒ Thu tháº­p náº¯ng â€¢ ğŸŒº Trá»“ng cÃ¢y â€¢ ğŸ’€ TiÃªu diá»‡t zombie',
      // How to play
      howTitle: 'HÆ°á»›ng Dáº«n ChÆ¡i',
      howText: 'Trá»“ng cÃ¢y vÃ  báº£o vá»‡ nhÃ  báº¡n khá»i lÅ© zombie',
      backBtn: 'Quay láº¡i',
      howTip1: 'ğŸŒ <strong>Thu tháº­p náº¯ng</strong> - Click vÃ o máº·t trá»i rÆ¡i xuá»‘ng Ä‘á»ƒ láº¥y nÄƒng lÆ°á»£ng',
      howTip2: 'ğŸŒ± <strong>Trá»“ng cÃ¢y</strong> - Chá»n cÃ¢y tá»« thanh cÃ´ng cá»¥ vÃ  Ä‘áº·t vÃ o Ã´ trá»‘ng',
      howTip3: 'ğŸ›¡ï¸ <strong>Báº£o vá»‡</strong> - KhÃ´ng Ä‘á»ƒ zombie Ä‘i qua hÃ ng rÃ o bÃªn trÃ¡i',
      howTip4: 'âœˆï¸ <strong>HÃ ng trÃªn</strong> - 2 hÃ ng Ä‘áº§u cáº§n Ä‘áº·t Cá» 4 LÃ¡ trÆ°á»›c khi trá»“ng cÃ¢y khÃ¡c.<br>âš ï¸ <strong>LÆ°u Ã½:</strong> Má»™t sá»‘ cÃ¢y vÃ  náº¥m sáº½ khÃ´ng trá»“ng Ä‘Æ°á»£c á»Ÿ 2 hÃ ng Ä‘áº§u.',
      howTip5: 'ğŸŒ™ <strong>Ban Ä‘Ãªm</strong> - Tá»« mÃ n 11 trá»Ÿ Ä‘i sáº½ dÃ¹ng náº¥m thay vÃ¬ cÃ¢y',
      howTip6: "ğŸ’¡ <strong>LÆ°u Ã½:</strong> Tá»« mÃ n 16 trá»Ÿ Ä‘i cáº§n Ä‘áº·t <span style='color:#ff8a65'>Náº¥m Lá»­a</span> hoáº·c <span style='color:#81d4fa'>Náº¥m PhÃ¡t Quang</span> Ä‘á»ƒ chiáº¿u sÃ¡ng khu vá»±c.",
        howTipHammer: "ğŸ”¨ <strong>BÃºa:</strong> DÃ¹ng bÃºa Ä‘á»ƒ phÃ¡ bá» cÃ¢y Ä‘Ã£ trá»“ng náº¿u Ä‘áº·t nháº§m hoáº·c muá»‘n thay Ä‘á»•i chiáº¿n thuáº­t.",
      // Controls
      sun: 'Náº¯ng',
      start: 'Báº¯t Ä‘áº§u',
      pause: 'Táº¡m dá»«ng',
      reset: 'Äáº·t láº¡i',
      skipLevel: 'Bá» qua',
      hammer: 'BÃºa',
      // HUD
      plants: 'CÃ¢y',
      zombies: 'Zombie',
      level: 'MÃ n',
      remaining: 'CÃ²n láº¡i',
      // Level overlay
      levelComplete: 'HoÃ n thÃ nh mÃ n!',
      nextLevel: 'MÃ n tiáº¿p theo',
      readyNext: 'Sáºµn sÃ ng cho mÃ n tiáº¿p theo?',
      // Game over
      gameOver: 'TrÃ² chÆ¡i káº¿t thÃºc!',
      zombieWin: 'Zombie Ä‘Ã£ xÃ¢m nháº­p!',
      tryAgain: 'ChÆ¡i láº¡i',
      // Plants
      clover: 'Cá» 4 LÃ¡',
      sunflower: 'Hoa HÆ°á»›ng DÆ°Æ¡ng',
      peashooter: 'Äáº¡i BÃ¡c Äáº­u',
      wallnut: 'Háº¡t Dáº»',
      cherry: 'Bom Anh ÄÃ o',
      icepea: 'Äáº­u BÄƒng',
      tallnut: 'Háº¡t Dáº» Cao',
      sunpea: 'Äáº­u Máº·t Trá»i',
      minibomb: 'MÃ¬n Nhá»',
      gatling: 'Äáº­u LiÃªn Thanh',
      spiker: 'Thornroot',
      squash: 'BÃ­ Nguyá»‡t',
      sunshroom: 'Náº¥m Náº¯ng',
      puffshroom: 'Náº¥m PhÃ¹n',
      scaredyshroom: 'Náº¥m NhÃ¡t',
      fumeshroom: 'Náº¥m KhÃ³i',
      hypnoshroom: 'Náº¥m ThÃ´i MiÃªn',
      strawshroom: 'Náº¥m DÃ¢u',
      iceshroom: 'Náº¥m BÄƒng',
      doomshroom: 'Náº¥m Diá»‡t Vong',
      embermush: 'Náº¥m Than Há»“ng',
      lumenmush: 'Náº¥m PhÃ¡t SÃ¡ng',
      magnet: 'Náº¥m Nam ChÃ¢m'
    },
    en: {
      // Menu
      gameTitle: 'ğŸŒ± Garden Defense ğŸŒ±',
      subtitle: 'Protect your garden from zombies!',
      menuDesc: '',
      playBtn: 'ğŸ® Play Now',
      howBtn: 'ğŸ“– How to Play',
      menuTips: 'ğŸŒ Collect sun â€¢ ğŸŒº Plant â€¢ ğŸ’€ Kill zombies',
      // How to play
      howTitle: 'How to Play',
      howText: 'Plant your plants and defend your home from the zombie horde',
      backBtn: 'Go Back',
      howTip1: 'ğŸŒ <strong>Collect Sun</strong> - Click on falling suns to gather energy',
      howTip2: 'ğŸŒ± <strong>Plant</strong> - Select a plant from the seed bar and place it on an empty tile',
      howTip3: 'ğŸ›¡ï¸ <strong>Defend</strong> - Don\'t let zombies pass the left fence',
      howTip4: 'âœˆï¸ <strong>Top Rows</strong> - First 2 rows need 4-Leaf Clover before other plants.<br>âš ï¸ <strong>Note:</strong> Some plants and mushrooms cannot be planted in the first 2 rows.',
      howTip5: 'ğŸŒ™ <strong>Night Mode</strong> - From level 11 onwards, use mushrooms instead of plants',
      howTip6: "ğŸ’¡ <strong>Note:</strong> From level 16 onwards, you need to place <span style='color:#ff8a65'>Ember Mushroom</span> or <span style='color:#81d4fa'>Lumen Mushroom</span> to light up the area.",
        howTipHammer: "ğŸ”¨ <strong>Hammer:</strong> Use the hammer to remove a planted plant if you misplace it or want to change your strategy.",
      // Controls
      sun: 'Sun',
      start: 'Start',
      pause: 'Pause',
      reset: 'Reset',
      skipLevel: 'Skip',
      hammer: 'Hammer',
      // HUD
      plants: 'Plants',
      zombies: 'Zombies',
      level: 'Level',
      remaining: 'Remaining',
      // Level overlay
      levelComplete: 'Level Complete!',
      nextLevel: 'Next Level',
      readyNext: 'Ready for next level?',
      // Game over
      gameOver: 'Game Over!',
      zombieWin: 'Zombies invaded!',
      tryAgain: 'Try Again',
      // Plants
      clover: '4-Leaf Clover',
      sunflower: 'Sunflower',
      peashooter: 'Cannon Pea',
      wallnut: 'Wall-nut',
      cherry: 'Cherry Bomb',
      icepea: 'Snow Pea',
      tallnut: 'Tall-nut',
      gatling: 'Gatling Pea',
      spiker: 'Thornroot',
      squash: 'Squash',
      sunshroom: 'Sun-shroom',
      puffshroom: 'Puff-shroom',
      scaredyshroom: 'Scaredy-shroom',
      fumeshroom: 'Fume-shroom',
      hypnoshroom: 'Hypno-shroom',
      strawshroom: 'Straw-shroom',
      iceshroom: 'Ice-shroom',
      doomshroom: 'Doom-shroom',
      magnet: 'Magnet-shroom',
      embermush: 'Ember Mushroom',
      lumenmush: 'Lumen Mushroom'
    }
  };
  
  // Danh sÃ¡ch cÃ¡c cÃ¢y khÃ´ng thá»ƒ trá»“ng á»Ÿ 2 hÃ ng Ä‘áº§u
  const plantsNotAllowedTopRows = [
    'cherry',      // Cherry Bomb
    'thorn',       // Thornroot
    'minibomb',    // MÃ¬n Nhá»
    'squash',      // BÃ­ NgÃ´/BÃ­ Äao
    'doomshroom',  // Náº¥m Diá»‡t Vong
    'embermush',   // Náº¥m Lá»­a
    'lumenmush'    // Náº¥m PhÃ¡t SÃ¡ng
  ];

  function t(key) {
    return translations[currentLanguage][key] || translations['en'][key] || key;
  }
  
  function updateAllTexts() {
    // Menu texts
    const menuTitle = document.querySelector('#menuCard h1');
    const menuSubtitle = document.querySelector('#menuCard .subtitle');
    // menuDesc element was removed from DOM; skip querying it
    const playBtnEl = document.getElementById('playBtn');
    const menuHowEl = document.getElementById('menuHow');
    const menuTipsEl = document.querySelector('#menuCard p[style*="margin-top: 25px"]');
    
    if(menuTitle) menuTitle.textContent = t('gameTitle');
    if(menuSubtitle) menuSubtitle.textContent = t('subtitle');
    if(playBtnEl) playBtnEl.textContent = t('playBtn');
    if(menuHowEl) menuHowEl.textContent = t('howBtn');
    if(menuTipsEl) menuTipsEl.textContent = t('menuTips');
    
    // How to play
    const howTitle = document.getElementById('howTitle');
    const howText = document.getElementById('howText');
    const howBackBtn = document.getElementById('howBackBtn');
    const howTip1 = document.getElementById('howTip1');
    const howTip2 = document.getElementById('howTip2');
    const howTip3 = document.getElementById('howTip3');
    const howTip4 = document.getElementById('howTip4');
    const howTip5 = document.getElementById('howTip5');
    const howTip6 = document.getElementById('howTip6');
      const howTipHammer = document.getElementById('howTipHammer');
    if(howTitle) howTitle.innerHTML = 'ğŸ“– ' + t('howTitle');
    if(howText) howText.textContent = t('howText');
    if(howBackBtn) howBackBtn.textContent = 'â† ' + t('backBtn');
    if(howTip1) howTip1.innerHTML = t('howTip1');
    if(howTip2) howTip2.innerHTML = t('howTip2');
    if(howTip3) howTip3.innerHTML = t('howTip3');
    if(howTip4) howTip4.innerHTML = t('howTip4');
    if(howTip5) howTip5.innerHTML = t('howTip5');
    if(howTip6) {
      howTip6.innerHTML = t('howTip6');
    }
    if(howTipHammer) {
      howTipHammer.innerHTML = t('howTipHammer');
    }
    
    // Controls: do not add a duplicate sun label here (sun is shown in the seed bar)
    const startEl = document.getElementById('start'); if(startEl) startEl.textContent = t('start');
    const pauseEl = document.getElementById('pause'); if(pauseEl) pauseEl.textContent = t('pause');
    const resetEl = document.getElementById('reset'); if(resetEl) resetEl.textContent = t('reset');
    const skipEl = document.getElementById('skipLevel'); if(skipEl) skipEl.textContent = t('skipLevel');
    const hammerEl = document.getElementById('hammerBtn'); if(hammerEl) hammerEl.title = t('hammer');
    
    // Level overlay
    const levelTitle = document.getElementById('levelTitle');
    const levelText = document.getElementById('levelText');
    const nextLevelBtn = document.getElementById('nextLevelBtn');
    if(levelTitle) levelTitle.textContent = t('levelComplete');
    if(levelText) levelText.textContent = t('readyNext');
    if(nextLevelBtn) nextLevelBtn.textContent = t('nextLevel');
    
    // Game Over overlay
    const gameOverTitle = document.getElementById('gameOverTitle');
    const gameOverText = document.getElementById('gameOverText');
    const tryAgainText = document.getElementById('tryAgainText');
    const restartBtn = document.getElementById('restartBtn');
    if(gameOverTitle) gameOverTitle.textContent = t('gameOver');
    if(gameOverText) gameOverText.textContent = t('zombieWin');
    if(tryAgainText) tryAgainText.textContent = t('tryAgain');
    if(restartBtn) {
      restartBtn.textContent = 'ğŸ”„ ' + t('tryAgain');
      // Ensure restartBtn triggers the same reset behavior as the toolbar reset
      restartBtn.onclick = function(){
        const toolbarReset = document.getElementById('reset');
        if(toolbarReset){ toolbarReset.click(); return; }
        // fallback: perform reset directly
        sun = 200; plants=[]; zombies=[]; bullets=[]; particles=[]; running=false; initLawnmowers(); updateUI(); try{ menuOverlay.style.display='flex'; }catch(e){} try{ stopMusic(); }catch(e){}; currentLevel = 1; levelTarget = 20; levelSpawned = 0; levelKilled = 0; spawnAcc = 0; rebuildCardsForLevel(); buildSeedBar(); try{ stopZombieMoan(); }catch(e){}; document.getElementById('gameOverOverlay').style.display = 'none';
      };
    }

    // Update HUD (only if game is initialized)
    if(gameInitialized && typeof updateUI === 'function') updateUI();
    
    // Rebuild seed cards with translated names
    if(gameInitialized && typeof buildSeedBar === 'function') buildSeedBar();
  }
  
  function setLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('gameLanguage', lang);
    
    // Update language button display
    const currentFlag = document.getElementById('currentFlag');
    const currentLangEl = document.getElementById('currentLang');
    const langOptions = document.querySelectorAll('.lang-option');
    
    if(lang === 'vi') {
      currentFlag.textContent = 'ğŸ‡»ğŸ‡³';
      currentLangEl.textContent = 'Tiáº¿ng Viá»‡t';
    } else {
      currentFlag.textContent = 'ğŸ‡ºğŸ‡¸';
      currentLangEl.textContent = 'English';
    }
    
    // Update active state
    langOptions.forEach(opt => {
      opt.classList.remove('active');
      if(opt.dataset.lang === lang) opt.classList.add('active');
    });
    
    // Update all texts
    updateAllTexts();
  }
  
  // Language selector events
  document.getElementById('langBtn').addEventListener('click', () => {
    document.getElementById('langDropdown').classList.toggle('show');
  });
  
  document.querySelectorAll('.lang-option').forEach(opt => {
    opt.addEventListener('click', () => {
      setLanguage(opt.dataset.lang);
      document.getElementById('langDropdown').classList.remove('show');
    });
  });
  
  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    try {
      if(!e.target.closest('.lang-selector')) {
        document.getElementById('langDropdown').classList.remove('show');
      }
    } catch(err) { console.error('Lang dropdown error:', err); }
  });
  
  // Load saved language
  const savedLang = localStorage.getItem('gameLanguage');
  if(savedLang) {
    setLanguage(savedLang);
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Upgraded: PVZ-like seed bar with cooldown, pre-game menu, and wider grid
  // small visual marker to show script executed
  try{ document.getElementById('hud').textContent = 'Initializing...'; }catch(e){}
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const ROWS = 5, COLS = 14; // increased columns
  const LOGICAL_W = 1000, LOGICAL_H = 500; // canvas logic nhá» hÆ¡n cho mobile
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = LOGICAL_W * DPR; canvas.height = LOGICAL_H * DPR;
  canvas.style.width = LOGICAL_W + 'px'; canvas.style.height = LOGICAL_H + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  const W = LOGICAL_W, H = LOGICAL_H;
  const CW = W / COLS, CH = H / ROWS;
  // Offscreen canvas for fog overlay (matches DPR and logical size)
  const fogCanvas = document.createElement('canvas');
  fogCanvas.width = LOGICAL_W * DPR; fogCanvas.height = LOGICAL_H * DPR;
  const fogCtx = fogCanvas.getContext('2d');
  fogCtx.setTransform(DPR,0,0,DPR,0,0);
  // Small vertical nudges for top two rows
  const ROW_SHIFT = 12; // base nudge used previously
  const EXTRA_SHIFT = 12; // additional nudge requested
  const PLANT_ZOMBIE_SHIFT = ROW_SHIFT + EXTRA_SHIFT; // applied to plants and zombies only
  // spawn / difficulty tuning
  const SPAWN_INTERVAL = 2800; // base ms between zombie spawns
  const MAX_ACTIVE_ZOMBIES = 6; // cap simultaneous zombies
  // global speed scale for zombies (lower = slower)
  // Doubled zombie base speed
  const ZOMBIE_SPEED_SCALE = 0.44; // x2 zombie speed
  
  // Game speed multiplier (1x, 2x, 3x)
  let gameSpeedMultiplier = 1;
  // Keyboard speed hold state (Space = hold fast), and previous speed storage
  let _spaceHeld = false;
  let _prevSpeed = 1;
  // Hammer (remove plant) mode
  let hammerMode = false;
  // Hover preview cell when selecting/placing plants
  let hoverRow = -1, hoverCol = -1;

  const seedBar = document.getElementById('seedBar');
  const sunEl = document.getElementById('sun');
  const hud = document.getElementById('hud');
  const btnStart = document.getElementById('start');
  const btnPause = document.getElementById('pause');
  const btnReset = document.getElementById('reset');
  const menuOverlay = document.getElementById('menuOverlay');
  const playBtn = document.getElementById('playBtn');
  
  // debug traces removed for production

  // sprites (SVG data URLs) â€” UPGRADED with detailed graphics
  function svgToDataURL(svg){ return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg); }
  const sprites = {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SUNFLOWER â€” Radiant flower with layered petals, 3D shading, glowing center
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    sunflower: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <defs>
        <radialGradient id='sfCenter' cx='30%' cy='25%'><stop offset='0%' stop-color='#fff8e1'/><stop offset='30%' stop-color='#ffca28'/><stop offset='70%' stop-color='#ff8f00'/><stop offset='100%' stop-color='#e65100'/></radialGradient>
        <radialGradient id='sfPetalOut' cx='50%' cy='20%'><stop offset='0%' stop-color='#fff176'/><stop offset='40%' stop-color='#ffeb3b'/><stop offset='100%' stop-color='#f9a825'/></radialGradient>
        <radialGradient id='sfPetalIn' cx='50%' cy='20%'><stop offset='0%' stop-color='#ffee58'/><stop offset='100%' stop-color='#fbc02d'/></radialGradient>
        <linearGradient id='sfStem' x1='0' y1='0' x2='1' y2='0'><stop offset='0%' stop-color='#2e7d32'/><stop offset='50%' stop-color='#4caf50'/><stop offset='100%' stop-color='#388e3c'/></linearGradient>
        <filter id='sfGlow'><feGaussianBlur stdDeviation='4' result='blur'/><feMerge><feMergeNode in='blur'/><feMergeNode in='blur'/><feMergeNode in='SourceGraphic'/></feMerge></filter>
        <filter id='sfShadow'><feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#33691e' flood-opacity='0.4'/></filter>
      </defs>
      <g transform='translate(80,120)'>
        <!-- Stem with 3D effect -->
        <path d='M-3 25 Q-8 45 -2 72' stroke='#2e7d32' stroke-width='10' fill='none' stroke-linecap='round'/>
        <path d='M0 25 Q-5 45 1 70' stroke='url(#sfStem)' stroke-width='7' fill='none' stroke-linecap='round'/>
        <path d='M2 28 Q0 45 3 68' stroke='#66bb6a' stroke-width='2' fill='none' stroke-linecap='round' opacity='0.6'/>
        <!-- Leaves with veins -->
        <g filter='url(#sfShadow)'>
          <ellipse cx='-20' cy='48' rx='14' ry='9' fill='#43a047' transform='rotate(-30,-20,48)'/>
          <path d='M-26 45 Q-20 48 -14 45' stroke='#2e7d32' stroke-width='1' fill='none'/>
          <ellipse cx='18' cy='56' rx='12' ry='7' fill='#66bb6a' transform='rotate(25,18,56)'/>
          <path d='M12 54 Q18 56 24 54' stroke='#388e3c' stroke-width='1' fill='none'/>
        </g>
        <!-- Outer petals (larger, darker) -->
        <g fill='url(#sfPetalOut)' stroke='#ef6c00' stroke-width='0.8'>
          <ellipse rx='32' ry='13' transform='rotate(0) translate(0,-10)'/><ellipse rx='32' ry='13' transform='rotate(24) translate(0,-10)'/>
          <ellipse rx='32' ry='13' transform='rotate(48) translate(0,-10)'/><ellipse rx='32' ry='13' transform='rotate(72) translate(0,-10)'/>
          <ellipse rx='32' ry='13' transform='rotate(96) translate(0,-10)'/><ellipse rx='32' ry='13' transform='rotate(120) translate(0,-10)'/>
          <ellipse rx='32' ry='13' transform='rotate(144) translate(0,-10)'/><ellipse rx='32' ry='13' transform='rotate(168) translate(0,-10)'/>
        </g>
        <!-- Inner petals (smaller, brighter) -->
        <g fill='url(#sfPetalIn)' stroke='#ff8f00' stroke-width='0.5'>
          <ellipse rx='26' ry='10' transform='rotate(12) translate(0,-6)'/><ellipse rx='26' ry='10' transform='rotate(36) translate(0,-6)'/>
          <ellipse rx='26' ry='10' transform='rotate(60) translate(0,-6)'/><ellipse rx='26' ry='10' transform='rotate(84) translate(0,-6)'/>
          <ellipse rx='26' ry='10' transform='rotate(108) translate(0,-6)'/><ellipse rx='26' ry='10' transform='rotate(132) translate(0,-6)'/>
          <ellipse rx='26' ry='10' transform='rotate(156) translate(0,-6)'/><ellipse rx='26' ry='10' transform='rotate(180) translate(0,-6)'/>
        </g>
        <!-- Glowing center -->
        <circle r='24' fill='url(#sfCenter)' stroke='#bf360c' stroke-width='2' filter='url(#sfGlow)'/>
        <!-- Seed pattern in center -->
        <g fill='#8d6e63' opacity='0.3'>
          <circle cx='-8' cy='8' r='2'/><circle cx='0' cy='10' r='2'/><circle cx='8' cy='8' r='2'/>
          <circle cx='-5' cy='14' r='1.5'/><circle cx='5' cy='14' r='1.5'/>
        </g>
        <!-- Expressive eyes with shine -->
        <ellipse cx='-8' cy='-5' rx='5' ry='6' fill='#4e342e'/><ellipse cx='8' cy='-5' rx='5' ry='6' fill='#4e342e'/>
        <ellipse cx='-7' cy='-6' rx='2.5' ry='3' fill='#fff'/><ellipse cx='9' cy='-6' rx='2.5' ry='3' fill='#fff'/>
        <circle cx='-6' cy='-7' r='1' fill='#fff'/><circle cx='10' cy='-7' r='1' fill='#fff'/>
        <!-- Big happy smile -->
        <path d='M-12 5 Q0 18 12 5' stroke='#5d4037' stroke-width='2.5' fill='none' stroke-linecap='round'/>
        <path d='M-8 8 Q0 14 8 8' fill='#c62828' opacity='0.4'/>
        <!-- Rosy cheeks -->
        <ellipse cx='-14' cy='2' rx='5' ry='4' fill='#ffab91' opacity='0.5'/>
        <ellipse cx='14' cy='2' rx='5' ry='4' fill='#ffab91' opacity='0.5'/>
        <!-- Cute eyebrows -->
        <path d='M-12 -12 Q-8 -14 -4 -12' stroke='#6d4c41' stroke-width='1.5' fill='none'/>
        <path d='M4 -12 Q8 -14 12 -12' stroke='#6d4c41' stroke-width='1.5' fill='none'/>
      </g>
    </svg>`),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PEASHOOTER â€” Determined shooter with 3D head, expressive eyes, detailed cannon
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    peashooter: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <defs>
        <linearGradient id='psBody' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#bdbdbd'/><stop offset='50%' stop-color='#9e9e9e'/><stop offset='100%' stop-color='#616161'/></linearGradient>
        <radialGradient id='psHead' cx='25%' cy='20%'><stop offset='0%' stop-color='#efefef'/><stop offset='40%' stop-color='#bdbdbd'/><stop offset='100%' stop-color='#616161'/></radialGradient>
        <linearGradient id='psMouth' x1='0' y1='0' x2='1' y2='0'><stop offset='0%' stop-color='#222'/><stop offset='50%' stop-color='#111'/><stop offset='100%' stop-color='#000'/></linearGradient>
        <radialGradient id='psMouthInner' cx='80%' cy='50%'><stop offset='0%' stop-color='#000'/><stop offset='100%' stop-color='#000'/></radialGradient>
        <linearGradient id='psLeaf' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#8d8d8d'/><stop offset='100%' stop-color='#5a5a5a'/></linearGradient>
        <filter id='psShadow'><feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#000' flood-opacity='0.4'/></filter>
      </defs>
      <g transform='translate(80,120)'>
        <!-- Support mast -->
        <rect x='-6' y='18' width='12' height='60' rx='3' fill='url(#psBody)' stroke='#424242' stroke-width='1'/>
        <!-- Small support plates -->
        <rect x='-36' y='40' width='28' height='12' rx='3' fill='url(#psLeaf)' stroke='#424242' stroke-width='1'/>
        <rect x='10' y='44' width='24' height='10' rx='3' fill='url(#psLeaf)' stroke='#424242' stroke-width='1'/>
        <!-- Head with metallic shading -->
        <ellipse cx='0' cy='-5' rx='36' ry='30' fill='url(#psHead)' stroke='#616161' stroke-width='3'/>
        <!-- Head highlight -->
        <ellipse cx='-14' cy='-18' rx='12' ry='8' fill='#fff' opacity='0.18'/>
        <!-- Mouth/cannon with deep black interior -->
        <ellipse cx='34' cy='-1' rx='26' ry='18' fill='url(#psMouth)' stroke='#000' stroke-width='2'/>
        <ellipse cx='44' cy='-1' rx='14' ry='12' fill='url(#psMouthInner)'/>
        <ellipse cx='52' cy='-1' rx='7' ry='9' fill='#000'/>
        <!-- Cannon rings -->
        <ellipse cx='38' cy='-1' rx='3' ry='14' fill='none' stroke='#7a7a7a' stroke-width='1.5' opacity='0.6'/>
        <!-- Big expressive eyes (kept for character) -->
        <ellipse cx='-9' cy='-12' rx='11' ry='14' fill='#fff' stroke='#616161' stroke-width='1.5'/>
        <ellipse cx='8' cy='-12' rx='11' ry='14' fill='#fff' stroke='#616161' stroke-width='1.5'/>
        <!-- Pupils looking forward -->
        <circle cx='-5' cy='-10' r='6' fill='#1a1a1a'/><circle cx='12' cy='-10' r='6' fill='#1a1a1a'/>
        <!-- Eye shine -->
        <circle cx='-3' cy='-13' r='3' fill='#fff'/><circle cx='14' cy='-13' r='3' fill='#fff'/>
        <circle cx='-7' cy='-8' r='1.5' fill='#fff' opacity='0.6'/><circle cx='10' cy='-8' r='1.5' fill='#fff' opacity='0.6'/>
        <!-- Determined eyebrows -->
        <path d='M-18 -22 Q-9 -26 -2 -22' stroke='#2e7d32' stroke-width='2.5' fill='none' stroke-linecap='round'/>
        <path d='M2 -22 Q9 -26 16 -22' stroke='#2e7d32' stroke-width='2.5' fill='none' stroke-linecap='round'/>
        <!-- Lip/chin detail -->
        <path d='M14 10 Q22 14 30 10' stroke='#66bb6a' stroke-width='2' fill='none'/>
        <path d='M-8 12 Q0 16 8 12' stroke='#4caf50' stroke-width='1.5' fill='none'/>
      </g>
    </svg>`),

    // SUNPEA - small icon used in seed toolbar (yellow stalk + sun head)
    sunpea: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <g transform='translate(80,80)'>
        <rect x='68' y='110' width='0' height='0' fill='none' />
        <!-- stalk -->
        <rect x='72' y='58' width='16' height='56' rx='6' fill='#ffeb3b' stroke='#f9a825' stroke-width='2'/>
        <!-- sun head -->
        <g transform='translate(0,-10)'>
          <circle r='30' fill='#ffd54f' stroke='#ff8f00' stroke-width='3'/>
          <!-- rays -->
          <g fill='#ffb300' opacity='0.9'>
            <rect x='-4' y='-54' width='8' height='16' rx='3'/>
            <rect x='-54' y='-4' width='16' height='8' rx='3' transform='rotate(0)' />
            <rect x='38' y='-4' width='16' height='8' rx='3' transform='rotate(0)' />
            <rect x='-36' y='30' width='12' height='8' rx='3' transform='rotate(-30)' />
          </g>
          <!-- face -->
          <circle cx='-8' cy='-4' r='6' fill='#000'/>
          <circle cx='8' cy='-4' r='6' fill='#000'/>
          <path d='M-12 10 Q0 18 12 10' stroke='#b71c1c' stroke-width='2' fill='none' stroke-linecap='round'/>
        </g>
      </g>
    </svg>`),

    // MINIBOMB - small cluster icon for seed toolbar
    minibomb: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <g transform='translate(80,80)'>
        <rect x='-40' y='30' width='80' height='40' rx='8' fill='#efebe9' opacity='0.0'/>
        <g>
          <circle cx='-18' cy='0' r='10' fill='#37474f' stroke='#263238' stroke-width='2'/>
          <circle cx='0' cy='-6' r='10' fill='#455a64' stroke='#263238' stroke-width='2'/>
          <circle cx='18' cy='2' r='10' fill='#37474f' stroke='#263238' stroke-width='2'/>
          <circle cx='-6' cy='10' r='6' fill='#ff7043'/>
        </g>
      </g>
    </svg>`),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WALL-NUT â€” Armored nut with 3D shell texture, battle scars, fierce expression
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    wallnut: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <defs>
        <radialGradient id='wnBody' cx='30%' cy='20%'><stop offset='0%' stop-color='#efebe9'/><stop offset='25%' stop-color='#d7ccc8'/><stop offset='50%' stop-color='#a1887f'/><stop offset='80%' stop-color='#6d4c41'/><stop offset='100%' stop-color='#4e342e'/></radialGradient>
        <radialGradient id='wnHighlight' cx='30%' cy='20%'><stop offset='0%' stop-color='#fff' stop-opacity='0.4'/><stop offset='100%' stop-color='#fff' stop-opacity='0'/></radialGradient>
        <filter id='wnShadow'><feDropShadow dx='0' dy='3' stdDeviation='3' flood-color='#3e2723' flood-opacity='0.5'/></filter>
        <filter id='wnInner'><feGaussianBlur stdDeviation='1'/></filter>
      </defs>
      <g transform='translate(80,120)'>
        <!-- Main body with 3D effect -->
        <ellipse rx='40' ry='46' fill='url(#wnBody)' stroke='#3e2723' stroke-width='3' filter='url(#wnShadow)'/>
        <!-- Shell highlight -->
        <ellipse rx='30' ry='35' fill='url(#wnHighlight)' transform='translate(-5,-8)'/>
        <!-- Detailed shell ridges -->
        <path d='M-32 -25 Q0 -42 32 -25' stroke='#8d6e63' stroke-width='2.5' fill='none' opacity='0.7'/>
        <path d='M-35 -10 Q0 -25 35 -10' stroke='#a1887f' stroke-width='2' fill='none' opacity='0.6'/>
        <path d='M-34 5 Q0 -8 34 5' stroke='#8d6e63' stroke-width='2' fill='none' opacity='0.5'/>
        <path d='M-30 20 Q0 10 30 20' stroke='#6d4c41' stroke-width='2' fill='none' opacity='0.4'/>
        <path d='M-24 32 Q0 25 24 32' stroke='#5d4037' stroke-width='1.5' fill='none' opacity='0.3'/>
        <!-- Battle damage cracks -->
        <path d='M-28 -5 L-22 0 L-26 8 L-20 12' stroke='#4e342e' stroke-width='1.5' fill='none' opacity='0.6'/>
        <path d='M25 -15 L20 -8 L24 -2' stroke='#5d4037' stroke-width='1' fill='none' opacity='0.5'/>
        <!-- Knot details -->
        <ellipse cx='-20' cy='15' rx='6' ry='5' fill='#5d4037' opacity='0.4'/>
        <ellipse cx='22' cy='-20' rx='5' ry='4' fill='#4e342e' opacity='0.3'/>
        <!-- Fierce determined eyes -->
        <ellipse cx='-12' cy='-8' rx='7' ry='9' fill='#3e2723'/>
        <ellipse cx='12' cy='-8' rx='7' ry='9' fill='#3e2723'/>
        <ellipse cx='-11' cy='-9' rx='3' ry='4' fill='#fff'/>
        <ellipse cx='13' cy='-9' rx='3' ry='4' fill='#fff'/>
        <circle cx='-10' cy='-10' r='1.5' fill='#fff'/><circle cx='14' cy='-10' r='1.5' fill='#fff'/>
        <!-- Angry/determined eyebrows -->
        <path d='M-22 -20 L-8 -15' stroke='#3e2723' stroke-width='4' stroke-linecap='round'/>
        <path d='M22 -20 L8 -15' stroke='#3e2723' stroke-width='4' stroke-linecap='round'/>
        <!-- Gritted determined mouth -->
        <path d='M-16 14 Q0 8 16 14' stroke='#3e2723' stroke-width='3' fill='none' stroke-linecap='round'/>
        <path d='M-12 14 L-8 12 L-4 14 L0 12 L4 14 L8 12 L12 14' stroke='#5d4037' stroke-width='1' fill='none' opacity='0.6'/>
        <!-- Stress lines -->
        <path d='M-6 18 L-4 22' stroke='#6d4c41' stroke-width='1' opacity='0.4'/>
        <path d='M6 18 L4 22' stroke='#6d4c41' stroke-width='1' opacity='0.4'/>
      </g>
    </svg>`),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CHERRY BOMB â€” Glossy explosive cherries with sparking fuse, furious expressions
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    cherry: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <defs>
        <radialGradient id='chBomb' cx='25%' cy='20%'><stop offset='0%' stop-color='#ff8a80'/><stop offset='30%' stop-color='#ff5252'/><stop offset='70%' stop-color='#d32f2f'/><stop offset='100%' stop-color='#b71c1c'/></radialGradient>
        <radialGradient id='chBomb2' cx='25%' cy='20%'><stop offset='0%' stop-color='#ff8a80'/><stop offset='30%' stop-color='#ef5350'/><stop offset='70%' stop-color='#c62828'/><stop offset='100%' stop-color='#8e0000'/></radialGradient>
        <radialGradient id='chSpark' cx='50%' cy='50%'><stop offset='0%' stop-color='#fff'/><stop offset='30%' stop-color='#ffeb3b'/><stop offset='70%' stop-color='#ff9800'/><stop offset='100%' stop-color='#ff5722'/></radialGradient>
        <linearGradient id='chStem' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#558b2f'/><stop offset='100%' stop-color='#33691e'/></linearGradient>
        <filter id='chGlow'><feGaussianBlur stdDeviation='3' result='blur'/><feMerge><feMergeNode in='blur'/><feMergeNode in='blur'/><feMergeNode in='SourceGraphic'/></feMerge></filter>
        <filter id='chShadow'><feDropShadow dx='0' dy='3' stdDeviation='3' flood-color='#7f0000' flood-opacity='0.5'/></filter>
      </defs>
      <g transform='translate(80,120)'>
        <!-- Stem with 3D effect -->
        <path d='M-10 -25 Q-4 -48 14 -42 Q24 -40 22 -30' stroke='#2e7d32' stroke-width='6' fill='none' stroke-linecap='round'/>
        <path d='M-8 -25 Q-2 -46 14 -40 Q22 -38 20 -30' stroke='url(#chStem)' stroke-width='4' fill='none' stroke-linecap='round'/>
        <path d='M-6 -26 Q0 -44 14 -38' stroke='#7cb342' stroke-width='1.5' fill='none' opacity='0.6'/>
        <!-- Fuse with sparks -->
        <path d='M20 -30 Q25 -35 22 -40 Q28 -42 24 -48' stroke='#5d4037' stroke-width='2' fill='none'/>
        <circle cx='24' cy='-48' r='8' fill='url(#chSpark)' filter='url(#chGlow)'/>
        <circle cx='24' cy='-48' r='4' fill='#fff'/>
        <!-- Spark particles -->
        <circle cx='28' cy='-52' r='2' fill='#ffeb3b' opacity='0.8'/>
        <circle cx='20' cy='-54' r='1.5' fill='#ff9800' opacity='0.7'/>
        <circle cx='30' cy='-46' r='1.5' fill='#fff' opacity='0.9'/>
        <!-- Left cherry (larger) -->
        <circle cx='-14' cy='10' r='28' fill='url(#chBomb)' stroke='#7f0000' stroke-width='2' filter='url(#chShadow)'/>
        <!-- Left cherry shine -->
        <ellipse cx='-24' cy='-2' rx='8' ry='10' fill='rgba(255,255,255,0.35)'/>
        <ellipse cx='-20' cy='0' rx='4' ry='5' fill='rgba(255,255,255,0.5)'/>
        <!-- Right cherry (slightly smaller) -->
        <circle cx='20' cy='6' r='26' fill='url(#chBomb2)' stroke='#7f0000' stroke-width='2' filter='url(#chShadow)'/>
        <!-- Right cherry shine -->
        <ellipse cx='10' cy='-4' rx='7' ry='9' fill='rgba(255,255,255,0.35)'/>
        <ellipse cx='12' cy='-2' rx='3' ry='4' fill='rgba(255,255,255,0.5)'/>
        <!-- Left cherry furious face -->
        <g transform='translate(-14,10)'>
          <ellipse cx='-7' cy='-4' rx='5' ry='6' fill='#1a1a1a'/><ellipse cx='7' cy='-4' rx='5' ry='6' fill='#1a1a1a'/>
          <circle cx='-6' cy='-5' r='2' fill='#c62828'/><circle cx='8' cy='-5' r='2' fill='#c62828'/>
          <circle cx='-5' cy='-6' r='1' fill='#fff'/><circle cx='9' cy='-6' r='1' fill='#fff'/>
          <!-- Angry eyebrows -->
          <path d='M-14 -12 L-4 -7' stroke='#7f0000' stroke-width='3' stroke-linecap='round'/>
          <path d='M14 -12 L4 -7' stroke='#7f0000' stroke-width='3' stroke-linecap='round'/>
          <!-- Angry gritting teeth mouth -->
          <path d='M-8 8 Q0 4 8 8' stroke='#1a1a1a' stroke-width='2.5' fill='none'/>
          <path d='M-6 8 L-4 6 L-2 8 L0 6 L2 8 L4 6 L6 8' stroke='#fff' stroke-width='1' fill='none'/>
          <!-- Vein -->
          <path d='M10 -14 L14 -10 L12 -6' stroke='#d32f2f' stroke-width='1' fill='none'/>
        </g>
        <!-- Right cherry furious face -->
        <g transform='translate(20,6)'>
          <ellipse cx='-6' cy='-3' rx='4' ry='5' fill='#1a1a1a'/><ellipse cx='6' cy='-3' rx='4' ry='5' fill='#1a1a1a'/>
          <circle cx='-5' cy='-4' r='1.5' fill='#c62828'/><circle cx='7' cy='-4' r='1.5' fill='#c62828'/>
          <circle cx='-4' cy='-5' r='0.8' fill='#fff'/><circle cx='8' cy='-5' r='0.8' fill='#fff'/>
          <!-- Angry eyebrows -->
          <path d='M-12 -10 L-3 -6' stroke='#7f0000' stroke-width='2.5' stroke-linecap='round'/>
          <path d='M12 -10 L3 -6' stroke='#7f0000' stroke-width='2.5' stroke-linecap='round'/>
          <!-- Open angry mouth -->
          <ellipse cx='0' cy='7' rx='6' ry='4' fill='#1a1a1a'/>
          <path d='M-4 6 Q0 4 4 6' stroke='#fff' stroke-width='1' fill='none'/>
        </g>
      </g>
    </svg>`),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ICE PEA â€” Frosty shooter with ice crystals, frozen breath, glacial effects
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    icepea: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <defs>
        <linearGradient id='ipBody' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#b3e5fc'/><stop offset='50%' stop-color='#4fc3f7'/><stop offset='100%' stop-color='#0277bd'/></linearGradient>
        <radialGradient id='ipHead' cx='25%' cy='20%'><stop offset='0%' stop-color='#e1f5fe'/><stop offset='30%' stop-color='#81d4fa'/><stop offset='70%' stop-color='#29b6f6'/><stop offset='100%' stop-color='#0288d1'/></radialGradient>
        <linearGradient id='ipMouth' x1='0' y1='0' x2='1' y2='0'><stop offset='0%' stop-color='#0097a7'/><stop offset='100%' stop-color='#00695c'/></linearGradient>
        <radialGradient id='ipFrostGlow' cx='50%' cy='50%'><stop offset='0%' stop-color='#e0f7fa'/><stop offset='100%' stop-color='#80deea' stop-opacity='0'/></radialGradient>
        <filter id='ipFrost'><feGaussianBlur stdDeviation='2'/></filter>
        <filter id='ipShadow'><feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#01579b' flood-opacity='0.4'/></filter>
      </defs>
      <g transform='translate(80,120)'>
        <!-- Stem with frost -->
        <path d='M-9 20 Q-14 38 -7 65 Q0 74 7 65 Q14 38 9 20' fill='url(#ipBody)' stroke='#01579b' stroke-width='2'/>
        <path d='M-5 25 Q-8 40 -4 55' stroke='#e1f5fe' stroke-width='2' fill='none' opacity='0.6'/>
        <!-- Ice crystals on stem -->
        <g stroke='#e1f5fe' stroke-width='2' fill='none'>
          <path d='M-20 32 L-12 30 L-20 28'/><path d='M-18 30 L-16 25 M-18 30 L-16 35'/>
          <path d='M18 42 L26 40 L18 38'/><path d='M22 40 L24 35 M22 40 L24 45'/>
        </g>
        <!-- Frost particles around stem -->
        <circle cx='-22' cy='45' r='2' fill='#e0f7fa' opacity='0.7'/>
        <circle cx='24' cy='52' r='1.5' fill='#b3e5fc' opacity='0.6'/>
        <!-- Head with icy sheen -->
        <ellipse cx='0' cy='-5' rx='34' ry='30' fill='url(#ipHead)' stroke='#0277bd' stroke-width='3' filter='url(#ipShadow)'/>
        <!-- Ice highlight -->
        <ellipse cx='-12' cy='-18' rx='14' ry='10' fill='#e1f5fe' opacity='0.5'/>
        <!-- Ice crystals on head -->
        <g stroke='#fff' stroke-width='2' fill='none' opacity='0.9'>
          <path d='M-30 -18 L-22 -14 L-30 -10'/><path d='M-26 -14 L-24 -20 M-26 -14 L-24 -8'/>
          <path d='M28 -22 L36 -18 L28 -14'/><path d='M32 -18 L34 -24 M32 -18 L34 -12'/>
          <path d='M-26 8 L-20 12 L-26 16'/>
        </g>
        <!-- Frost aura -->
        <ellipse cx='0' cy='-5' rx='42' ry='36' fill='url(#ipFrostGlow)' opacity='0.3'/>
        <!-- Mouth/cannon with frozen effect -->
        <ellipse cx='30' cy='0' rx='20' ry='16' fill='url(#ipMouth)' stroke='#004d40' stroke-width='2'/>
        <ellipse cx='30' cy='0' rx='16' ry='12' fill='#00838f'/>
        <ellipse cx='42' cy='0' rx='10' ry='12' fill='#004d40'/>
        <ellipse cx='46' cy='0' rx='5' ry='8' fill='#00251a'/>
        <!-- Ice breath inside cannon -->
        <circle cx='44' cy='0' r='6' fill='#80deea' filter='url(#ipFrost)'/>
        <circle cx='44' cy='0' r='3' fill='#e0f7fa'/>
        <!-- Frozen pea visible -->
        <circle cx='38' cy='0' r='5' fill='#4dd0e1' opacity='0.8'/>
        <circle cx='36' cy='-2' r='2' fill='#e0f7fa'/>
        <!-- Cool icy eyes -->
        <ellipse cx='-9' cy='-12' rx='11' ry='14' fill='#e0f7fa' stroke='#0097a7' stroke-width='1.5'/>
        <ellipse cx='8' cy='-12' rx='11' ry='14' fill='#e0f7fa' stroke='#0097a7' stroke-width='1.5'/>
        <!-- Icy blue pupils -->
        <circle cx='-5' cy='-10' r='6' fill='#00acc1'/><circle cx='12' cy='-10' r='6' fill='#00acc1'/>
        <circle cx='-4' cy='-9' r='3' fill='#006064'/><circle cx='13' cy='-9' r='3' fill='#006064'/>
        <!-- Eye shine with frost -->
        <circle cx='-3' cy='-13' r='3' fill='#fff'/><circle cx='14' cy='-13' r='3' fill='#fff'/>
        <circle cx='-7' cy='-8' r='1.5' fill='#e0f7fa'/><circle cx='10' cy='-8' r='1.5' fill='#e0f7fa'/>
        <!-- Cool expression eyebrows -->
        <path d='M-18 -22 Q-9 -26 -2 -22' stroke='#0288d1' stroke-width='2.5' fill='none'/>
        <path d='M2 -22 Q9 -26 16 -22' stroke='#0288d1' stroke-width='2.5' fill='none'/>
        <!-- Snowflake near eye -->
        <g transform='translate(22,-25)' stroke='#e1f5fe' stroke-width='1' fill='none' opacity='0.8'>
          <line x1='0' y1='-4' x2='0' y2='4'/><line x1='-3.5' y1='-2' x2='3.5' y2='2'/><line x1='-3.5' y1='2' x2='3.5' y2='-2'/>
        </g>
      </g>
    </svg>`),

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SUNSHROOM â€” Adorable glowing mushroom with dreamy expression and spots
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    sunshroom: svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
      <defs>
        <radialGradient id='smCap' cx='35%' cy='25%'><stop offset='0%' stop-color='#fff9c4'/><stop offset='30%' stop-color='#ffee58'/><stop offset='60%' stop-color='#ffb300'/><stop offset='100%' stop-color='#ff6f00'/></radialGradient>
        <radialGradient id='smGlow' cx='50%' cy='50%'><stop offset='0%' stop-color='#fff8e1' stop-opacity='0.6'/><stop offset='100%' stop-color='#ffb300' stop-opacity='0'/></radialGradient>
        <linearGradient id='smStem' x1='0' y1='0' x2='1' y2='0'><stop offset='0%' stop-color='#e0e0e0'/><stop offset='50%' stop-color='#fafafa'/><stop offset='100%' stop-color='#eeeeee'/></linearGradient>
        <filter id='smShadow'><feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#e65100' flood-opacity='0.4'/></filter>
        <filter id='smBlur'><feGaussianBlur stdDeviation='3'/></filter>
      </defs>
      <g transform='translate(80,130) scale(0.25)'>
        <!-- Glow aura -->
        <ellipse cx='0' cy='-5' rx='50' ry='35' fill='url(#smGlow)' filter='url(#smBlur)'/>
        <!-- Stem with 3D shading -->
        <path d='M-12 5 Q-14 25 -10 45 Q0 52 10 45 Q14 25 12 5' fill='url(#smStem)' stroke='#9e9e9e' stroke-width='1.5'/>
        <path d='M-8 8 Q-10 25 -6 42' stroke='#fff' stroke-width='2' fill='none' opacity='0.5'/>
        <path d='M8 8 Q10 25 6 42' stroke='#bdbdbd' stroke-width='1' fill='none' opacity='0.4'/>
        <!-- Stem rings -->
        <ellipse cx='0' cy='15' rx='10' ry='3' fill='none' stroke='#e0e0e0' stroke-width='1' opacity='0.5'/>
        <ellipse cx='0' cy='28' rx='9' ry='2.5' fill='none' stroke='#eeeeee' stroke-width='1' opacity='0.4'/>
        <!-- Main cap with 3D effect -->
        <ellipse cx='0' cy='-8' rx='40' ry='28' fill='url(#smCap)' stroke='#e65100' stroke-width='2' filter='url(#smShadow)'/>
        <!-- Cap highlight -->
        <ellipse cx='-12' cy='-20' rx='16' ry='10' fill='#fff9c4' opacity='0.5'/>
        <!-- Decorative spots -->
        <circle cx='-18' cy='-18' r='7' fill='#fff3e0' opacity='0.85'/>
        <circle cx='-16' cy='-16' r='3' fill='#fff' opacity='0.5'/>
        <circle cx='14' cy='-14' r='6' fill='#fff3e0' opacity='0.8'/>
        <circle cx='15' cy='-13' r='2.5' fill='#fff' opacity='0.4'/>
        <circle cx='-6' cy='-6' r='5' fill='#fff3e0' opacity='0.75'/>
        <circle cx='24' cy='-20' r='5' fill='#fff3e0' opacity='0.7'/>
        <circle cx='-26' cy='-8' r='4' fill='#ffe0b2' opacity='0.6'/>
        <circle cx='8' cy='-22' r='4' fill='#fff3e0' opacity='0.65'/>
        <!-- Sleepy/dreamy eyes -->
        <path d='M-12 2 Q-7 -1 -2 2' stroke='#5d4037' stroke-width='2.5' fill='none' stroke-linecap='round'/>
        <path d='M2 2 Q7 -1 12 2' stroke='#5d4037' stroke-width='2.5' fill='none' stroke-linecap='round'/>
        <!-- Eye sparkles -->
        <circle cx='-10' cy='-1' r='1' fill='#fff' opacity='0.7'/>
        <circle cx='10' cy='-1' r='1' fill='#fff' opacity='0.7'/>
        <!-- Cute small mouth -->
        <ellipse cx='0' cy='10' rx='5' ry='3' fill='#ffab91' opacity='0.8'/>
        <path d='M-3 9 Q0 12 3 9' stroke='#e64a19' stroke-width='1' fill='none' opacity='0.5'/>
        <!-- Rosy cheeks -->
        <ellipse cx='-18' cy='6' rx='5' ry='3' fill='#ffccbc' opacity='0.5'/>
        <ellipse cx='18' cy='6' rx='5' ry='3' fill='#ffccbc' opacity='0.5'/>
        <!-- Small glow particles -->
        <circle cx='-32' cy='-15' r='2' fill='#ffeb3b' opacity='0.6'/>
        <circle cx='34' cy='-10' r='1.5' fill='#fff59d' opacity='0.5'/>
        <circle cx='-28' cy='8' r='1.5' fill='#ffe082' opacity='0.4'/>
      </g>
    </svg>`)

    
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EXTRA PLANT SPRITES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  sprites.tallnut = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='tnBody' cx='30%' cy='18%'>
        <stop offset='0%' stop-color='#e0d7c6'/>
        <stop offset='15%' stop-color='#a97c50'/>
        <stop offset='45%' stop-color='#6d4c2e'/>
        <stop offset='80%' stop-color='#3b2412'/>
        <stop offset='100%' stop-color='#23160a'/>
      </radialGradient>
      <radialGradient id='tnHighlight' cx='30%' cy='20%'>
        <stop offset='0%' stop-color='#fff' stop-opacity='0.22'/>
        <stop offset='100%' stop-color='#fff' stop-opacity='0'/>
      </radialGradient>
      <filter id='tnShadow'><feDropShadow dx='0' dy='7' stdDeviation='5' flood-color='#1a0e05' flood-opacity='0.7'/></filter>
    </defs>
    <g transform='translate(80,80) scale(1.18,1.32)'>
      <!-- Main tall body, bigger and more armored -->
      <rect x='-38' y='-56' width='76' height='112' rx='20' fill='url(#tnBody)' stroke='#1a0e05' stroke-width='5' filter='url(#tnShadow)'/>
      <!-- Body highlight -->
      <rect x='-28' y='-44' width='44' height='80' rx='14' fill='url(#tnHighlight)'/>
      <!-- Shell ridges, deeper and more pronounced -->
      <path d='M-32 -40 Q0 -65 32 -40' stroke='#4e342e' stroke-width='4' fill='none' opacity='0.8'/>
      <path d='M-34 -10 Q0 -35 34 -10' stroke='#6d4c41' stroke-width='3' fill='none' opacity='0.7'/>
      <path d='M-34 20 Q0 -5 34 20' stroke='#4e342e' stroke-width='2.5' fill='none' opacity='0.6'/>
      <path d='M-32 45 Q0 30 32 45' stroke='#3b2412' stroke-width='2' fill='none' opacity='0.5'/>
      <!-- Battle scars and cracks, more visible -->
      <path d='M-30 -30 L-22 -18 L-28 -8 L-18 4' stroke='#23160a' stroke-width='2.2' fill='none' opacity='0.8'/>
      <path d='M28 -45 L22 -30 L28 -18 L18 -5' stroke='#3b2412' stroke-width='2' fill='none' opacity='0.7'/>
      <path d='M-22 30 L-16 40 L-22 50' stroke='#23160a' stroke-width='1.5' fill='none' opacity='0.6'/>
      <!-- Knot details -->
      <ellipse cx='-20' cy='25' rx='7' ry='6' fill='#3b2412' opacity='0.5'/>
      <ellipse cx='22' cy='-38' rx='6' ry='5' fill='#23160a' opacity='0.45'/>
      <ellipse cx='18' cy='40' rx='5' ry='4' fill='#3b2412' opacity='0.4'/>
      <!-- Fierce, angry eyes -->
      <ellipse cx='-13' cy='-28' rx='9' ry='12' fill='#1a0e05'/>
      <ellipse cx='13' cy='-28' rx='9' ry='12' fill='#1a0e05'/>
      <ellipse cx='-12' cy='-29' rx='4.5' ry='5.5' fill='#fff'/>
      <ellipse cx='14' cy='-29' rx='4.5' ry='5.5' fill='#fff'/>
      <circle cx='-11' cy='-31' r='2' fill='#fff'/><circle cx='15' cy='-31' r='2' fill='#fff'/>
      <!-- Very angry, thick eyebrows -->
      <path d='M-28 -46 L-8 -34' stroke='#1a0e05' stroke-width='7' stroke-linecap='round'/>
      <path d='M28 -46 L8 -34' stroke='#1a0e05' stroke-width='7' stroke-linecap='round'/>
      <!-- Gritted, angry mouth -->
      <path d='M-16 18 Q0 8 16 18' stroke='#1a0e05' stroke-width='5' fill='none' stroke-linecap='round'/>
      <path d='M-12 18 L-8 13 L-4 18 L0 13 L4 18 L8 13 L12 18' stroke='#3b2412' stroke-width='2.5' fill='none'/>
      <!-- Stress veins, more pronounced -->
      <path d='M-34 -54 L-28 -48 L-34 -42' stroke='#6d4c41' stroke-width='1.5' fill='none' opacity='0.7'/>
      <path d='M34 -54 L28 -48 L34 -42' stroke='#6d4c41' stroke-width='1.5' fill='none' opacity='0.7'/>
    </g>
  </svg>`);

  // removed mushroom sprites

  sprites.gatling = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <linearGradient id='gtBody' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#a5d6a7'/><stop offset='50%' stop-color='#66bb6a'/><stop offset='100%' stop-color='#2e7d32'/></linearGradient>
      <radialGradient id='gtHead' cx='30%' cy='25%'><stop offset='0%' stop-color='#c8e6c9'/><stop offset='50%' stop-color='#81c784'/><stop offset='100%' stop-color='#388e3c'/></radialGradient>
      <linearGradient id='gtBarrel' x1='0' y1='0' x2='1' y2='0'><stop offset='0%' stop-color='#546e7a'/><stop offset='50%' stop-color='#37474f'/><stop offset='100%' stop-color='#263238'/></linearGradient>
      <linearGradient id='gtHelmet' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#8d6e63'/><stop offset='50%' stop-color='#6d4c41'/><stop offset='100%' stop-color='#4e342e'/></linearGradient>
      <filter id='gtShadow'><feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#1b5e20' flood-opacity='0.4'/></filter>
    </defs>
    <g transform='translate(80,80)'>
      <!-- Stem with segments -->
      <path d='M-11 15 Q-16 32 -9 58 Q0 66 9 58 Q16 32 11 15' fill='url(#gtBody)' stroke='#1b5e20' stroke-width='2'/>
      <path d='M-6 20 Q-9 35 -5 50' stroke='#a5d6a7' stroke-width='2' fill='none' opacity='0.5'/>
      <!-- Leaves -->
      <ellipse cx='-22' cy='35' rx='14' ry='7' fill='#4caf50' transform='rotate(-35,-22,35)'/>
      <path d='M-30 32 Q-22 35 -14 32' stroke='#2e7d32' stroke-width='1' fill='none'/>
      <ellipse cx='20' cy='42' rx='12' ry='6' fill='#66bb6a' transform='rotate(30,20,42)'/>
      <!-- Head -->
      <ellipse cx='0' cy='-8' rx='32' ry='28' fill='url(#gtHead)' stroke='#2e7d32' stroke-width='3' filter='url(#gtShadow)'/>
      <!-- 4 detailed barrels with 3D effect -->
      <g transform='translate(24,0)'>
        <rect x='0' y='-22' rx='4' width='32' height='10' fill='url(#gtBarrel)' stroke='#263238' stroke-width='1'/>
        <rect x='28' y='-20' rx='2' width='6' height='6' fill='#1a1a1a'/>
        <ellipse cx='4' cy='-17' rx='3' ry='4' fill='#455a64' opacity='0.6'/>
        
        <rect x='0' y='-10' rx='4' width='32' height='10' fill='url(#gtBarrel)' stroke='#263238' stroke-width='1'/>
        <rect x='28' y='-8' rx='2' width='6' height='6' fill='#1a1a1a'/>
        <ellipse cx='4' cy='-5' rx='3' ry='4' fill='#546e7a' opacity='0.5'/>
        
        <rect x='0' y='2' rx='4' width='32' height='10' fill='url(#gtBarrel)' stroke='#263238' stroke-width='1'/>
        <rect x='28' y='4' rx='2' width='6' height='6' fill='#1a1a1a'/>
        <ellipse cx='4' cy='7' rx='3' ry='4' fill='#455a64' opacity='0.6'/>
        
        <rect x='0' y='14' rx='4' width='32' height='10' fill='url(#gtBarrel)' stroke='#263238' stroke-width='1'/>
        <rect x='28' y='16' rx='2' width='6' height='6' fill='#1a1a1a'/>
        <ellipse cx='4' cy='19' rx='3' ry='4' fill='#546e7a' opacity='0.5'/>
        <!-- Metal band -->
        <rect x='12' y='-24' width='4' height='50' fill='#78909c' opacity='0.7'/>
      </g>
      <!-- Big determined eyes -->
      <ellipse cx='-8' cy='-12' rx='10' ry='12' fill='#fff' stroke='#1b5e20' stroke-width='1.5'/>
      <ellipse cx='8' cy='-12' rx='10' ry='12' fill='#fff' stroke='#1b5e20' stroke-width='1.5'/>
      <circle cx='-5' cy='-10' r='5' fill='#1a1a1a'/><circle cx='11' cy='-10' r='5' fill='#1a1a1a'/>
      <circle cx='-3' cy='-12' r='2.5' fill='#fff'/><circle cx='13' cy='-12' r='2.5' fill='#fff'/>
      <!-- Serious eyebrows -->
      <path d='M-16 -22 Q-8 -26 -2 -22' stroke='#2e7d32' stroke-width='3' fill='none'/>
      <path d='M2 -22 Q8 -26 14 -22' stroke='#2e7d32' stroke-width='3' fill='none'/>
      <!-- Military helmet with detail -->
      <ellipse cx='0' cy='-32' rx='24' ry='12' fill='url(#gtHelmet)' stroke='#3e2723' stroke-width='2'/>
      <ellipse cx='0' cy='-34' rx='18' ry='8' fill='#8d6e63' opacity='0.4'/>
      <!-- Helmet strap -->
      <path d='M-20 -28 Q-22 -20 -20 -12' stroke='#5d4037' stroke-width='2' fill='none'/>
      <path d='M20 -28 Q22 -20 20 -12' stroke='#5d4037' stroke-width='2' fill='none'/>
      <!-- Helmet star -->
      <polygon points='0,-36 2,-32 6,-32 3,-29 4,-25 0,-27 -4,-25 -3,-29 -6,-32 -2,-32' fill='#ffc107'/>
    </g>
  </svg>`);

  sprites.pumpkin = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='pkBody' cx='35%' cy='25%'><stop offset='0%' stop-color='#ffcc80'/><stop offset='30%' stop-color='#ffb74d'/><stop offset='70%' stop-color='#f57c00'/><stop offset='100%' stop-color='#e65100'/></radialGradient>
      <radialGradient id='pkInner' cx='50%' cy='50%'><stop offset='0%' stop-color='#fff3e0'/><stop offset='50%' stop-color='#ffe0b2'/><stop offset='100%' stop-color='#ffcc80'/></radialGradient>
      <radialGradient id='pkGlow' cx='50%' cy='50%'><stop offset='0%' stop-color='#ffeb3b' stop-opacity='0.8'/><stop offset='100%' stop-color='#ff9800' stop-opacity='0'/></radialGradient>
      <linearGradient id='pkStem' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#7cb342'/><stop offset='100%' stop-color='#558b2f'/></linearGradient>
      <filter id='pkShadow'><feDropShadow dx='0' dy='3' stdDeviation='3' flood-color='#bf360c' flood-opacity='0.5'/></filter>
      <filter id='pkInnerGlow'><feGaussianBlur stdDeviation='2'/></filter>
    </defs>
    <g transform='translate(80,85)'>
      <!-- Main pumpkin body -->
      <ellipse rx='46' ry='42' fill='url(#pkBody)' stroke='#bf360c' stroke-width='3' filter='url(#pkShadow)'/>
      <!-- Body highlight -->
      <ellipse cx='-15' cy='-15' rx='20' ry='15' fill='#ffe0b2' opacity='0.4'/>
      <!-- Segment grooves -->
      <path d='M0 -42 Q-6 0 0 42' stroke='#e65100' stroke-width='2.5' fill='none' opacity='0.6'/>
      <path d='M-24 -38 Q-32 0 -24 38' stroke='#f57c00' stroke-width='2' fill='none' opacity='0.5'/>
      <path d='M24 -38 Q32 0 24 38' stroke='#f57c00' stroke-width='2' fill='none' opacity='0.5'/>
      <path d='M-40 -25 Q-48 0 -40 25' stroke='#ef6c00' stroke-width='1.5' fill='none' opacity='0.4'/>
      <path d='M40 -25 Q48 0 40 25' stroke='#ef6c00' stroke-width='1.5' fill='none' opacity='0.4'/>
      <!-- Stem with curl -->
      <path d='M-4 -42 Q-6 -52 0 -56 Q8 -58 12 -52 Q14 -48 10 -46' fill='url(#pkStem)' stroke='#33691e' stroke-width='2'/>
      <ellipse cx='0' cy='-44' rx='8' ry='4' fill='#689f38'/>
      <!-- Small leaf -->
      <ellipse cx='14' cy='-50' rx='8' ry='5' fill='#8bc34a' transform='rotate(30,14,-50)'/>
      <path d='M10 -52 Q14 -50 18 -52' stroke='#558b2f' stroke-width='1' fill='none'/>
      <!-- Inner glow for spooky effect -->
      <ellipse rx='30' ry='26' fill='url(#pkGlow)' filter='url(#pkInnerGlow)' opacity='0.3'/>
      <!-- Spooky triangle eyes -->
      <polygon points='-20,-8 -12,-22 -4,-8' fill='#1a1a1a'/>
      <polygon points='-18,-10 -12,-20 -6,-10' fill='url(#pkInner)' opacity='0.6'/>
      <polygon points='4,-8 12,-22 20,-8' fill='#1a1a1a'/>
      <polygon points='6,-10 12,-20 18,-10' fill='url(#pkInner)' opacity='0.6'/>
      <!-- Glowing eye effect -->
      <circle cx='-12' cy='-12' r='3' fill='#ffeb3b' opacity='0.4'/>
      <circle cx='12' cy='-12' r='3' fill='#ffeb3b' opacity='0.4'/>
      <!-- Spooky jagged mouth -->
      <path d='M-20 14 L-14 6 L-6 16 L0 4 L6 16 L14 6 L20 14' fill='#1a1a1a' stroke='#0d0d0d' stroke-width='1'/>
      <path d='M-16 12 L-12 8 L-6 14 L0 6 L6 14 L12 8 L16 12' fill='url(#pkInner)' opacity='0.5'/>
      <!-- Inner mouth glow -->
      <ellipse cx='0' cy='10' rx='12' ry='6' fill='#ffeb3b' opacity='0.2' filter='url(#pkInnerGlow)'/>
    </g>
  </svg>`);

  sprites.magnet = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='mgCap' cx='35%' cy='25%'><stop offset='0%' stop-color='#e1bee7'/><stop offset='40%' stop-color='#ba68c8'/><stop offset='80%' stop-color='#8e24aa'/><stop offset='100%' stop-color='#6a1b9a'/></radialGradient>
      <linearGradient id='mgStem' x1='0' y1='0' x2='1' y2='0'><stop offset='0%' stop-color='#e8eaf6'/><stop offset='50%' stop-color='#fafafa'/><stop offset='100%' stop-color='#eceff1'/></linearGradient>
      <linearGradient id='mgRed' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#ef5350'/><stop offset='50%' stop-color='#e53935'/><stop offset='100%' stop-color='#c62828'/></linearGradient>
      <linearGradient id='mgBlue' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#42a5f5'/><stop offset='50%' stop-color='#1e88e5'/><stop offset='100%' stop-color='#1565c0'/></linearGradient>
      <radialGradient id='mgField' cx='50%' cy='50%'><stop offset='0%' stop-color='#ce93d8' stop-opacity='0.5'/><stop offset='100%' stop-color='#9c27b0' stop-opacity='0'/></radialGradient>
      <filter id='mgShadow'><feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#4a148c' flood-opacity='0.4'/></filter>
      <filter id='mgGlow'><feGaussianBlur stdDeviation='2'/></filter>
    </defs>
    <g transform='translate(80,85)'>
      <!-- Magnetic field aura -->
      <ellipse rx='55' ry='45' fill='url(#mgField)' filter='url(#mgGlow)' opacity='0.4'/>
      <!-- Stem with 3D shading -->
      <path d='M-12 8 Q-14 28 -10 50 Q0 58 10 50 Q14 28 12 8' fill='url(#mgStem)' stroke='#b0bec5' stroke-width='1.5'/>
      <path d='M-7 12 Q-9 30 -5 45' stroke='#fff' stroke-width='2' fill='none' opacity='0.5'/>
      <!-- Main cap -->
      <ellipse cx='0' cy='-5' rx='42' ry='30' fill='url(#mgCap)' stroke='#4a148c' stroke-width='2' filter='url(#mgShadow)'/>
      <!-- Cap highlight -->
      <ellipse cx='-14' cy='-18' rx='16' ry='10' fill='#e1bee7' opacity='0.5'/>
      <!-- Decorative spots -->
      <circle cx='-22' cy='-2' r='6' fill='#f3e5f5' opacity='0.8'/>
      <circle cx='-20' cy='-4' r='2.5' fill='#fff' opacity='0.5'/>
      <circle cx='20' cy='-8' r='5' fill='#f3e5f5' opacity='0.7'/>
      <circle cx='18' cy='-10' r='2' fill='#fff' opacity='0.4'/>
      <circle cx='-8' cy='8' r='4' fill='#e1bee7' opacity='0.6'/>
      <circle cx='28' cy='2' r='4' fill='#f3e5f5' opacity='0.5'/>
      <!-- 3D Magnet on top -->
      <g transform='translate(0,-30)'>
        <!-- Magnet arc -->
        <path d='M-18 0 L-18 -18 A18 18 0 0 1 18 -18 L18 0' stroke='#9e9e9e' stroke-width='10' fill='none' stroke-linecap='round'/>
        <path d='M-16 -2 L-16 -16 A16 16 0 0 1 16 -16 L16 -2' stroke='#bdbdbd' stroke-width='6' fill='none' stroke-linecap='round'/>
        <!-- Red pole -->
        <rect x='-22' y='-5' width='12' height='10' rx='2' fill='url(#mgRed)' stroke='#b71c1c' stroke-width='1'/>
        <rect x='-20' y='-3' width='3' height='6' fill='#ef9a9a' opacity='0.5'/>
        <text x='-16' y='2' font-size='6' fill='#fff' text-anchor='middle' font-weight='bold'>N</text>
        <!-- Blue pole -->
        <rect x='10' y='-5' width='12' height='10' rx='2' fill='url(#mgBlue)' stroke='#0d47a1' stroke-width='1'/>
        <rect x='12' y='-3' width='3' height='6' fill='#90caf9' opacity='0.5'/>
        <text x='16' y='2' font-size='6' fill='#fff' text-anchor='middle' font-weight='bold'>S</text>
        <!-- Magnetic field lines -->
        <path d='M-10 -22 Q0 -32 10 -22' stroke='#ce93d8' stroke-width='1' fill='none' opacity='0.6'/>
        <path d='M-14 -26 Q0 -38 14 -26' stroke='#ba68c8' stroke-width='1' fill='none' opacity='0.4'/>
      </g>
      <!-- Cute focused eyes -->
      <ellipse cx='-10' cy='6' rx='6' ry='7' fill='#fff' stroke='#7b1fa2' stroke-width='1'/>
      <ellipse cx='10' cy='6' rx='6' ry='7' fill='#fff' stroke='#7b1fa2' stroke-width='1'/>
      <circle cx='-9' cy='7' r='3.5' fill='#1a1a1a'/><circle cx='11' cy='7' r='3.5' fill='#1a1a1a'/>
      <circle cx='-8' cy='5' r='1.5' fill='#fff'/><circle cx='12' cy='5' r='1.5' fill='#fff'/>
      <!-- Small content smile -->
      <path d='M-4 14 Q0 17 4 14' stroke='#6a1b9a' stroke-width='2' fill='none' stroke-linecap='round'/>
    </g>
  </svg>`);

  sprites.spiker = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='trBase' cx='40%' cy='30%'><stop offset='0%' stop-color='#d7ccc8'/><stop offset='60%' stop-color='#8d6e63'/><stop offset='100%' stop-color='#5d4037'/></radialGradient>
      <linearGradient id='trSpike' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#ffffff'/><stop offset='60%' stop-color='#b0bec5'/><stop offset='100%' stop-color='#37474f'/></linearGradient>
      <filter id='trShadow'><feDropShadow dx='0' dy='3' stdDeviation='3' flood-color='#2e2723' flood-opacity='0.6'/></filter>
    </defs>
    <g transform='translate(80,95)'>
      <!-- wide armored root base -->
      <ellipse rx='46' ry='26' fill='url(#trBase)' stroke='#3e2723' stroke-width='2' filter='url(#trShadow)'/>
      <!-- central core with metal spikes -->
      <g>
        <polygon points='-38,-6 -18,-46 0,-10' fill='url(#trSpike)' stroke='#2b2b2b' stroke-width='1'/>
        <polygon points='-10,-6 8,-50 28,-8' fill='url(#trSpike)' stroke='#2b2b2b' stroke-width='1'/>
        <polygon points='20,-4 36,-42 50,-6' fill='url(#trSpike)' stroke='#2b2b2b' stroke-width='1'/>
      </g>
      <!-- thorny rim -->
      <g fill='#7b1c1c' stroke='#4a0000' stroke-width='0.6'>
        <path d='M-30,0 L-36,-8 L-24,-4 Z'/>
        <path d='M-10,-2 L-16,-14 L-4,-6 Z'/>
        <path d='M8,-4 L2,-18 L14,-8 Z'/>
        <path d='M28,-2 L22,-16 L34,-6 Z'/>
      </g>
      <!-- menacing eyes and blood spatters -->
      <ellipse cx='-18' cy='2' rx='6' ry='5' fill='#fff' stroke='#2e1b17' stroke-width='1'/>
      <ellipse cx='18' cy='2' rx='6' ry='5' fill='#fff' stroke='#2e1b17' stroke-width='1'/>
      <circle cx='-17' cy='3' r='2.5' fill='#2e1b17'/>
      <circle cx='19' cy='3' r='2.5' fill='#2e1b17'/>
      <g fill='#b71c1c' opacity='0.85'>
        <circle cx='6' cy='8' r='3'/>
        <path d='M-6 10 Q-2 14 2 12 Q6 10 8 14 Q4 16 -2 14 Q-8 12 -6 8 Z'/>
      </g>
      <!-- root tendrils -->
      <path d='M-42 20 Q-30 34 -10 32 Q0 30 10 34 Q30 38 44 20' stroke='#4e342e' stroke-width='3' fill='none' opacity='0.8'/>
    </g>
  </svg>`);

  // SQUASH - Jumps on zombies to squash them (day plant #10)
  sprites.squash = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='sqBody' cx='35%' cy='30%'><stop offset='0%' stop-color='#a5d6a7'/><stop offset='50%' stop-color='#66bb6a'/><stop offset='100%' stop-color='#2e7d32'/></radialGradient>
      <linearGradient id='sqLeaf' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#81c784'/><stop offset='100%' stop-color='#388e3c'/></linearGradient>
    </defs>
    <g transform='translate(80,85)'>
      <!-- Shadow -->
      <ellipse cx='0' cy='35' rx='28' ry='10' fill='#1b5e20' opacity='0.4'/>
      <!-- Legs -->
      <ellipse cx='-18' cy='28' rx='10' ry='8' fill='#4caf50' stroke='#2e7d32' stroke-width='2'/>
      <ellipse cx='18' cy='28' rx='10' ry='8' fill='#4caf50' stroke='#2e7d32' stroke-width='2'/>
      <!-- Main body - squash shape -->
      <ellipse cx='0' cy='0' rx='32' ry='28' fill='url(#sqBody)' stroke='#2e7d32' stroke-width='2'/>
      <!-- Body stripes -->
      <path d='M-20 -15 Q0 -25 20 -15' stroke='#81c784' stroke-width='3' fill='none' opacity='0.5'/>
      <path d='M-25 0 Q0 -10 25 0' stroke='#81c784' stroke-width='2' fill='none' opacity='0.4'/>
      <!-- Stem -->
      <rect x='-4' y='-32' width='8' height='10' rx='3' fill='#8d6e63' stroke='#5d4037' stroke-width='1'/>
      <!-- Leaf -->
      <ellipse cx='8' cy='-35' rx='12' ry='6' fill='url(#sqLeaf)' stroke='#2e7d32' stroke-width='1' transform='rotate(20)'/>
      <!-- Angry determined eyes -->
      <ellipse cx='-12' cy='-5' rx='9' ry='10' fill='#fff' stroke='#2e7d32' stroke-width='1'/>
      <ellipse cx='12' cy='-5' rx='9' ry='10' fill='#fff' stroke='#2e7d32' stroke-width='1'/>
      <circle cx='-10' cy='-3' r='5' fill='#1b5e20'/><circle cx='14' cy='-3' r='5' fill='#1b5e20'/>
      <circle cx='-9' cy='-4' r='2' fill='#fff'/><circle cx='15' cy='-4' r='2' fill='#fff'/>
      <!-- Angry eyebrows -->
      <path d='M-20 -14 L-6 -12' stroke='#1b5e20' stroke-width='3' stroke-linecap='round'/>
      <path d='M20 -14 L6 -12' stroke='#1b5e20' stroke-width='3' stroke-linecap='round'/>
      <!-- Determined frown -->
      <path d='M-8 10 Q0 6 8 10' stroke='#1b5e20' stroke-width='3' fill='none'/>
    </g>
  </svg>`);

  // CLOVER (Cá» 4 lÃ¡) - Platform for planting on top 2 rows, has spinning propeller effect
  sprites.clover = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='clLeaf' cx='30%' cy='30%'>
        <stop offset='0%' stop-color='#c8e6c9'/>
        <stop offset='50%' stop-color='#66bb6a'/>
        <stop offset='100%' stop-color='#2e7d32'/>
      </radialGradient>
      <linearGradient id='clStem' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#81c784'/>
        <stop offset='100%' stop-color='#388e3c'/>
      </linearGradient>
    </defs>
    <g transform='translate(80,85)'>
      <!-- Shadow -->
      <ellipse cx='0' cy='35' rx='25' ry='8' fill='rgba(0,0,0,0.3)'/>
      
      <!-- Main stem -->
      <rect x='-4' y='10' width='8' height='30' rx='3' fill='url(#clStem)' stroke='#2e7d32' stroke-width='1'/>
      
      <!-- Four-leaf clover leaves (heart-shaped) -->
      <!-- Top leaf -->
      <g transform='translate(0,-25)'>
        <path d='M0 0 C-15 -10 -18 -25 0 -35 C18 -25 15 -10 0 0' fill='url(#clLeaf)' stroke='#2e7d32' stroke-width='1.5'/>
        <path d='M0 -5 L0 -28' stroke='#43a047' stroke-width='2' opacity='0.5'/>
      </g>
      <!-- Right leaf -->
      <g transform='translate(25,0) rotate(90)'>
        <path d='M0 0 C-15 -10 -18 -25 0 -35 C18 -25 15 -10 0 0' fill='url(#clLeaf)' stroke='#2e7d32' stroke-width='1.5'/>
        <path d='M0 -5 L0 -28' stroke='#43a047' stroke-width='2' opacity='0.5'/>
      </g>
      <!-- Bottom leaf -->
      <g transform='translate(0,25) rotate(180)'>
        <path d='M0 0 C-15 -10 -18 -25 0 -35 C18 -25 15 -10 0 0' fill='url(#clLeaf)' stroke='#2e7d32' stroke-width='1.5'/>
        <path d='M0 -5 L0 -28' stroke='#43a047' stroke-width='2' opacity='0.5'/>
      </g>
      <!-- Left leaf -->
      <g transform='translate(-25,0) rotate(-90)'>
        <path d='M0 0 C-15 -10 -18 -25 0 -35 C18 -25 15 -10 0 0' fill='url(#clLeaf)' stroke='#2e7d32' stroke-width='1.5'/>
        <path d='M0 -5 L0 -28' stroke='#43a047' stroke-width='2' opacity='0.5'/>
      </g>
      
      <!-- Center hub -->
      <circle cx='0' cy='0' r='8' fill='#4caf50' stroke='#2e7d32' stroke-width='2'/>
      <circle cx='0' cy='0' r='4' fill='#81c784'/>
      
      <!-- Lucky number 4 symbol -->
      <text x='0' y='3' text-anchor='middle' font-size='8' font-weight='bold' fill='#1b5e20'>4</text>
      
      <!-- Sparkles for luck -->
      <g fill='#ffeb3b' opacity='0.8'>
        <polygon points='-30,-30 -28,-26 -24,-28' />
        <polygon points='28,-25 30,-21 34,-23' />
        <polygon points='-32,15 -30,19 -26,17' />
        <polygon points='30,20 32,24 36,22' />
      </g>
    </g>
  </svg>`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NIGHT MUSHROOM PLANTS (10 types)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // PUFF-SHROOM - Free small mushroom (night plant #1)
  sprites.puffshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='psCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#e1bee7'/><stop offset='60%' stop-color='#9c27b0'/><stop offset='100%' stop-color='#6a1b9a'/></radialGradient>
    </defs>
    <g transform='translate(80,90) scale(0.25)'>
      <ellipse cx='0' cy='20' rx='12' ry='6' fill='#4a148c' opacity='0.5'/>
      <rect x='-6' y='0' width='12' height='22' rx='4' fill='#e1bee7' stroke='#7b1fa2' stroke-width='1'/>
      <ellipse cx='0' cy='-8' rx='20' ry='18' fill='url(#psCap)' stroke='#6a1b9a' stroke-width='2'/>
      <ellipse cx='-8' cy='-12' rx='4' ry='3' fill='#f3e5f5' opacity='0.6'/>
      <ellipse cx='6' cy='-6' rx='3' ry='2' fill='#f3e5f5' opacity='0.5'/>
      <circle cx='-5' cy='-5' r='3' fill='#fff'/><circle cx='5' cy='-5' r='3' fill='#fff'/>
      <circle cx='-4' cy='-4' r='1.5' fill='#4a148c'/><circle cx='6' cy='-4' r='1.5' fill='#4a148c'/>
      <ellipse cx='0' cy='2' rx='4' ry='2' fill='#4a148c'/>
    </g>
  </svg>`);

  // SCAREDY-SHROOM - Long range but hides when zombies close (night plant #2)
  sprites.scaredyshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='ssCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#fff9c4'/><stop offset='60%' stop-color='#ffeb3b'/><stop offset='100%' stop-color='#f9a825'/></radialGradient>
    </defs>
    <g transform='translate(80,85)'>
      <ellipse cx='0' cy='30' rx='14' ry='7' fill='#f57f17' opacity='0.5'/>
      <rect x='-7' y='0' width='14' height='32' rx='5' fill='#fff9c4' stroke='#f9a825' stroke-width='1'/>
      <ellipse cx='0' cy='-12' rx='26' ry='22' fill='url(#ssCap)' stroke='#f57f17' stroke-width='2'/>
      <ellipse cx='-10' cy='-18' rx='5' ry='4' fill='#fffde7' opacity='0.7'/>
      <!-- Worried eyes -->
      <ellipse cx='-8' cy='-8' rx='6' ry='8' fill='#fff' stroke='#f57f17' stroke-width='1'/>
      <ellipse cx='8' cy='-8' rx='6' ry='8' fill='#fff' stroke='#f57f17' stroke-width='1'/>
      <circle cx='-6' cy='-6' r='3' fill='#5d4037'/><circle cx='10' cy='-6' r='3' fill='#5d4037'/>
      <!-- Worried eyebrows -->
      <path d='M-14 -16 L-4 -14' stroke='#f57f17' stroke-width='2'/>
      <path d='M14 -16 L4 -14' stroke='#f57f17' stroke-width='2'/>
      <ellipse cx='0' cy='4' rx='5' ry='3' fill='#5d4037'/>
    </g>
  </svg>`);

  // FUME-SHROOM - Shoots fumes that pierce zombies (night plant #3)
  sprites.fumeshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='fsCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#b39ddb'/><stop offset='60%' stop-color='#673ab7'/><stop offset='100%' stop-color='#4527a0'/></radialGradient>
    </defs>
    <g transform='translate(80,85)'>
      <ellipse cx='0' cy='28' rx='16' ry='8' fill='#311b92' opacity='0.5'/>
      <rect x='-8' y='0' width='16' height='30' rx='6' fill='#d1c4e9' stroke='#5e35b1' stroke-width='1'/>
      <ellipse cx='0' cy='-10' rx='30' ry='24' fill='url(#fsCap)' stroke='#4527a0' stroke-width='2'/>
      <!-- Smoke coming out -->
      <ellipse cx='25' cy='-8' rx='8' ry='6' fill='#9575cd' opacity='0.7'/>
      <ellipse cx='35' cy='-10' rx='6' ry='5' fill='#b39ddb' opacity='0.5'/>
      <!-- Angry eyes -->
      <ellipse cx='-10' cy='-8' rx='6' ry='7' fill='#fff' stroke='#4527a0' stroke-width='1'/>
      <ellipse cx='6' cy='-8' rx='6' ry='7' fill='#fff' stroke='#4527a0' stroke-width='1'/>
      <circle cx='-8' cy='-6' r='3' fill='#311b92'/><circle cx='8' cy='-6' r='3' fill='#311b92'/>
      <path d='M-16 -18 L-6 -14' stroke='#4527a0' stroke-width='2.5'/>
      <path d='M12 -18 L2 -14' stroke='#4527a0' stroke-width='2.5'/>
      <path d='M-6 4 Q0 8 6 4' stroke='#4527a0' stroke-width='2' fill='none'/>
    </g>
  </svg>`);

  // HYPNO-SHROOM - Hypnotizes zombies when eaten (night plant #4)
  sprites.hypnoshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='hsCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#80deea'/><stop offset='60%' stop-color='#00bcd4'/><stop offset='100%' stop-color='#00838f'/></radialGradient>
    </defs>
    <g transform='translate(80,85)'>
      <ellipse cx='0' cy='28' rx='15' ry='8' fill='#006064' opacity='0.5'/>
      <rect x='-8' y='0' width='16' height='30' rx='6' fill='#b2ebf2' stroke='#0097a7' stroke-width='1'/>
      <ellipse cx='0' cy='-10' rx='28' ry='24' fill='url(#hsCap)' stroke='#00838f' stroke-width='2'/>
      <!-- Polka dots -->
      <circle cx='-12' cy='-15' r='4' fill='#e0f7fa' opacity='0.7'/>
      <circle cx='8' cy='-18' r='3' fill='#e0f7fa' opacity='0.6'/>
      <circle cx='0' cy='-5' r='3' fill='#e0f7fa' opacity='0.5'/>
      <!-- Spiral hypno eyes -->
      <circle cx='-10' cy='-8' r='8' fill='#fff' stroke='#00838f' stroke-width='1'/>
      <circle cx='10' cy='-8' r='8' fill='#fff' stroke='#00838f' stroke-width='1'/>
      <circle cx='-10' cy='-8' r='6' fill='none' stroke='#e91e63' stroke-width='1.5'/>
      <circle cx='-10' cy='-8' r='4' fill='none' stroke='#e91e63' stroke-width='1.5'/>
      <circle cx='-10' cy='-8' r='2' fill='#e91e63'/>
      <circle cx='10' cy='-8' r='6' fill='none' stroke='#e91e63' stroke-width='1.5'/>
      <circle cx='10' cy='-8' r='4' fill='none' stroke='#e91e63' stroke-width='1.5'/>
      <circle cx='10' cy='-8' r='2' fill='#e91e63'/>
      <!-- Smile -->
      <path d='M-5 6 Q0 10 5 6' stroke='#00838f' stroke-width='2' fill='none'/>
    </g>
  </svg>`);

  // STRAW-SHROOM - Throws spores that arc onto zombies (night plant #5)
  sprites.strawshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='ssCapPink' cx='40%' cy='30%'><stop offset='0%' stop-color='#f8bbd0'/><stop offset='60%' stop-color='#e91e63'/><stop offset='100%' stop-color='#ad1457'/></radialGradient>
      <linearGradient id='ssStrawPink' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#f8bbd0'/><stop offset='100%' stop-color='#e91e63'/></linearGradient>
    </defs>
    <g transform='translate(80,85)'>
      <!-- Shadow -->
      <ellipse cx='0' cy='32' rx='18' ry='8' fill='#ad1457' opacity='0.4'/>
      <!-- Straw base/skirt -->
      <path d='M-20 25 L-25 35 L25 35 L20 25 Z' fill='url(#ssStrawPink)' stroke='#e91e63' stroke-width='1'/>
      <path d='M-22 30 L-18 30 M-12 32 L-8 28 M0 33 L0 28 M10 31 L12 27 M18 30 L22 30' stroke='#e91e63' stroke-width='1.5'/>
      <!-- Stem -->
      <rect x='-10' y='0' width='20' height='28' rx='8' fill='#f8bbd0' stroke='#e91e63' stroke-width='1'/>
      <!-- Cap - conical straw hat shape -->
      <ellipse cx='0' cy='-5' rx='30' ry='20' fill='url(#ssCapPink)' stroke='#e91e63' stroke-width='2'/>
      <!-- Straw texture on cap -->
      <path d='M-25 -2 Q-15 -15 0 -18 Q15 -15 25 -2' stroke='#f8bbd0' stroke-width='2' fill='none' opacity='0.6'/>
      <path d='M-20 2 Q-10 -8 0 -10 Q10 -8 20 2' stroke='#e91e63' stroke-width='1.5' fill='none' opacity='0.5'/>
      <!-- Cute eyes -->
      <ellipse cx='-10' cy='-2' rx='6' ry='7' fill='#fff' stroke='#e91e63' stroke-width='1'/>
      <ellipse cx='10' cy='-2' rx='6' ry='7' fill='#fff' stroke='#e91e63' stroke-width='1'/>
      <circle cx='-8' cy='0' r='3' fill='#ad1457'/><circle cx='12' cy='0' r='3' fill='#ad1457'/>
      <circle cx='-7' cy='-1' r='1' fill='#fff'/><circle cx='13' cy='-1' r='1' fill='#fff'/>
      <!-- Happy smile -->
      <path d='M-6 8 Q0 14 6 8' stroke='#e91e63' stroke-width='2' fill='none'/>
      <!-- Flying spore above -->
      <circle cx='20' cy='-30' r='5' fill='#e91e63' stroke='#ad1457' stroke-width='1'/>
      <circle cx='20' cy='-30' r='2' fill='#f8bbd0'/>
    </g>
  </svg>`);

  // Spore projectile for straw-shroom
  sprites.spore = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'>
    <circle cx='16' cy='16' r='10' fill='#ffb74d' stroke='#f57c00' stroke-width='2'/>
    <circle cx='14' cy='14' r='4' fill='#fff8e1' opacity='0.7'/>
  </svg>`);

  // ICE-SHROOM - Freezes all zombies (night plant #6)
  sprites.iceshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='isCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#e3f2fd'/><stop offset='60%' stop-color='#90caf9'/><stop offset='100%' stop-color='#1976d2'/></radialGradient>
    </defs>
    <g transform='translate(80,85)'>
      <ellipse cx='0' cy='28' rx='15' ry='8' fill='#0d47a1' opacity='0.5'/>
      <rect x='-8' y='0' width='16' height='30' rx='6' fill='#e3f2fd' stroke='#1976d2' stroke-width='1'/>
      <ellipse cx='0' cy='-10' rx='28' ry='24' fill='url(#isCap)' stroke='#1565c0' stroke-width='2'/>
      <!-- Ice crystals -->
      <polygon points='0,-30 -3,-22 3,-22' fill='#e3f2fd' stroke='#64b5f6' stroke-width='1'/>
      <polygon points='-15,-25 -12,-18 -18,-18' fill='#bbdefb' stroke='#64b5f6' stroke-width='1'/>
      <polygon points='15,-25 12,-18 18,-18' fill='#bbdefb' stroke='#64b5f6' stroke-width='1'/>
      <!-- Sleepy eyes -->
      <path d='M-14 -8 Q-10 -10 -6 -8' stroke='#1565c0' stroke-width='2' fill='none'/>
      <path d='M6 -8 Q10 -10 14 -8' stroke='#1565c0' stroke-width='2' fill='none'/>
      <path d='M-5 4 Q0 6 5 4' stroke='#1565c0' stroke-width='2' fill='none'/>
    </g>
  </svg>`);

  // DOOM-SHROOM - Huge explosion (night plant #7)
  sprites.doomshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='dsCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#616161'/><stop offset='60%' stop-color='#424242'/><stop offset='100%' stop-color='#212121'/></radialGradient>
    </defs>
    <g transform='translate(80,85)'>
      <ellipse cx='0' cy='28' rx='18' ry='9' fill='#000' opacity='0.6'/>
      <rect x='-10' y='-5' width='20' height='35' rx='8' fill='#757575' stroke='#424242' stroke-width='2'/>
      <ellipse cx='0' cy='-15' rx='35' ry='28' fill='url(#dsCap)' stroke='#212121' stroke-width='2'/>
      <!-- Skull pattern -->
      <ellipse cx='0' cy='-12' rx='12' ry='10' fill='#9e9e9e'/>
      <circle cx='-5' cy='-14' r='3' fill='#212121'/><circle cx='5' cy='-14' r='3' fill='#212121'/>
      <ellipse cx='0' cy='-8' rx='2' ry='3' fill='#212121'/>
      <path d='M-6 -4 L-4 -2 L-2 -4 L0 -2 L2 -4 L4 -2 L6 -4' stroke='#212121' stroke-width='1.5' fill='none'/>
      <!-- Glowing eyes -->
      <circle cx='-5' cy='-14' r='1.5' fill='#ff5722'/>
      <circle cx='5' cy='-14' r='1.5' fill='#ff5722'/>
    </g>
  </svg>`);

  // GLOOM-SHROOM - Shoots in all directions (night plant #8)
  sprites.gloomshroom = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='gsCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#7e57c2'/><stop offset='60%' stop-color='#512da8'/><stop offset='100%' stop-color='#311b92'/></radialGradient>
    </defs>
    <g transform='translate(80,85)'>
      <ellipse cx='0' cy='28' rx='22' ry='10' fill='#1a237e' opacity='0.5'/>
      <rect x='-12' y='-5' width='24' height='35' rx='10' fill='#9575cd' stroke='#512da8' stroke-width='2'/>
      <ellipse cx='0' cy='-15' rx='38' ry='30' fill='url(#gsCap)' stroke='#311b92' stroke-width='2'/>
      <!-- Multiple barrels -->
      <circle cx='0' cy='-35' r='6' fill='#311b92'/><circle cx='0' cy='-37' r='3' fill='#1a237e'/>
      <circle cx='-20' cy='-25' r='5' fill='#311b92'/><circle cx='-22' cy='-26' r='2.5' fill='#1a237e'/>
      <circle cx='20' cy='-25' r='5' fill='#311b92'/><circle cx='22' cy='-26' r='2.5' fill='#1a237e'/>
      <circle cx='-28' cy='-10' r='5' fill='#311b92'/><circle cx='-30' cy='-10' r='2.5' fill='#1a237e'/>
      <circle cx='28' cy='-10' r='5' fill='#311b92'/><circle cx='30' cy='-10' r='2.5' fill='#1a237e'/>
      <!-- Eyes -->
      <circle cx='-8' cy='-10' r='5' fill='#fff'/><circle cx='8' cy='-10' r='5' fill='#fff'/>
      <circle cx='-6' cy='-9' r='2.5' fill='#311b92'/><circle cx='10' cy='-9' r='2.5' fill='#311b92'/>
    </g>
  </svg>`);

  // preload Image objects to avoid creating new Image every frame
  // Extra small sprites for Ember/Lumen shrooms
  sprites.embermush = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='emCap' cx='40%' cy='30%'><stop offset='0%' stop-color='#fff2e6'/><stop offset='40%' stop-color='#ff8a65'/><stop offset='100%' stop-color='#b71c1c'/></radialGradient>
      <filter id='emGlow'><feGaussianBlur stdDeviation='3' result='b'/><feMerge><feMergeNode in='b'/><feMergeNode in='SourceGraphic'/></feMerge></filter>
    </defs>
    <g transform='translate(80,80)'>
      <!-- sturdy stem / armored base -->
      <path d='M-6 18 Q-10 32 -6 50 Q0 58 6 50 Q10 32 6 18' fill='#4e342e' stroke='#3e2723' stroke-width='1.5'/>
      <!-- cap: battle-scarred with spikes -->
      <ellipse cx='0' cy='-2' rx='44' ry='30' fill='url(#emCap)' stroke='#880e0e' stroke-width='2' filter='url(#emGlow)'/>
      <!-- spikes / teeth around cap edge -->
      <g fill='#7f0000' stroke='#4a0000' stroke-width='0.6'>
        <path d='M-36 -4 L-44 -12 L-28 -8 Z'/>
        <path d='M-22 -22 L-26 -30 L-14 -26 Z'/>
        <path d='M-6 -28 L-8 -36 L2 -30 Z'/>
        <path d='M12 -26 L18 -34 L22 -26 Z'/>
        <path d='M28 -12 L38 -20 L30 -8 Z'/>
      </g>
      <!-- blood splatters and scratches -->
      <g fill='#b71c1c' opacity='0.9'>
        <ellipse cx='10' cy='0' rx='4' ry='2'/>
        <path d='M-4 6 Q-2 10 2 8 Q6 6 8 10 Q4 12 -2 10 Q-8 8 -6 4 Z'/>
      </g>
      <!-- fierce eyes -->
      <ellipse cx='-12' cy='-6' rx='6' ry='7' fill='#2e1b17'/>
      <ellipse cx='14' cy='-6' rx='6' ry='7' fill='#2e1b17'/>
      <circle cx='-11' cy='-6' r='2' fill='#fff'/>
      <circle cx='15' cy='-6' r='2' fill='#fff'/>
      <!-- scar band / metal plate -->
      <rect x='-28' y='2' width='56' height='8' rx='3' fill='#3e2723' opacity='0.6'/>
    </g>
  </svg>`);
  sprites.lumenmush = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='luCap' cx='50%' cy='30%'><stop offset='0%' stop-color='#ffffff'/><stop offset='60%' stop-color='#dff4ff'/><stop offset='100%' stop-color='#81d4fa'/></radialGradient>
      <filter id='luGlow'><feGaussianBlur stdDeviation='4' result='g'/><feMerge><feMergeNode in='g'/><feMergeNode in='SourceGraphic'/></feMerge></filter>
    </defs>
    <g transform='translate(80,80)'>
      <!-- nurse cap style: white with red cross -->
      <ellipse cx='0' cy='-12' rx='42' ry='22' fill='#fff' stroke='#e0e0e0' stroke-width='1.5'/>
      <rect x='-10' y='-18' width='20' height='8' rx='2' fill='#fff' stroke='#e0e0e0' stroke-width='1.2'/>
      <g transform='translate(0,-10)'>
        <rect x='-6' y='-2' width='12' height='12' fill='#fff'/>
        <path d='M-2 0 v-6 h4 v6 h6 v4 h-6 v6 h-4 v-6 h-6 v-4 z' fill='#d32f2f' transform='translate(-4,-6) scale(0.7)'/>
      </g>
      <!-- soft glowing cap underside -->
      <ellipse cx='0' cy='-2' rx='36' ry='20' fill='url(#luCap)' filter='url(#luGlow)'/>
      <!-- gentle smiling eyes to look caring -->
      <path d='M-14 -6 q4 6 14 0' stroke='#2e1b17' stroke-width='2' fill='none' stroke-linecap='round'/>
      <path d='M6 -6 q4 6 14 0' stroke='#2e1b17' stroke-width='2' fill='none' stroke-linecap='round'/>
      <circle cx='-12' cy='-8' r='2' fill='#fff'/>
      <circle cx='14' cy='-8' r='2' fill='#fff'/>
      <!-- nurse sash / apron hint on stem -->
      <path d='M-22 6 Q-8 18 0 10 Q8 18 22 6' fill='#fff' opacity='0.9'/>
      <path d='M-6 10 L6 10 L6 16 L-6 16 Z' fill='#dff4ff' opacity='0.95'/>
    </g>
  </svg>`);
  const spriteImages = {};
  Object.keys(sprites).forEach(k=>{ const im = new Image(); im.src = sprites[k]; spriteImages[k]=im; });

  // lawnmower sprite (upgraded 2D detailed SVG)
  sprites.lawnmower = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 48'>
    <defs>
      <linearGradient id='lmBody' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#ff8a65'/>
        <stop offset='50%' stop-color='#ff7043'/>
        <stop offset='100%' stop-color='#d84315'/>
      </linearGradient>
      <linearGradient id='lmMetal' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#cfd8dc'/>
        <stop offset='100%' stop-color='#90a4ae'/>
      </linearGradient>
      <radialGradient id='lmBladeGrd' cx='50%' cy='40%' r='60%'>
        <stop offset='0%' stop-color='#1a1a1a'/>
        <stop offset='40%' stop-color='#0f0f0f'/>
        <stop offset='100%' stop-color='#000000'/>
      </radialGradient>
      <filter id='lmShadow'><feDropShadow dx='0' dy='3' stdDeviation='3' flood-color='#000' flood-opacity='0.6'/></filter>
    </defs>
    <!-- Main body -->
    <g filter='url(#lmShadow)'>
      <rect x='6' y='8' width='72' height='24' rx='8' fill='url(#lmBody)' stroke='#bf360c' stroke-width='1.5'/>
      <!-- top cockpit metal panel -->
      <rect x='58' y='10' width='28' height='18' rx='4' fill='url(#lmMetal)' stroke='#455a64' stroke-width='1'/>
      <!-- blade housing subtle highlight -->
      <path d='M10 14 Q30 4 60 10' fill='none' stroke='rgba(255,255,255,0.12)' stroke-width='2' />
      <!-- front bumper / grill -->
      <rect x='10' y='22' width='18' height='8' rx='3' fill='#b71c1c' opacity='0.18' />
    </g>
    <!-- Saw-blade wheels -->
    <g>
      <g transform='translate(26,40)'>
        <!-- outer blade -->
        <circle r='9' fill='#050505' stroke='#000' stroke-width='2'/>
        <!-- teeth (star-like saw teeth) - sharper and highlighted -->
        <path d='M-9 0 L-6 -3 L-10 -4 L-5 -6 L-7 -9 L-3 -8 L-2 -11 L0 -7 L2 -11 L3 -8 L7 -9 L5 -6 L10 -4 L6 -3 L9 0 L6 3 L10 4 L5 6 L7 9 L3 8 L2 11 L0 7 L-2 11 L-3 8 L-7 9 L-5 6 L-10 4 L-6 3 Z' fill='#e6e6e6' stroke='#000' stroke-width='1'/>
        <!-- scalloped inner bevel (darker) -->
        <circle r='5.2' fill='rgba(0,0,0,0.18)' />
        <!-- center hub (higher contrast) -->
        <circle r='3.2' fill='#e0e0e0' stroke='#000' stroke-width='0.9'/>
      </g>
      <g transform='translate(62,40)'>
        <circle r='9' fill='#050505' stroke='#000' stroke-width='2'/>
        <path d='M-9 0 L-6 -3 L-10 -4 L-5 -6 L-7 -9 L-3 -8 L-2 -11 L0 -7 L2 -11 L3 -8 L7 -9 L5 -6 L10 -4 L6 -3 L9 0 L6 3 L10 4 L5 6 L7 9 L3 8 L2 11 L0 7 L-2 11 L-3 8 L-7 9 L-5 6 L-10 4 L-6 3 Z' fill='#e6e6e6' stroke='#000' stroke-width='1'/>
        <circle r='5.2' fill='rgba(0,0,0,0.18)' />
        <circle r='3.2' fill='#e0e0e0' stroke='#000' stroke-width='0.9'/>
      </g>
    </g>

    <!-- Rear handle (push bar) -->
    <g>
      <path d='M6 12 Q2 10 2 6 L2 4 Q2 2 6 2' fill='none' stroke='#455a64' stroke-width='3' stroke-linecap='round' stroke-linejoin='round' opacity='0.95'/>
      <rect x='2' y='0.8' width='4' height='24' rx='2' fill='url(#lmMetal)' opacity='0.9' transform='rotate(-12 4 12)' />
      <!-- handle grip -->
      <rect x='0' y='-2' width='10' height='4' rx='2' fill='#37474f' transform='translate(0,0) rotate(-12 5 0)' opacity='0.95'/>
    </g>
    <!-- Eyes removed per request; cleaner lawnmower look -->
    <!-- Headlight / accent -->
    <g>
      <ellipse cx='80' cy='20' rx='6' ry='4' fill='#ffeb3b' opacity='0.9'/>
      <ellipse cx='80' cy='20' rx='3' ry='2' fill='#fff' opacity='0.9'/>
    </g>
    <!-- small blade hint under body -->
    <path d='M18 34 L82 34' stroke='rgba(30,30,30,0.35)' stroke-width='3' stroke-linecap='round'/>
  </svg>`);

  // airplane sprite for top 2 rows (day version)
  sprites.airplane = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 40'>
    <defs>
      <linearGradient id='planeBody' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#eceff1'/><stop offset='50%' stop-color='#cfd8dc'/><stop offset='100%' stop-color='#90a4ae'/>
      </linearGradient>
      <linearGradient id='planeWing' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#b0bec5'/><stop offset='100%' stop-color='#78909c'/>
      </linearGradient>
    </defs>
    <!-- Main body (fuselage) -->
    <ellipse cx='35' cy='20' rx='30' ry='8' fill='url(#planeBody)' stroke='#607d8b' stroke-width='1'/>
    <!-- Nose cone -->
    <path d='M65 20 Q75 20 70 20 L65 16 Q72 20 65 24 Z' fill='#ff5722' stroke='#e64a19' stroke-width='0.5'/>
    <!-- Cockpit window -->
    <ellipse cx='58' cy='18' rx='6' ry='4' fill='#29b6f6' stroke='#0288d1' stroke-width='0.5'/>
    <ellipse cx='59' cy='17' rx='2' ry='1.5' fill='rgba(255,255,255,0.5)'/>
    <!-- Top wing -->
    <path d='M25 12 L45 12 L50 8 L48 6 L22 6 L18 10 Z' fill='url(#planeWing)' stroke='#546e7a' stroke-width='0.5'/>
    <!-- Bottom wing -->
    <path d='M25 28 L45 28 L50 32 L48 34 L22 34 L18 30 Z' fill='url(#planeWing)' stroke='#546e7a' stroke-width='0.5'/>
    <!-- Tail fin -->
    <path d='M5 20 L8 8 L15 10 L12 20 Z' fill='#ff5722' stroke='#e64a19' stroke-width='0.5'/>
    <path d='M5 20 L8 32 L15 30 L12 20 Z' fill='#ff5722' stroke='#e64a19' stroke-width='0.5'/>
    <!-- Tail horizontal stabilizer -->
    <path d='M8 18 L3 14 L5 12 L12 17 Z' fill='url(#planeWing)' stroke='#546e7a' stroke-width='0.5'/>
    <path d='M8 22 L3 26 L5 28 L12 23 Z' fill='url(#planeWing)' stroke='#546e7a' stroke-width='0.5'/>
    <!-- Engine -->
    <ellipse cx='35' cy='20' rx='4' ry='5' fill='#455a64' stroke='#37474f' stroke-width='0.5'/>
    <!-- Propeller blur effect -->
    <ellipse cx='72' cy='20' rx='2' ry='10' fill='rgba(100,100,100,0.3)'/>
    <!-- Windows -->
    <circle cx='48' cy='18' r='2' fill='#4fc3f7'/>
    <circle cx='42' cy='18' r='2' fill='#4fc3f7'/>
    <circle cx='36' cy='18' r='2' fill='#4fc3f7'/>
  </svg>`);

  // airplane sprite for night (with lights)
  sprites.airplaneNight = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 40'>
    <defs>
      <linearGradient id='planeBodyN' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#37474f'/><stop offset='50%' stop-color='#263238'/><stop offset='100%' stop-color='#1a1a1a'/>
      </linearGradient>
      <linearGradient id='planeWingN' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#455a64'/><stop offset='100%' stop-color='#263238'/>
      </linearGradient>
      <radialGradient id='lightGlow' cx='50%' cy='50%' r='50%'>
        <stop offset='0%' stop-color='#ffeb3b'/><stop offset='50%' stop-color='rgba(255,235,59,0.5)'/><stop offset='100%' stop-color='rgba(255,235,59,0)'/>
      </radialGradient>
    </defs>
    <!-- Main body (fuselage) - darker for night -->
    <ellipse cx='35' cy='20' rx='30' ry='8' fill='url(#planeBodyN)' stroke='#1a1a1a' stroke-width='1'/>
    <!-- Nose cone -->
    <path d='M65 20 Q75 20 70 20 L65 16 Q72 20 65 24 Z' fill='#b71c1c' stroke='#7f0000' stroke-width='0.5'/>
    <!-- Front lights (headlights) -->
    <circle cx='70' cy='18' r='4' fill='url(#lightGlow)'/>
    <circle cx='70' cy='18' r='2' fill='#ffeb3b'/>
    <circle cx='70' cy='22' r='4' fill='url(#lightGlow)'/>
    <circle cx='70' cy='22' r='2' fill='#ffeb3b'/>
    <!-- Light beam effect -->
    <path d='M72 16 L85 10 L85 14 L74 18 Z' fill='rgba(255,235,59,0.2)'/>
    <path d='M72 24 L85 30 L85 26 L74 22 Z' fill='rgba(255,235,59,0.2)'/>
    <!-- Cockpit window (lit from inside) -->
    <ellipse cx='58' cy='18' rx='6' ry='4' fill='#4fc3f7' stroke='#0288d1' stroke-width='0.5'/>
    <ellipse cx='58' cy='18' rx='4' ry='2.5' fill='rgba(255,255,255,0.3)'/>
    <!-- Top wing -->
    <path d='M25 12 L45 12 L50 8 L48 6 L22 6 L18 10 Z' fill='url(#planeWingN)' stroke='#1a1a1a' stroke-width='0.5'/>
    <!-- Wing tip lights -->
    <circle cx='48' cy='7' r='2' fill='#f44336'/>
    <circle cx='22' cy='7' r='2' fill='#4caf50'/>
    <!-- Bottom wing -->
    <path d='M25 28 L45 28 L50 32 L48 34 L22 34 L18 30 Z' fill='url(#planeWingN)' stroke='#1a1a1a' stroke-width='0.5'/>
    <!-- Wing tip lights bottom -->
    <circle cx='48' cy='33' r='2' fill='#f44336'/>
    <circle cx='22' cy='33' r='2' fill='#4caf50'/>
    <!-- Tail fin -->
    <path d='M5 20 L8 8 L15 10 L12 20 Z' fill='#b71c1c' stroke='#7f0000' stroke-width='0.5'/>
    <path d='M5 20 L8 32 L15 30 L12 20 Z' fill='#b71c1c' stroke='#7f0000' stroke-width='0.5'/>
    <!-- Tail light -->
    <circle cx='6' cy='8' r='2' fill='#ffeb3b'/>
    <!-- Tail horizontal stabilizer -->
    <path d='M8 18 L3 14 L5 12 L12 17 Z' fill='url(#planeWingN)' stroke='#1a1a1a' stroke-width='0.5'/>
    <path d='M8 22 L3 26 L5 28 L12 23 Z' fill='url(#planeWingN)' stroke='#1a1a1a' stroke-width='0.5'/>
    <!-- Engine glow -->
    <ellipse cx='35' cy='20' rx='4' ry='5' fill='#263238' stroke='#1a1a1a' stroke-width='0.5'/>
    <!-- Propeller blur effect -->
    <ellipse cx='72' cy='20' rx='2' ry='10' fill='rgba(150,150,150,0.3)'/>
    <!-- Windows (lit) -->
    <circle cx='48' cy='18' r='2' fill='#fff59d'/>
    <circle cx='42' cy='18' r='2' fill='#fff59d'/>
    <circle cx='36' cy='18' r='2' fill='#fff59d'/>
  </svg>`);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ZOMBIE â€” Classic undead humanoid with tattered suit, hunched posture
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  sprites.zombie = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <linearGradient id='zSuit' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#4a4a4a'/><stop offset='50%' stop-color='#3d3d3d'/><stop offset='100%' stop-color='#2d2d2d'/></linearGradient>
      <linearGradient id='zShirt' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#f5f5f5'/><stop offset='100%' stop-color='#bdbdbd'/></linearGradient>
    </defs>
    <g transform='translate(80,78)'>
      <!-- LEGS - walking pose -->
      <path d='M-8 52 L-12 75 L-8 76 L-4 55' fill='#3d3d3d' stroke='#2d2d2d' stroke-width='1'/>
      <path d='M8 52 L14 72 L10 74 L4 55' fill='#4a4a4a' stroke='#2d2d2d' stroke-width='1'/>
      <!-- Shoes -->
      <ellipse cx='-10' cy='76' rx='6' ry='3' fill='#1a1a1a'/>
      <ellipse cx='12' cy='73' rx='6' ry='3' fill='#1a1a1a'/>
      
      <!-- BODY - hunched torso with tattered suit -->
      <path d='M-18 15 Q-22 35 -18 55 L18 55 Q22 35 18 15 Q0 10 -18 15' fill='url(#zSuit)' stroke='#2d2d2d' stroke-width='1'/>
      <!-- Suit lapels -->
      <path d='M-8 15 L-2 35 L0 15' fill='#3d3d3d' stroke='#2d2d2d' stroke-width='0.5'/>
      <path d='M8 15 L2 35 L0 15' fill='#3d3d3d' stroke='#2d2d2d' stroke-width='0.5'/>
      <!-- White shirt and tie -->
      <path d='M-4 15 L0 45 L4 15' fill='url(#zShirt)'/>
      <path d='M-2 18 L0 42 L2 18 L0 15 Z' fill='#8b0000'/>
      <!-- Torn fabric edges -->
      <path d='M-22 50 Q-20 55 -18 50 Q-16 56 -14 52' stroke='#2d2d2d' stroke-width='1' fill='none'/>
      <path d='M18 52 Q20 56 22 50' stroke='#2d2d2d' stroke-width='1' fill='none'/>
      
      <!-- ARMS - reaching forward zombie-style -->
      <!-- Left arm (forward) -->
      <path d='M-20 18 Q-35 15 -45 25 Q-50 30 -48 35' fill='#5a7a5a' stroke='#4a6b4a' stroke-width='2'/>
      <path d='M-20 22 Q-32 20 -42 28' fill='#3d3d3d'/>
      <!-- Left hand with fingers -->
      <path d='M-48 35 L-55 30' stroke='#5a7a5a' stroke-width='4' stroke-linecap='round'/>
      <path d='M-50 33 L-56 34' stroke='#5a7a5a' stroke-width='3' stroke-linecap='round'/>
      <path d='M-50 37 L-55 40' stroke='#5a7a5a' stroke-width='3' stroke-linecap='round'/>
      <!-- Right arm (slightly back) -->
      <path d='M20 18 Q32 22 38 35 Q40 42 38 48' fill='#5a7a5a' stroke='#4a6b4a' stroke-width='2'/>
      <path d='M20 22 Q30 25 35 38' fill='#3d3d3d'/>
      <!-- Right hand -->
      <path d='M38 48 L42 52' stroke='#5a7a5a' stroke-width='4' stroke-linecap='round'/>
      <path d='M40 46 L45 48' stroke='#5a7a5a' stroke-width='3' stroke-linecap='round'/>
      
      <!-- NECK -->
      <path d='M-8 5 Q0 8 8 5 L6 15 L-6 15 Z' fill='#5a7a5a' stroke='#4a6b4a' stroke-width='1'/>
      
      <!-- HEAD - oval shaped, tilted slightly -->
      <ellipse cx='2' cy='-18' rx='22' ry='26' fill='#5a7a5a' stroke='#4a6b4a' stroke-width='2' transform='rotate(-5)'/>
      
      <!-- Balding/messy hair -->
      <path d='M-15 -42 Q-10 -48 0 -46 Q10 -48 18 -40 Q20 -35 18 -30' fill='#3d3d3d' stroke='#2d2d2d' stroke-width='1'/>
      <path d='M-18 -38 Q-20 -42 -15 -42' fill='#3d3d3d'/>
      
      <!-- Sunken eye sockets - dark empty holes -->
      <ellipse cx='-8' cy='-20' rx='6' ry='7' fill='#1a1a1a'/>
      <ellipse cx='10' cy='-18' rx='6' ry='7' fill='#1a1a1a'/>
      
      <!-- Crooked nose -->
      <path d='M0 -16 L2 -8 L-1 -6' fill='#5a7a5a' stroke='#4a6b4a' stroke-width='1'/>
      
      <!-- Groaning mouth with teeth -->
      <path d='M-10 0 Q0 8 12 2' fill='#2d1f1f' stroke='#1a0a0a' stroke-width='1'/>
      <!-- Upper teeth (some missing) -->
      <path d='M-8 0 L-7 4 L-5 0 L-2 3 L1 0 L4 4 L7 0 L9 3 L11 1' fill='#e8e0d0' stroke='#a09080' stroke-width='0.3'/>
      <!-- Lower jaw -->
      <path d='M-8 4 Q0 10 10 5' fill='#6b8e6b' stroke='#4a6b4a' stroke-width='1'/>
      
      <!-- Rotting flesh details -->
      <ellipse cx='-16' cy='-10' rx='4' ry='3' fill='#5a7a5a' opacity='0.5'/>
      <ellipse cx='18' cy='-5' rx='5' ry='4' fill='#4a6a4a' opacity='0.4'/>
    </g>
  </svg>`);

  // ARMORED ZOMBIE - Zombie in tattered suit with silver bucket helmet and armor
  sprites.armoredZombie = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'>
    <defs>
      <radialGradient id='azSkin' cx='50%' cy='50%'><stop offset='0%' stop-color='#7a9a7a'/><stop offset='100%' stop-color='#4a6b4a'/></radialGradient>
      <linearGradient id='azArmor' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#f5f5f5'/>
        <stop offset='20%' stop-color='#e0e0e0'/>
        <stop offset='50%' stop-color='#b0b0b0'/>
        <stop offset='80%' stop-color='#808080'/>
        <stop offset='100%' stop-color='#606060'/>
      </linearGradient>
      <linearGradient id='azHelmetHighlight' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0%' stop-color='#fff' stop-opacity='0.8'/>
        <stop offset='40%' stop-color='#fff' stop-opacity='0.0'/>
        <stop offset='100%' stop-color='#fff' stop-opacity='0.0'/>
      </linearGradient>
      <radialGradient id='azHelmetShadow' cx='50%' cy='80%' r='60%'>
        <stop offset='0%' stop-color='#000' stop-opacity='0.0'/>
        <stop offset='100%' stop-color='#000' stop-opacity='0.25'/>
      </radialGradient>
      <linearGradient id='azSuit' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#4a4a4a'/><stop offset='100%' stop-color='#2d2d2d'/></linearGradient>
      <filter id='azShadow'><feDropShadow dx='0' dy='2' stdDeviation='2' flood-color='#000' flood-opacity='0.4'/></filter>
    </defs>
    <g transform='translate(80,78)'>
      <!-- LEGS -->
      <path d='M-8 52 L-12 75 L-8 76 L-4 55' fill='#3d3d3d' stroke='#2d2d2d' stroke-width='1'/>
      <path d='M8 52 L14 72 L10 74 L4 55' fill='#4a4a4a' stroke='#2d2d2d' stroke-width='1'/>
      <ellipse cx='-10' cy='76' rx='6' ry='3' fill='#1a1a1a'/>
      <ellipse cx='12' cy='73' rx='6' ry='3' fill='#1a1a1a'/>
      
      <!-- BODY with chest armor plate -->
      <path d='M-18 15 Q-22 35 -18 55 L18 55 Q22 35 18 15 Q0 10 -18 15' fill='url(#azSuit)' stroke='#2d2d2d' stroke-width='1'/>
      <!-- Silver chest plate -->
      <path d='M-14 18 L-16 48 L16 48 L14 18 Q0 12 -14 18' fill='url(#azArmor)' stroke='#505050' stroke-width='1'/>
      <line x1='0' y1='15' x2='0' y2='45' stroke='#909090' stroke-width='1'/>
      <line x1='-8' y1='20' x2='-8' y2='42' stroke='#a0a0a0' stroke-width='0.5' opacity='0.6'/>
      <line x1='8' y1='20' x2='8' y2='42' stroke='#a0a0a0' stroke-width='0.5' opacity='0.6'/>
      
      <!-- Shoulder armor -->
      <ellipse cx='-20' cy='18' rx='8' ry='6' fill='url(#azArmor)' stroke='#606060' stroke-width='1'/>
      <ellipse cx='20' cy='18' rx='8' ry='6' fill='url(#azArmor)' stroke='#606060' stroke-width='1'/>
      
      <!-- ARMS with armor -->
      <path d='M-22 18 Q-38 15 -48 28' fill='url(#azSkin)' stroke='#4a6b4a' stroke-width='2'/>
      <path d='M-28 16 Q-38 18 -45 26' stroke='url(#azArmor)' stroke-width='6' fill='none'/>
      <path d='M-48 28 L-54 24 M-49 30 L-55 30 M-48 33 L-53 36' stroke='url(#azSkin)' stroke-width='3' stroke-linecap='round'/>
      <path d='M22 18 Q36 20 42 38' fill='url(#azSkin)' stroke='#4a6b4a' stroke-width='2'/>
      <path d='M26 18 Q36 22 40 34' stroke='url(#azArmor)' stroke-width='6' fill='none'/>
      
      <!-- NECK -->
      <path d='M-8 5 Q0 8 8 5 L6 15 L-6 15 Z' fill='url(#azSkin)' stroke='#4a6b4a' stroke-width='1'/>
      
      <!-- HEAD -->
      <ellipse cx='2' cy='-18' rx='22' ry='26' fill='url(#azSkin)' stroke='#4a6b4a' stroke-width='2' filter='url(#azShadow)' transform='rotate(-5)'/>
      
      <!-- BUCKET HELMET (upgraded 2D effect) -->
      <g>
        <!-- Main helmet body -->
        <path d='M-20 -40 L-22 -8 L22 -8 L20 -40 Q0 -48 -20 -40' fill='url(#azArmor)' stroke='#505050' stroke-width='2'/>
        <!-- Highlight -->
        <path d='M-18 -38 Q0 -46 18 -38 Q10 -42 0 -40 Q-10 -38 -18 -38' fill='url(#azHelmetHighlight)'/>
        <!-- Shadow at bottom -->
        <ellipse cx='0' cy='-8' rx='22' ry='7' fill='url(#azHelmetShadow)'/>
        <!-- Dark visor slot -->
        <rect x='-18' y='-25' width='36' height='12' fill='#0a0a0a'/>
        <!-- Dead red eyes visible through visor - soulless -->
        <ellipse cx='-6' cy='-20' rx='3' ry='4' fill='#8b2020'/>
        <ellipse cx='10' cy='-19' rx='3' ry='4' fill='#8b2020'/>
        <circle cx='-6' cy='-20' r='1.5' fill='#2a0a0a'/>
        <circle cx='10' cy='-19' r='1.5' fill='#2a0a0a'/>
      </g>
      <!-- Mouth visible below helmet -->
      <path d='M-10 2 Q0 10 12 4' fill='#2d1f1f' stroke='#1a0a0a' stroke-width='1'/>
      <path d='M-7 2 L-6 6 L-3 2 L0 5 L3 2 L6 5 L9 3' fill='#e8e0d0'/>
    </g>
  </svg>`);

  // BOSS GOBLIN - Giant zombie boss, like a huge hulking zombie
  sprites.bossGoblin = svgToDataURL(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'>
    <defs>
      <radialGradient id='bgSkin' cx='50%' cy='50%'><stop offset='0%' stop-color='#6a7a5f'/><stop offset='100%' stop-color='#3d4a32'/></radialGradient>
      <filter id='bgShadow'><feDropShadow dx='0' dy='3' stdDeviation='3' flood-color='#2a3020' flood-opacity='0.6'/></filter>
    </defs>
    <g transform='translate(100,100)'>
      <!-- MASSIVE TORSO - hulking zombie body -->
      <ellipse cx='0' cy='20' rx='45' ry='40' fill='url(#bgSkin)' stroke='#3d4a32' stroke-width='2' filter='url(#bgShadow)'/>
      <!-- Torn giant coat/robe -->
      <path d='M-40 -10 L-48 70 Q-40 75 0 78 Q40 75 48 70 L40 -10' fill='#2d2520' stroke='#1a1410' stroke-width='2'/>
      <!-- Coat tears and rips -->
      <path d='M-42 50 L-50 55 L-44 58 L-48 65' fill='none' stroke='#1a1410' stroke-width='1'/>
      <path d='M42 50 L50 55 L44 58 L48 65' fill='none' stroke='#1a1410' stroke-width='1'/>
      <path d='M-20 70 L-22 78 M0 72 L0 80 M20 70 L22 78' fill='none' stroke='#1a1410' stroke-width='1'/>
      <!-- Exposed rotting chest -->
      <ellipse cx='0' cy='5' rx='25' ry='20' fill='#5d6b4f' opacity='0.8'/>
      <path d='M-10 0 Q0 8 10 0' stroke='#3d4a32' stroke-width='2' fill='none'/>
      <!-- Ribs showing -->
      <path d='M-18 5 Q-8 8 -5 5 M-16 12 Q-6 14 -3 12 M-14 18 Q-4 20 0 18' stroke='#4a5540' stroke-width='2' opacity='0.6'/>
      <path d='M18 5 Q8 8 5 5 M16 12 Q6 14 3 12 M14 18 Q4 20 0 18' stroke='#4a5540' stroke-width='2' opacity='0.6'/>
      
      <!-- MASSIVE LEGS - thick zombie legs -->
      <!-- Left leg -->
      <path d='M-22 55 L-28 90 L-18 92 L-14 58' fill='#3d4a32' stroke='#2a3020' stroke-width='2'/>
      <ellipse cx='-22' cy='95' rx='12' ry='5' fill='#1a1410'/>
      <!-- Right leg forward -->
      <path d='M14 55 L20 85 L30 87 L25 58' fill='#4a5540' stroke='#2a3020' stroke-width='2'/>
      <ellipse cx='24' cy='90' rx='12' ry='5' fill='#1a1410'/>
      
      <!-- GIANT HEAD - massive zombie head -->
      <ellipse cx='0' cy='-40' rx='38' ry='42' fill='url(#bgSkin)' stroke='#3d4a32' stroke-width='2' filter='url(#bgShadow)'/>
      <!-- Balding with remaining hair patches -->
      <ellipse cx='0' cy='-70' rx='25' ry='12' fill='#5d6b4f'/>
      <path d='M-30 -55 Q-35 -70 -28 -78 Q-20 -75 -25 -60' fill='#2a2520' opacity='0.6'/>
      <path d='M30 -55 Q35 -70 28 -78 Q20 -75 25 -60' fill='#2a2520' opacity='0.6'/>
      <!-- Deep sunken eye sockets -->
      <ellipse cx='-14' cy='-45' rx='10' ry='12' fill='#0a0a0a'/>
      <ellipse cx='14' cy='-45' rx='10' ry='12' fill='#0a0a0a'/>
      <!-- Giant dead red eyes - soulless stare -->
      <circle cx='-14' cy='-44' r='7' fill='#8b2020'/>
      <circle cx='14' cy='-44' r='7' fill='#8b2020'/>
      <!-- Dark pupils -->
      <circle cx='-14' cy='-44' r='4' fill='#2a0a0a'/>
      <circle cx='14' cy='-44' r='4' fill='#2a0a0a'/>
      <!-- Heavy brow -->
      <path d='M-28 -60 Q-14 -55 -2 -58' fill='#4a5540' stroke='#3d4a32' stroke-width='2'/>
      <path d='M28 -60 Q14 -55 2 -58' fill='#4a5540' stroke='#3d4a32' stroke-width='2'/>
      <!-- Decomposing nose - mostly rotted away -->
      <path d='M0 -38 L3 -28 L0 -25 L-3 -28 Z' fill='#3d4a32'/>
      <circle cx='-2' cy='-28' r='2' fill='#2a2a25'/>
      <circle cx='2' cy='-28' r='2' fill='#2a2a25'/>
      <!-- HUGE gaping mouth with broken teeth -->
      <path d='M-25 -18 Q0 5 25 -18' fill='#1a1510' stroke='#0d0a08' stroke-width='2'/>
      <!-- Broken jagged teeth -->
      <path d='M-20 -18 L-18 -10 L-15 -18 L-10 -8 L-5 -18 L0 -6 L5 -18 L10 -10 L15 -18 L18 -8 L20 -18' fill='#c4b89a' stroke='#a09078' stroke-width='1'/>
      <!-- Lower teeth/fangs -->
      <path d='M-15 -5 L-12 -15 L-9 -5 M9 -5 L12 -15 L15 -5' fill='#d4c8a0'/>
      <!-- Drool -->
      <path d='M-5 0 Q-3 8 -6 15' stroke='#8b9a7c' stroke-width='2' opacity='0.5' fill='none'/>
      
      <!-- MASSIVE ARMS reaching forward -->
      <!-- Left arm - huge and muscular -->
      <path d='M-42 -5 Q-65 -20 -72 10 Q-70 25 -55 30' fill='url(#bgSkin)' stroke='#3d4a32' stroke-width='3'/>
      <!-- Right arm reaching -->
      <path d='M42 -5 Q65 -15 70 15 Q68 30 55 35' fill='url(#bgSkin)' stroke='#3d4a32' stroke-width='3'/>
      <!-- Giant zombie hands with clawed fingers -->
      <g transform='translate(-72,15)'>
        <ellipse cx='0' cy='5' rx='12' ry='10' fill='#5d6b4f'/>
        <path d='M-8 0 L-15 -8 M-4 -3 L-8 -15 M2 -4 L5 -18 M8 -2 L14 -12 M10 3 L18 -2' stroke='#4a5540' stroke-width='4' stroke-linecap='round'/>
        <path d='M-15 -8 L-17 -10 M-8 -15 L-9 -18 M5 -18 L6 -22 M14 -12 L16 -14 M18 -2 L21 -3' stroke='#2a2a20' stroke-width='2' stroke-linecap='round'/>
      </g>
      <g transform='translate(70,20)'>
        <ellipse cx='0' cy='5' rx='12' ry='10' fill='#5d6b4f'/>
        <path d='M8 0 L15 -8 M4 -3 L8 -15 M-2 -4 L-5 -18 M-8 -2 L-14 -12 M-10 3 L-18 -2' stroke='#4a5540' stroke-width='4' stroke-linecap='round'/>
        <path d='M15 -8 L17 -10 M8 -15 L9 -18 M-5 -18 L-6 -22 M-14 -12 L-16 -14 M-18 -2 L-21 -3' stroke='#2a2a20' stroke-width='2' stroke-linecap='round'/>
      </g>
      <!-- Scars and wounds -->
      <path d='M-30 10 L-25 20 L-28 25' stroke='#8b4a4a' stroke-width='2' opacity='0.6'/>
      <path d='M25 15 L30 22' stroke='#8b4a4a' stroke-width='2' opacity='0.6'/>
    </g>
  </svg>`);

  // ensure newly-added sprites have corresponding Image objects
  spriteImages.lawnmower = new Image(); spriteImages.lawnmower.src = sprites.lawnmower;
  spriteImages.airplane = new Image(); spriteImages.airplane.src = sprites.airplane;
  spriteImages.airplaneNight = new Image(); spriteImages.airplaneNight.src = sprites.airplaneNight;
  spriteImages.zombie = new Image(); spriteImages.zombie.src = sprites.zombie;
  spriteImages.armoredZombie = new Image(); spriteImages.armoredZombie.src = sprites.armoredZombie;
  spriteImages.bossGoblin = new Image(); spriteImages.bossGoblin.src = sprites.bossGoblin;

  // Card definitions with cooldown (ms)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPECIAL CARD (available in both day and night) - Clover for top 2 rows
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const CLOVER_CARD = { id:'clover', name:'Cá» 4 LÃ¡', cost:25, cooldown:1500 };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DAY PLANTS (10 total - unlocked levels 1-9, level 10 has all 10)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const ALL_DAY_CARDS = [
    CLOVER_CARD,                                                       // Always available - platform for top 2 rows
    { id:'sunflower', name:'Sunflower', cost:50, cooldown:6000 },     // Level 1 (starts with)
    { id:'peashooter', name:'Cannon Pea', cost:75, cooldown:2800 },  // Level 1 (starts with)
    { id:'wallnut', name:'Wall-nut', cost:50, cooldown:15000 },       // Level 2
    { id:'cherry', name:'Cherry Bomb', cost:150, cooldown:20000 },    // Level 3
    { id:'icepea', name:'Ice Pea', cost:125, cooldown:4500 },         // Level 4
    { id:'tallnut', name:'Tall-nut', cost:125, cooldown:18000 },      // Level 5
    { id:'gatling', name:'Gatling Pea', cost:200, cooldown:10000 },   // Level 6
    { id:'spiker', name:'Thornroot', cost:250, cooldown:20000 },      // Level 7 (replaced Spikeweed) - cost increased
    { id:'squash', name:'BÃ­ Äao', cost:50, cooldown:18000 }           // Level 8
    ,{ id:'sunpea', name:'Sun Pea', cost:175, cooldown:3200 }         // Level 9 (new)
    ,{ id:'minibomb', name:'Mini-Bomb Patch', cost:25, cooldown:20000 } // Level 10 (new) - cost reduced to 25
  ];

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NIGHT MUSHROOM PLANTS (10 total - unlocked levels 11-19, level 20 has all 10)
  // When night starts, ALL day plants disappear and replaced by mushrooms
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const ALL_NIGHT_CARDS = [
    CLOVER_CARD,                                                            // Always available - platform for top 2 rows
    { id:'sunshroom', name:'Sun-shroom', cost:150, cooldown:6000 },         // Level 11 (starts with)
    { id:'puffshroom', name:'Puff-shroom', cost:0, cooldown:5000 },        // Level 11 (starts with)
    { id:'scaredyshroom', name:'Scaredy-shroom', cost:25, cooldown:5000 }, // Level 12
    { id:'fumeshroom', name:'Fume-shroom', cost:75, cooldown:5000 },      // Level 14 (moved here)
    { id:'strawshroom', name:'Náº¥m RÆ¡m', cost:150, cooldown:6000 },          // Level 15
    { id:'embermush', name:'Ember-shroom', cost:125, cooldown:9000 },   // Replaces old fire-shroom (area fire pulse)
    { id:'lumenmush', name:'Lumen-shroom', cost:150, cooldown:8000 },   // Replaces old glow-shroom (illumination + small heal)
    { id:'doomshroom', name:'Doom-shroom', cost:175, cooldown:40000 },     // Level 17
    { id:'magnet', name:'Magnet-shroom', cost:125, cooldown:18000 },        // Level 18 (cost reduced to 125)
    { id:'hypnoshroom', name:'Hypno-shroom', cost:175, cooldown:20000 },  // Level 19 (moved here, cost increased to 175)
    { id:'iceshroom', name:'Ice-shroom', cost:75, cooldown:30000 }        // Level 20 (moved)
  ];

  // Definitions & effects for night plants (descriptions in VI/EN + gameplay metadata)
  const NIGHT_PLANT_EFFECTS = {
    embermush: {
      id: 'embermush',
      vi: 'Náº¥m Lá»­a â€” má»—i vÃ i giÃ¢y phÃ¡t xung lá»­a diá»‡n rá»™ng gÃ¢y sÃ¡t thÆ°Æ¡ng lÃªn zombie trong vÃ¹ng',
      en: 'Ember-shroom â€” periodic area fire pulse that damages nearby zombies',
      radius: 2,            // tiles of illumination / effect reach
      pulseDamage: 12,     // damage per pulse
      pulseInterval: 4500, // ms between pulses
      illuminates: true
    },
    lumenmush: {
      id: 'lumenmush',
      vi: 'Náº¥m Huá»³nh quang â€” phÃ¡t sÃ¡ng vÃ¹ng xung quanh (xÃ³a sÆ°Æ¡ng) vÃ  Ä‘á»‹nh ká»³ há»“i mÃ¡u nháº¹ cho cÃ¢y lÃ¢n cáº­n',
      en: 'Lumen-shroom â€” illuminates (clears fog) and periodically heals nearby plants',
      radius: 2,
      healAmount: 4,   // reduced heal amount per request
      healInterval: 8000,
      illuminates: true
    }
  };

  // Active cards array - will be rebuilt based on level
  let CARDS = [ALL_DAY_CARDS[0], ALL_DAY_CARDS[1], ALL_DAY_CARDS[2]]; // Start with clover + sunflower + peashooter

  // Helper function to get plant max HP
  function getPlantMaxHp(plantId){
    switch(plantId){
      // Special plant
      case 'clover': return 20; // Platform for top 2 rows
      // Day plants
      case 'sunflower': return 15;
      case 'peashooter': return 15;
      case 'wallnut': return 140;
      case 'cherry': return 1;
      case 'icepea': return 15;
      case 'tallnut': return 260;
      case 'gatling': return 20;
      case 'pumpkin': return 150;
      case 'spiker': return 30;
      case 'squash': return 1; // One-time use
      case 'sunpea': return 15; // same as peashooter
      case 'minibomb': return 30; // mine-patch HP container
      // Night mushrooms
      case 'sunshroom': return 10;
      case 'puffshroom': return 5;
      case 'scaredyshroom': return 10;
      case 'fumeshroom': return 15;
      case 'hypnoshroom': return 1;
      case 'strawshroom': return 15;
      case 'iceshroom': return 1;
      case 'doomshroom': return 1; // HP
      case 'magnet': return 30;
      case 'gloomshroom': return 25;
      case 'embermush': return 12;
      case 'lumenmush': return 15;
      default: return 12;
    }
  }

  const cardState = {};

  const INITIAL_SUN = 200;
  let sun = INITIAL_SUN;
  // Falling sun pickups (day-only)
  let fallingSuns = [];
  let lastSunDrop = 0;
  const SUN_DROP_INTERVAL = 7000; // ms between sun drops
  // Rain / gloom effects for levels 5-10
  let rainDrops = [];
  const RAIN_SPAWN_COEFF = 1.0; // density multiplier for rain
  const RAIN_MAX_LEN = 20;
  let selected = null;
  let plants = [];
  let zombies = [];
  let bullets = [];
  let particles = [];
  // area/tile based visual effects (e.g., ember fire rings)
  let areaEffects = [];
  let lawnmowers = [];
  let running = false;
  let last = 0;
  let spawnAcc = 0;
  // track when the current run started (ms) to apply early-game modifiers
  let gameStartTime = 0;
  // level progression
  let currentLevel = 1;
  // Update zombie count formula per user request
  if(currentLevel <= 10){
    levelTarget = 20 + (currentLevel - 1) * 5; // Start at 20, +5 per level
  } else {
    // For map 11+, use zombie count from map 6 plus +5 per level
    levelTarget = 20 + (6 - 1) * 5 + (currentLevel - 11) * 5;
  }
  let levelSpawned = 0;
  let levelKilled = 0;
  
  // Mark game as initialized
  gameInitialized = true;
  // audio / global effects
  let zombieMoanOsc = null;
  let zombieMoanGain = null;
  let zombieMoanPlaying = false;

  // Rebuild CARDS array based on current level (day/night)
  // Day levels 1-10: Use day plants, unlock 1 per level (levels 2-9 unlock plants 3-10)
  // Night levels 11-20: ALL day plants disappear, use only mushrooms, unlock 1 per level
  function rebuildCardsForLevel(){
    const isNight = currentLevel >= 11 && currentLevel <= 20;
    
    if(isNight){
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• NIGHT MODE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Start with 3 base cards (clover + sunshroom + puffshroom)
      CARDS = [ALL_NIGHT_CARDS[0], ALL_NIGHT_CARDS[1], ALL_NIGHT_CARDS[2]];
      
      // Unlock additional mushrooms (levels 12-19 unlock mushrooms 4-11)
      // Level 11 = 3 cards, Level 12 = 4, ..., Level 19 = 11 (all), Level 20 = 11
      const nightLevel = currentLevel - 11; // 0 for level 11, 1 for level 12, etc.
      const unlockedCount = Math.min(nightLevel + 3, ALL_NIGHT_CARDS.length);
      for(let i = 3; i < unlockedCount; i++){
        CARDS.push(ALL_NIGHT_CARDS[i]);
      }
    } else {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DAY MODE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Start with 3 base cards (clover + sunflower + peashooter)
      CARDS = [ALL_DAY_CARDS[0], ALL_DAY_CARDS[1], ALL_DAY_CARDS[2]];
      
      // Unlock additional day plants (levels 2-9 unlock plants 4-11)
      // Level 1 = 3 plants, Level 2 = 4, ..., Level 9 = 11 (all), Level 10 = 11
      const unlockedCount = Math.min(currentLevel + 2, ALL_DAY_CARDS.length);
      for(let i = 3; i < unlockedCount; i++){
        CARDS.push(ALL_DAY_CARDS[i]);
      }
    }
  }

  function buildSeedBar(){
    const sunLabelText = currentLanguage === 'vi' ? 'Náº¯ng' : 'Sun';
    // Build seedBar contents without clobbering existing control buttons
    seedBar.innerHTML = '';
    const sunTile = document.createElement('div'); sunTile.className = 'sunTile';
    sunTile.innerHTML = `<div class="sunNum"><span id="sun">${sun}</span></div><div class="sunLabel">${sunLabelText}</div>`;
    seedBar.appendChild(sunTile);
    CARDS.forEach(def=>{
      const card = document.createElement('div'); card.className='seedCard'; card.dataset.id = def.id;
      const icon = document.createElement('div'); icon.className='seedIcon'; const img = new Image(); img.src = sprites[def.id]; img.style.width='44px'; img.style.height='44px'; icon.appendChild(img);
      const plantName = t(def.id) || def.name;
      const sunText = currentLanguage === 'vi' ? 'Náº¯ng' : 'Sun';
      const info = document.createElement('div'); info.className='seedInfo';
      info.innerHTML = `<div style="font-weight:800">${plantName}</div><div class="seedCost">${def.cost} ${sunText}</div>`;
      const mask = document.createElement('div'); mask.className='cooldownMask'; mask.style.transform = 'scaleY(0)'; mask.style.display='none';
      card.appendChild(icon); card.appendChild(info); card.appendChild(mask);
      card.onclick = ()=>{
        const st = cardState[def.id]; const now = performance.now();
        if(!window.devNoCd && st.cooldownUntil > now) return; if(sun < def.cost) return;
        // select
        document.querySelectorAll('.seedCard').forEach(c=>c.classList.remove('selected'));
        card.classList.add('selected'); selected = def.id;
      };
      seedBar.appendChild(card);
      cardState[def.id] = { def, el:card, mask, cooldownUntil:0 };
    });
    // Ensure Start/Pause/Reset are present in the toolbar: move existing buttons into a ctrlStack
    try{
      let stack = document.querySelector('#seedBar .ctrlStack');
      if(!stack){ stack = document.createElement('div'); stack.className = 'ctrlStack'; }
      // Try to reuse existing buttons; if they were removed by innerHTML, recreate them and attach handlers
      let speedBtn = document.getElementById('speedBtn');
      let pauseBtn = document.getElementById('pause');
      let resetBtn = document.getElementById('reset');
      // If speed button is missing (rare), create a simple one â€” the later speed control initializer will wire behavior
      if(!speedBtn){ speedBtn = document.createElement('button'); speedBtn.id = 'speedBtn'; speedBtn.textContent = `âš¡ ${gameSpeedMultiplier}x`; speedBtn.style.background = '#ff6b6b'; }
      if(!pauseBtn){ pauseBtn = document.createElement('button'); pauseBtn.id = 'pause'; pauseBtn.textContent = t('pause'); pauseBtn.onclick = ()=>{ running = !running; if(running){ last = performance.now(); requestAnimationFrame(loop); try{ startMusic(); }catch(e){} } else { try{ stopMusic(); }catch(e){} } }; }
      if(!resetBtn){
        resetBtn = document.createElement('button');
        resetBtn.id = 'reset';
      }
      // ensure reset uses the same toolbar button styling as pause
      resetBtn.textContent = t('reset');
      resetBtn.className = '';
      resetBtn.onclick = ()=>{
        sun = 200;
        plants = [];
        zombies = [];
        bullets = [];
        particles = [];
        running = false;
        initLawnmowers();
        updateUI();
        menuOverlay.style.display = 'flex';
        try { stopMusic(); } catch(e){}
        currentLevel = 1;
        levelTarget = 20;
        levelSpawned = 0;
        levelKilled = 0;
        spawnAcc = 0;
        rebuildCardsForLevel();
        buildSeedBar();
        try { stopZombieMoan(); } catch(e){}
        document.getElementById('gameOverOverlay').style.display = 'none';
      };
      if(!stack.contains(speedBtn)) stack.appendChild(speedBtn);
      if(!stack.contains(pauseBtn)) stack.appendChild(pauseBtn);
      if(!stack.contains(resetBtn)) stack.appendChild(resetBtn);
      // append control stack at the end so margin-left:auto pushes it to the right
      if(!seedBar.contains(stack)) seedBar.appendChild(stack);
      // Ensure hammer button sits under Skip Level in the top controls area (so it's visually under Skip)
      try{
        const controlsDiv = document.getElementById('controls');
        if(controlsDiv){
          // Create or reuse a right-side vertical container so Skip and Hammer stack vertically
          let rightControls = document.getElementById('rightControls');
          if(!rightControls){
            rightControls = document.createElement('div');
            rightControls.id = 'rightControls';
            rightControls.style.display = 'flex';
            rightControls.style.flexDirection = 'column';
            rightControls.style.gap = '6px';
            rightControls.style.alignItems = 'flex-end';
          }
          // Ensure speed button remains directly inside #controls (not stacked)
          // Move skipLevel into rightControls so hammer can sit beneath it
          const skipEl = document.getElementById('skipLevel');
          if(skipEl && skipEl.parentElement !== rightControls){
            // ensure skip button shows translated label
            skipEl.textContent = t('skipLevel');
            rightControls.appendChild(skipEl);
            skipEl.style.marginLeft = '';
            skipEl.style.marginTop = '0';
          }

          let hammerBtnLocal = document.getElementById('hammerBtn');
          if(!hammerBtnLocal){
            hammerBtnLocal = document.createElement('button');
            hammerBtnLocal.id = 'hammerBtn';
            hammerBtnLocal.textContent = 'ğŸ”¨';
            hammerBtnLocal.title = t('hammer');
          }
          // Place hammer directly beneath skip (inside rightControls)
          if(rightControls.lastChild !== hammerBtnLocal) rightControls.appendChild(hammerBtnLocal);

          // DEV BUTTON: add below hammer
          let devBtn = document.getElementById('devBtn');
          if(!devBtn){
            devBtn = document.createElement('button');
            devBtn.id = 'devBtn';
            devBtn.textContent = 'DEV';
            devBtn.title = 'VÃ´ háº¡n máº·t trá»i';
            devBtn.style.background = '#222';
            devBtn.style.color = '#ffd600';
            devBtn.style.fontWeight = 'bold';
            devBtn.style.marginTop = '6px';
            devBtn.style.borderRadius = '7px';
          }
          if(rightControls.lastChild !== devBtn) rightControls.appendChild(devBtn);
          devBtn.onclick = ()=>{
            sun = 999999;
            window.devNoCd = true;
            // No cooldown for all cards, vÃ  báº­t cháº¿ Ä‘á»™ no-cd vÄ©nh viá»…n
            try {
              Object.values(cardState).forEach(s => { s.cooldownUntil = 0; });
            } catch(e){}
            updateUI();
          };

          // Ensure rightControls is appended to controlsDiv
          if(controlsDiv !== rightControls.parentElement) controlsDiv.appendChild(rightControls);

          hammerBtnLocal.onclick = ()=>{ hammerMode = !hammerMode; if(hammerMode){ selected = null; document.querySelectorAll('.seedCard').forEach(c=>c.classList.remove('selected')); hammerBtnLocal.style.background = '#ffd54f'; canvas.style.cursor = 'crosshair'; } else { hammerBtnLocal.style.background = ''; canvas.style.cursor = 'default'; } };
        }
      }catch(e){ console.error('hammer placement error', e); }
    }catch(e){ console.error(e); }
    updateSeedUI();
  }

  function updateLevelUI(){
    // update HUD displayed later via updateUI
    // keep placeholder if needed
  }

  function initLawnmowers(){ lawnmowers = []; for(let r=0;r<ROWS;r++){ lawnmowers.push({ row:r, x:-0.6, active:true, moving:false, speed: 0.25, hitFirst: false }); } }

  function updateSeedUI(){
    Object.values(cardState).forEach(s=>{
      const now = performance.now();
      const disabled = ((!window.devNoCd && s.cooldownUntil > now) || (sun < s.def.cost));
      s.el.classList.toggle('disabled', disabled);
      if(!window.devNoCd && s.cooldownUntil > now){ s.mask.style.display='block'; const pct = (s.cooldownUntil - now)/s.def.cooldown; s.mask.style.transform = `scaleY(${Math.max(0, pct)})`; } else { s.mask.style.display='none'; s.mask.style.transform='scaleY(0)'; }
    });
  }

  // Helper function to draw fluffy clouds
  function drawCloud(ctx, x, y, scale){
    ctx.beginPath();
    ctx.ellipse(x, y, 45*scale, 22*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x-30*scale, y+5*scale, 30*scale, 18*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+35*scale, y+3*scale, 35*scale, 16*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+15*scale, y-12*scale, 25*scale, 15*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x-15*scale, y-8*scale, 20*scale, 12*scale, 0, 0, Math.PI*2);
    ctx.fill();
  }

  

  // Helper function to draw broken angel wings behind zombies in top 2 rows
  function drawBrokenAngelWings(ctx, cx, cy, zw, zh, animPhase){
    const flapOffset = Math.sin(animPhase * 0.15) * 0.03; // Very subtle movement
    
    ctx.save();
    
    // LEFT WING - Dark fallen angel wing
    ctx.save();
    ctx.translate(cx - zw*0.25, cy);
    ctx.rotate(-0.5 + flapOffset); // Drooping down
    
    // Wing shadow/depth
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    
    // Main wing shape - dark gradient
    const leftGrd = ctx.createLinearGradient(0, -20, -55, 15);
    leftGrd.addColorStop(0, 'rgba(40,35,45,0.95)');
    leftGrd.addColorStop(0.3, 'rgba(30,25,35,0.9)');
    leftGrd.addColorStop(0.7, 'rgba(20,18,25,0.85)');
    leftGrd.addColorStop(1, 'rgba(15,12,20,0.8)');
    
    // Large primary feathers (long, elegant)
    ctx.fillStyle = leftGrd;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    // Top edge - curved elegantly
    ctx.bezierCurveTo(-15, -12, -35, -18, -50, -8);
    ctx.bezierCurveTo(-58, -2, -62, 5, -60, 12);
    // Feather tips - jagged like real feathers
    ctx.lineTo(-55, 10);
    ctx.lineTo(-52, 15);
    ctx.lineTo(-46, 12);
    ctx.lineTo(-42, 18);
    ctx.lineTo(-35, 14);
    ctx.lineTo(-30, 20);
    ctx.lineTo(-22, 15);
    ctx.lineTo(-15, 18);
    ctx.lineTo(-8, 12);
    ctx.bezierCurveTo(-4, 8, -2, 4, 0, 2);
    ctx.closePath();
    ctx.fill();
    
    // Secondary layer - slightly lighter for depth
    const secGrd = ctx.createLinearGradient(0, -10, -40, 10);
    secGrd.addColorStop(0, 'rgba(55,50,60,0.8)');
    secGrd.addColorStop(1, 'rgba(35,30,40,0.7)');
    
    ctx.fillStyle = secGrd;
    ctx.beginPath();
    ctx.moveTo(-2, 2);
    ctx.bezierCurveTo(-12, -5, -25, -8, -38, -2);
    ctx.bezierCurveTo(-42, 2, -40, 8, -35, 10);
    ctx.lineTo(-30, 8);
    ctx.lineTo(-25, 12);
    ctx.lineTo(-18, 9);
    ctx.lineTo(-12, 11);
    ctx.lineTo(-6, 7);
    ctx.closePath();
    ctx.fill();
    
    // Feather texture lines
    ctx.strokeStyle = 'rgba(70,65,80,0.6)';
    ctx.lineWidth = 1;
    for(let i = 0; i < 6; i++){
      ctx.beginPath();
      ctx.moveTo(-5 - i*8, 3 + i*2);
      ctx.lineTo(-15 - i*7, -3 + i);
      ctx.stroke();
    }
    
    // Highlight on feathers (subtle shine)
    ctx.strokeStyle = 'rgba(100,95,110,0.4)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(-10, -2);
    ctx.bezierCurveTo(-25, -8, -40, -5, -50, 0);
    ctx.stroke();
    
    // Blood stains - dark red, dripping
    ctx.fillStyle = 'rgba(100,0,0,0.7)';
    ctx.beginPath();
    ctx.ellipse(-30, 5, 6, 4, 0.3, 0, Math.PI*2);
    ctx.fill();
    // Blood drip
    ctx.fillStyle = 'rgba(80,0,0,0.6)';
    ctx.beginPath();
    ctx.moveTo(-30, 9);
    ctx.quadraticCurveTo(-31, 18, -29, 25);
    ctx.quadraticCurveTo(-27, 18, -28, 9);
    ctx.fill();
    
    // Torn/broken feather pieces
    ctx.fillStyle = 'rgba(25,20,30,0.6)';
    ctx.beginPath();
    ctx.ellipse(-58, 18, 5, 2, 0.6, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
    
    // RIGHT WING - slightly less damaged
    ctx.save();
    ctx.translate(cx + zw*0.25, cy);
    ctx.rotate(0.45 - flapOffset * 0.7);
    ctx.scale(-1, 1); // Mirror
    
    // Wing shadow
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = -3;
    ctx.shadowOffsetY = 3;
    
    // Main wing - dark gradient
    const rightGrd = ctx.createLinearGradient(0, -20, -55, 15);
    rightGrd.addColorStop(0, 'rgba(45,40,50,0.95)');
    rightGrd.addColorStop(0.3, 'rgba(35,30,40,0.92)');
    rightGrd.addColorStop(0.7, 'rgba(25,22,30,0.88)');
    rightGrd.addColorStop(1, 'rgba(18,15,22,0.82)');
    
    // Primary feathers
    ctx.fillStyle = rightGrd;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.bezierCurveTo(-18, -15, -40, -20, -55, -10);
    ctx.bezierCurveTo(-63, -3, -65, 8, -62, 15);
    // Feather tips
    ctx.lineTo(-57, 12);
    ctx.lineTo(-53, 18);
    ctx.lineTo(-47, 14);
    ctx.lineTo(-42, 20);
    ctx.lineTo(-35, 16);
    ctx.lineTo(-28, 22);
    ctx.lineTo(-20, 17);
    ctx.lineTo(-13, 20);
    ctx.lineTo(-7, 14);
    ctx.bezierCurveTo(-3, 9, -1, 5, 0, 2);
    ctx.closePath();
    ctx.fill();
    
    // Secondary layer
    ctx.fillStyle = secGrd;
    ctx.beginPath();
    ctx.moveTo(-2, 2);
    ctx.bezierCurveTo(-15, -6, -30, -10, -42, -3);
    ctx.bezierCurveTo(-46, 3, -44, 10, -38, 12);
    ctx.lineTo(-32, 10);
    ctx.lineTo(-26, 14);
    ctx.lineTo(-20, 10);
    ctx.lineTo(-14, 13);
    ctx.lineTo(-8, 9);
    ctx.closePath();
    ctx.fill();
    
    // Feather texture
    ctx.strokeStyle = 'rgba(75,70,85,0.6)';
    ctx.lineWidth = 1;
    for(let i = 0; i < 7; i++){
      ctx.beginPath();
      ctx.moveTo(-5 - i*8, 3 + i*1.8);
      ctx.lineTo(-16 - i*6, -4 + i*0.8);
      ctx.stroke();
    }
    
    // Highlight
    ctx.strokeStyle = 'rgba(105,100,115,0.35)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(-12, -4);
    ctx.bezierCurveTo(-30, -12, -48, -8, -58, 0);
    ctx.stroke();
    
    // Blood
    ctx.fillStyle = 'rgba(90,0,0,0.6)';
    ctx.beginPath();
    ctx.ellipse(-40, 8, 5, 3, -0.2, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
    
    ctx.restore();
  }

    // Draw a simple oval 'ball' plant (no stem) with eyes and optional glow
    function draw2DOvalBall(ctx, p, x, y, w, h, now, capColor1, capColor2, eyeColor, pupilColor){
      const bob = Math.sin(now/400 + (p.col||0))*2;
      const type = p && p.type;
      ctx.save();
      ctx.translate(x, y + bob);
      ctx.scale(p.scale || 1, p.scale || 1);

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.22)';
      ctx.beginPath(); ctx.ellipse(0, h*0.35, w*0.22, h*0.05, 0, 0, Math.PI*2); ctx.fill();

      // Prepare body shape parameters (default rounded ball)
      let bodyRx = w*0.42, bodyRy = h*0.28, bodyRot = 0;

      // Body gradient and subtle outline
      const capGrd = ctx.createRadialGradient(-w*0.05, -h*0.08, 0, 0, -h*0.02, w*0.45);
      capGrd.addColorStop(0, capColor1);
      capGrd.addColorStop(1, capColor2);
      ctx.fillStyle = capGrd;

      // Draw body and eyes together under rotation so they align
      ctx.save();
      if(bodyRot) ctx.rotate(bodyRot);
      ctx.beginPath(); ctx.ellipse(0, -h*0.06, bodyRx, bodyRy, 0, 0, Math.PI*2); ctx.fill();
      ctx.lineWidth = Math.max(1, Math.round(w*0.015));
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.beginPath(); ctx.ellipse(0, -h*0.06, bodyRx, bodyRy, 0, 0, Math.PI*2); ctx.stroke();

      // small glossy spot
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.beginPath(); ctx.ellipse(-w*0.08, -h*0.12, w*0.06, h*0.04, 0, 0, Math.PI*2); ctx.fill();

      // Default eye placement tuned to look like the seed icons
      let ex = w * 0.05, ey = -h * 0.045, erx = w*0.065, ery = h*0.05, pupilR = w*0.022;

      ctx.fillStyle = eyeColor || '#fff';
      ctx.beginPath(); ctx.ellipse(-ex, ey, erx, ery, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(ex, ey, erx, ery, 0, 0, Math.PI*2); ctx.fill();
      // Pupils
      ctx.fillStyle = pupilColor || '#0d0d0d';
      ctx.beginPath(); ctx.arc(-ex + w*0.01, ey + h*0.01, pupilR, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(ex + w*0.01, ey + h*0.01, pupilR, 0, Math.PI*2); ctx.fill();
      // Small eye shine
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath(); ctx.arc(-ex + w*0.02, ey - h*0.01, Math.max(1, Math.round(w*0.01)), 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(ex + w*0.02, ey - h*0.01, Math.max(1, Math.round(w*0.01)), 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

  // ====== Dark fog overlay for very late levels (>=16) ======
  // grid of illuminated cells cleared by plant placement illumination
  // store counts so overlapping illuminators don't prematurely remove light
  const illuminated = {};

  function clearFogGrid(){
    for(const k in illuminated) delete illuminated[k];
  }

  // remove a plant object and clear any fog illumination it created
  function removePlantObj(plant){
    plants = plants.filter(p=>p!==plant);
    if(plant && plant.fogKeys){
      for(const k of plant.fogKeys){
        try{ if(illuminated[k]){ illuminated[k] = Math.max(0, illuminated[k]-1); if(illuminated[k] <= 0) delete illuminated[k]; } }catch(e){}
      }
      try{ delete plant.fogKeys; }catch(e){}
    }
    // if this was a clover with a top-mounted plant, clear its topFogKeys too
    if(plant && plant.topFogKeys){
      for(const k of plant.topFogKeys){
        try{ if(illuminated[k]){ illuminated[k] = Math.max(0, illuminated[k]-1); if(illuminated[k] <= 0) delete illuminated[k]; } }catch(e){}
      }
      try{ delete plant.topFogKeys; }catch(e){}
    }
  }

  // Illuminate a square area around a tile and return the keys created
  function illuminateFrom(row, col, radius=2){
    const keys = [];
    for(let dr=-radius; dr<=radius; dr++){
      for(let dc=-radius; dc<=radius; dc++){
        const rr = row + dr, cc = col + dc;
        if(rr>=0 && rr<ROWS && cc>=0 && cc<COLS){ const k = rr + '_' + cc; illuminated[k] = (illuminated[k]||0) + 1; keys.push(k); }
      }
    }
    return keys;
  }

  // Hook into plant placement: detect placements that create illumination (fogKeys)
  // We wrap the original push to detect placements.
  (function(){
    const origPush = Array.prototype.push;
    Array.prototype.push = function(...args){
      try{
        if(this === plants){
          for(const item of args){ 
            if(item && typeof item.type === 'string' && typeof item.row === 'number' && typeof item.col === 'number'){
              // compute and store fog keys for plants that illuminate the fog
              let radius = 0;
              // use metadata from NIGHT_PLANT_EFFECTS when available
              try{ if(NIGHT_PLANT_EFFECTS && NIGHT_PLANT_EFFECTS[item.type] && NIGHT_PLANT_EFFECTS[item.type].radius) radius = NIGHT_PLANT_EFFECTS[item.type].radius; }catch(e){}
              if(radius > 0){
                const keys = illuminateFrom(item.row, item.col, radius);
                item.fogKeys = keys;
              }
            }
          }
        }
      }catch(e){ console.error('illuminate hook err', e); }
      return origPush.apply(this, args);
    };
  })();

  // Draw overlay loop that paints heavy fog when currentLevel >= 16
  function drawFogOverlay(){
    try{
      // only show for very late levels
      if(typeof currentLevel === 'undefined' || currentLevel < 16) return;
      // prepare offscreen fog canvas: fill with semi-opaque black (90% alpha)
      fogCtx.clearRect(0,0,W,H);
      fogCtx.save();
      fogCtx.globalCompositeOperation = 'source-over';
      fogCtx.fillStyle = 'rgba(0,0,0,0.9)';
      fogCtx.fillRect(0,0,W,H);
      // clear exact tile rectangles for illuminated tiles so underlying scene shows through
      Object.keys(illuminated).forEach(k=>{
        const [r,c] = k.split('_').map(Number);
        const tx = c * CW;
        const ty = r * CH;
        fogCtx.clearRect(tx, ty, CW, CH);
      });
      fogCtx.restore();

      // draw the fog overlay on top of the main canvas (preserves scene pixels)
      ctx.drawImage(fogCanvas, 0, 0, W, H);
    }catch(e){ console.warn('fog draw error', e); }
  }

  // Mushroom helpers removed

  // Ensure fog cleared when starting a new level or resetting
  const origRebuild = rebuildCardsForLevel;
  rebuildCardsForLevel = function(){ clearFogGrid(); return origRebuild(); };

  function spawnPlantParticles(x,y,color,count=12){ for(let i=0;i<count;i++){ const ang=Math.random()*Math.PI*2; const sp=0.5+Math.random()*1.6; particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp, life:500+Math.random()*400, t:0, color}); } }
  function spawnSmoke(x,y,count=6){ for(let i=0;i<count;i++){ const ang = Math.random()*Math.PI*2; const sp = 0.2 + Math.random()*0.6; const vx = Math.cos(ang)*sp*0.3; const vy = -0.6 - Math.random()*0.6; const life = 700 + Math.random()*600; const size = 6 + Math.random()*8; const shade = 80 + Math.floor(Math.random()*30); particles.push({x, y, vx, vy, life, t:0, color: `rgba(${shade},${shade},${shade},0.85)`, size, gravity: -0.01 }); } }
  function particleStep(dt){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.t+=dt; p.x+=p.vx*dt/16; p.y+=p.vy*dt/16; p.vy+=(p.gravity || 0.01)*dt/16; p.vx*=0.99; if(p.t>=p.life) particles.splice(i,1); } }

  // gore / blood splatter particles for zombie deaths - EXPLOSIVE BLOOD BURST
  function spawnGoreParticles(x,y,count=18){ 
    const bloodColors = ['#8b0000','#ff3b3b','#6b2b1b','#c72b2b','#990000','#ff0000','#660000','#cc0000']; 
    const fleshColors = ['#8b4a4a','#a05050','#704040'];
    const boneColors = ['#e8e0d0','#d8d0c0','#c8c0b0'];
    for(let i=0;i<count;i++){ 
      const ang = Math.random()*Math.PI*2; 
      const sp = 1.0 + Math.random()*3.5; 
      let color;
      const r = Math.random();
      if(r < 0.7) color = bloodColors[Math.floor(Math.random()*bloodColors.length)];
      else if(r < 0.9) color = fleshColors[Math.floor(Math.random()*fleshColors.length)];
      else color = boneColors[Math.floor(Math.random()*boneColors.length)];
      particles.push({ x, y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp - Math.random()*2, life: 800 + Math.random()*700, t:0, color, size: 3 + Math.random()*6, gravity: 0.08 }); 
    } 
  }

  function updateUI(){ 
    const sunElement = document.getElementById('sun');
    const hudElement = document.getElementById('hud');
    if(sunElement && typeof sun !== 'undefined') sunElement.textContent = String(sun); 
    if(hudElement && typeof plants !== 'undefined') {
      // Progress bar logic
      const remaining = Math.max(0, (typeof levelTarget !== 'undefined' ? levelTarget : 0) - (typeof levelKilled !== 'undefined' ? levelKilled : 0));
      const percent = levelTarget > 0 ? (remaining / levelTarget) : 0;
      const barWidth = Math.max(0, percent*320);
      const showFlag = currentLevel % 5 === 0;
      hudElement.innerHTML = `
        <div id="zombieProgressWrap" style="width:320px;height:32px;background:#2e3b2e;border-radius:16px;position:relative;overflow:hidden;margin:auto;box-shadow:0 2px 8px #0002;">
          <div id="zombieProgressBar" style="height:100%;background:#81c784;border-radius:16px 0 0 16px;position:absolute;left:0;top:0;width:${barWidth}px;transition:width 0.3s;"></div>
          <div id="zombieHead" style="position:absolute;top:0;width:32px;height:32px;left:${Math.max(0, barWidth-16)}px;transition:left 0.3s;z-index:2;">
            <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><ellipse cx='16' cy='16' rx='14' ry='14' fill='%238b2020'/><ellipse cx='16' cy='16' rx='12' ry='12' fill='%23cfd8dc'/><ellipse cx='16' cy='20' rx='8' ry='6' fill='%23fff'/><ellipse cx='12' cy='14' rx='3' ry='4' fill='%230a0a0a'/><ellipse cx='20' cy='14' rx='3' ry='4' fill='%230a0a0a'/><ellipse cx='12' cy='14' rx='1.5' ry='2' fill='%238b2020'/><ellipse cx='20' cy='14' rx='1.5' ry='2' fill='%238b2020'/><ellipse cx='16' cy='24' rx='5' ry='2' fill='%238b2020'/></svg>" style="width:32px;height:32px;" />
          </div>
          ${showFlag ? `<div id='flagIcon' style='position:absolute;left:0;top:4px;width:22px;height:22px;z-index:3;'><img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 22 22'><rect x='2' y='8' width='3' height='10' fill='%238b2020'/><polygon points='5,8 18,11 5,14' fill='%23ff1744' stroke='%238b2020' stroke-width='1'/></svg>" style="width:22px;height:22px;" /></div>` : ''}
        </div>
      `;
    }
    if(typeof updateSeedUI === 'function') updateSeedUI(); 
  }
  

  // planting
  document.getElementById('gameWrap').addEventListener('click', (e)=>{});
  canvas.addEventListener('click', (e)=>{
    const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
    // Sun pickup (day only) - allow picking up while game is running
    if(running && !isNightLevel()){
      for(let si = fallingSuns.length - 1; si >= 0; si--){
        const s = fallingSuns[si];
        const dx = x - s.x, dy = y - s.y;
        // larger clickable area: at least 28px radius or s.r + 12
        const hitR = Math.max(28, (s.r || 18) + 12);
        if(Math.hypot(dx,dy) < hitR){
          sun += 25;
          fallingSuns.splice(si, 1);
          spawnPlantParticles(s.x, s.y, '#fff59d', 12);
          try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(720,'sine',0.06,0.08); }catch(e){}
          updateUI();
          return;
        }
      }
    }
    // If hammer mode active, remove plant at clicked cell (works even when paused)
    if(hammerMode){
      const colH = Math.floor(x / CW), rowH = Math.floor(y / CH);
      if(colH>=0 && colH<COLS && rowH>=0 && rowH<ROWS){
        // find plant occupying this tile
        const plant = plants.find(p=>p.row===rowH && p.col===colH);
        if(plant){
            if(plant.type === 'clover' && plant.topPlant){
            // remove topPlant stored on clover and clear any fog keys it created
            if(plant.topFogKeys && plant.topFogKeys.length){ for(const k of plant.topFogKeys){ try{ if(illuminated[k]){ illuminated[k] = Math.max(0, illuminated[k]-1); if(illuminated[k] <= 0) delete illuminated[k]; } }catch(e){} } try{ delete plant.topFogKeys; }catch(e){} }
            plant.topPlant = null; plant.topHp = 0; plant.topMaxHp = 0; plant.topFireAcc = 0; plant.topGatling = false; plant.topMagnet = false;
            spawnPlantParticles((colH+0.5)*CW, (rowH+0.5)*CH, '#ffab91', 12);
          } else {
            // remove the plant object
            removePlantObj(plant);
            spawnPlantParticles((colH+0.5)*CW, (rowH+0.5)*CH, '#ffab91', 12);
          }
          try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playThump(); }catch(e){}
          // turn off hammer mode after single use
          hammerMode = false; const hb = document.getElementById('hammerBtn'); if(hb) hb.style.background = ''; canvas.style.cursor = 'default';
          updateUI();
        }
      }
      return;
    }
    if(!selected || !running) return;
    const col = Math.floor(x / CW), row = Math.floor(y / CH);
    if(col<0||col>=COLS||row<0||row>=ROWS) return;
    // Prevent planting in the leftmost column (farm gate area)
    if(col === 0) return;
    
    // Check for existing plant at this location
    const existingPlant = plants.find(p=>p.row===row && p.col===col);
    const existingClover = plants.find(p=>p.row===row && p.col===col && p.type==='clover');
    const def = CARDS.find(c=>c.id===selected); if(!def) return; if(sun < def.cost) return;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â• CLOVER LOGIC FOR TOP 2 ROWS â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Top 2 rows (row 0 and 1) require clover first before any other plant
    if(row < 2){
      // If placing clover, allow it (clover can only be placed on top 2 rows)
      if(def.id === 'clover'){
        if(existingPlant) return; // Can't place clover on existing plant
        // Continue to place clover
      } else {
        // For other plants, need clover as platform first
        if(!existingClover){
          // No clover here, can't place other plants
          return;
        }
        // Has clover - check if already has a plant on top of clover
        if(existingClover.topPlant){
          return; // Already has a plant on clover
        }
        // Can place plant on top of clover - will be handled below
        // Skip the normal existingPlant check since we're placing ON clover
      }
    } else {
      // For rows 2-4, clover cannot be placed
      if(def.id === 'clover') return;
    }
    
    // Pumpkin special placement logic - can be placed on other plants or other plants on it
    // Skip this for top 2 rows when placing on clover
    if(existingPlant && def.id !== 'clover' && !(row < 2 && existingClover)){
      // If placing pumpkin on existing non-pumpkin plant
      if(def.id === 'pumpkin' && existingPlant.type !== 'pumpkin' && !existingPlant.hasPumpkin){
        sun -= def.cost;
        existingPlant.hasPumpkin = true;
        existingPlant.pumpkinHp = 150;
        existingPlant.pumpkinMaxHp = 150;
        spawnPlantParticles((col+0.5)*CW, (row+0.5)*CH, '#ff9800', 18);
        const st = cardState[def.id]; st.cooldownUntil = performance.now()+def.cooldown; st.mask.style.display='block'; st.el.classList.add('disabled');
        try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playPlace(); } catch(e){}
        selected = null; document.querySelectorAll('.seedCard').forEach(s=>s.classList.remove('selected'));
        updateUI();
        return;
      }
      // If placing non-pumpkin on existing pumpkin
      if(def.id !== 'pumpkin' && existingPlant.type === 'pumpkin' && !existingPlant.innerPlant){
        sun -= def.cost;
        // Create the inner plant properties on the pumpkin
        existingPlant.innerPlant = def.id;
        existingPlant.innerHp = getPlantMaxHp(def.id);
        existingPlant.innerMaxHp = existingPlant.innerHp;
        existingPlant.innerFireAcc = 0;
        if(def.id === 'gatling'){ existingPlant.innerGatling = true; existingPlant.innerGatlingRate = 420; }
        spawnPlantParticles((col+0.5)*CW, (row+0.5)*CH, '#7fffd4', 18);
        const st = cardState[def.id]; st.cooldownUntil = performance.now()+def.cooldown; st.mask.style.display='block'; st.el.classList.add('disabled');
        try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playPlace(); } catch(e){}
        selected = null; document.querySelectorAll('.seedCard').forEach(s=>s.classList.remove('selected'));
        updateUI();
        return;
      }
      // Otherwise can't place here
      return;
    }
    sun -= def.cost;
    // set hp and special fields per plant type
    let maxHp = 12;
    if(def.id === 'sunflower') maxHp = 15;
    else if(def.id === 'wallnut') maxHp = 140;
    else if(def.id === 'cherry') maxHp = 1;
    else if(def.id === 'sunshroom') maxHp = 10;
    else if(def.id === 'peashooter') maxHp = 15;
    else if(def.id === 'sunpea') maxHp = 15;
    else if(def.id === 'minibomb') maxHp = 30;
    else if(def.id === 'icepea') maxHp = 15;
    else if(def.id === 'tallnut') maxHp = 260;
    // removed mushrooms - no max HP entry needed
    else if(def.id === 'gatling') maxHp = 20;
    else if(def.id === 'pumpkin') maxHp = 150;
    else if(def.id === 'magnet') maxHp = 30;
    else if(def.id === 'spiker') maxHp = 10;
    else if(def.id === 'clover') maxHp = 20;
    
    // If placing on clover (top 2 rows), store as topPlant on clover instead
    if(row < 2 && existingClover && def.id !== 'clover'){
      existingClover.topPlant = def.id;
      existingClover.topHp = maxHp;
      existingClover.topMaxHp = maxHp;
      existingClover.topFireAcc = 0;
      if(def.id === 'gatling'){ existingClover.topGatling = true; existingClover.topGatlingRate = 420; }
      if(def.id === 'magnet'){ existingClover.topMagnet = true; }
      // top-mounted mushroom illumination for new shrooms
      if(def.id === 'lumenmush') existingClover.topFogKeys = illuminateFrom(row, col, 2);
      if(def.id === 'embermush') existingClover.topFogKeys = illuminateFrom(row, col, 2);
      spawnPlantParticles((col+0.5)*CW, (row+0.5)*CH, '#7fffd4', 18);
      const st = cardState[def.id]; st.cooldownUntil = performance.now()+def.cooldown; st.mask.style.display='block'; st.el.classList.add('disabled');
      try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playPlace(); } catch(e){}
      selected = null; document.querySelectorAll('.seedCard').forEach(s=>s.classList.remove('selected'));
      updateUI();
      return;
    }
    
    const p = { id:Date.now()+Math.random(), row, col, type:def.id, hp: maxHp, maxHp, fireAcc:0, spawnT:performance.now(), scale:0 };
      // Set planted scale for sunshroom and puffshroom
      if(def.id === 'sunshroom' || def.id === 'puffshroom') p.scale = 0.33;
    // type-specific flags
    if(def.id === 'gatling'){ p.gatling = true; p.gatlingRate = 420; }
    if(def.id === 'spiker'){ p.thorn = true; p.thornDamage = 8; p.thornInterval = 4500; p.thornAcc = 0; p.thornRadius = 2; p.thornStepDamage = 0.6; }
    if(def.id === 'tallnut' || def.id === 'pumpkin'){ p.tank = true; }
    if(def.id === 'magnet'){ p.magnet = true; }
    if(def.id === 'clover'){ p.clover = true; p.spinPhase = 0; } // Clover has spinning animation
    if(def.id === 'sunpea'){ p.sunpea = true; p.fireAcc = 0; }
    if(def.id === 'minibomb'){ 
      p.mines = []; 
      const n = 5 + Math.floor(Math.random()*3); // 5-7 mines
      for(let mi=0;mi<n;mi++) p.mines.push({ id:mi, dmg:5 });
      p.mineDamage = 5;
    }
    // Cherry Bomb: make invulnerable on placement and explode quickly (500ms)
    if(def.id === 'cherry'){
      p.explodeAt = performance.now() + 500; // explode after 0.5s
      p.immortal = true; // ignore incoming damage until explosion
    }
    if(def.id === 'cherry'){ // cherry: invulnerable immediately and fuse = 0.5s
      p.invulnerable = true;
      p.explodeAt = performance.now() + 500;
    }

    // ICE-SHROOM: freeze all zombies for 5 seconds
    if(def.id === 'iceshroom') {
      const freezeDuration = 5000; // ms
      const now = performance.now();
      zombies.forEach(z => {
        z.frozen = true;
        z.frozenUntil = now + freezeDuration;
      });
      // Optional: spawn freeze particles or play freeze sound here
      spawnPlantParticles((col+0.5)*CW, (row+0.5)*CH, '#90caf9', 24);
      try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(320,'triangle',0.18,0.18); }catch(e){}
    }

    plants.push(p);
    spawnPlantParticles((col+0.5)*CW, (row+0.5)*CH, def.id==='sunflower'?'#ffd166':'#7fffd4', 18);
    // start cooldown
    const st = cardState[def.id]; st.cooldownUntil = performance.now()+def.cooldown; st.mask.style.display='block'; st.el.classList.add('disabled');
      // play place SFX
      try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playPlace(); } catch(e){}
    selected = null; document.querySelectorAll('.seedCard').forEach(s=>s.classList.remove('selected'));
    updateUI();
  });
  canvas.addEventListener('mousemove', (e)=>{
    try{
      const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      if((selected || hammerMode) && (running || !running)){
        const c = Math.floor(x / CW), r = Math.floor(y / CH);
        if(c>=0 && c<COLS && r>=0 && r<ROWS){ hoverCol = c; hoverRow = r; return; }
      }
      hoverCol = -1; hoverRow = -1;
    }catch(e){ hoverCol = -1; hoverRow = -1; }
  });
  canvas.addEventListener('mouseleave', ()=>{ hoverCol = -1; hoverRow = -1; });

  function spawnZombie(){ if(levelSpawned >= levelTarget) return; const row = Math.floor(Math.random()*ROWS);
    // Base zombie HP: 20, increases by 2 every 2 levels
    const baseHp = 20 + Math.floor((currentLevel - 1) / 2) * 2;
    const elapsed = performance.now() - (gameStartTime || performance.now());
    
    // If this is a boss level (every 5th) and this is the last spawn for the level, make a boss
    let isBoss = false;
    if(currentLevel % 5 === 0 && levelSpawned === levelTarget - 1){
      isBoss = true;
    }
    
    // After 30 seconds, can spawn armored zombies (30% chance)
    const canSpawnArmored = elapsed >= 30000;
    const spawnArmored = canSpawnArmored && Math.random() < 0.3 && !isBoss;
    
    // After 45 seconds, can spawn bomb zombies (40% chance)
    const canSpawnBomb = elapsed >= 45000;
    const spawnBomb = canSpawnBomb && Math.random() < 0.4 && !isBoss && !spawnArmored;

    if(isBoss){
      // BOSS: Giant Zombie - HP = 3x normal zombie (scales with level)
      const bossHp = baseHp * 3;
      const bossSpeed = 0.004; // slow movement
      const bossAttack = 0.072; // strong attack (1.6x normal)
      const hasBrokenWings = row < 2; // Top 2 rows get broken angel wings
      zombies.push({ id:Date.now()+Math.random(), row, x: COLS + 1, hp:bossHp, maxHp:bossHp, speedBase: bossSpeed, attack: bossAttack, slowUntil:0, walkPhase: Math.random()*10, attacking:false, boss:true, cherryHits:0, brokenWings: hasBrokenWings });
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playBeep(220,'square',0.18,0.18); playZombieGroan(); }catch(e){}
    } else if(spawnBomb){
      // BOMB ZOMBIE: HP 33 + 1 per level, explodes at 50% HP and on death
      const bombHp = 33 + (currentLevel - 1);
      const bombSpeed = 0.005;
      const bombAttack = 0.04;
      const hasBrokenWings = row < 2;
      zombies.push({ id:Date.now()+Math.random(), row, x: COLS + 1, hp:bombHp, maxHp:bombHp, speedBase: bombSpeed, attack: bombAttack, slowUntil:0, walkPhase: Math.random()*10, attacking:false, bomb:true, hasExploded50:false, brokenWings: hasBrokenWings });
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playZombieGroan(); }catch(e){}
    } else if(spawnArmored){
      // ARMORED ZOMBIE: HP 35 + 1 per level, DPS 0.05, speed 0.004
      const armoredHp = 35 + (currentLevel - 1);
      const armoredSpeed = 0.004;
      const armoredAttack = 0.05;
      const hasBrokenWings = row < 2; // Top 2 rows get broken angel wings
      zombies.push({ id:Date.now()+Math.random(), row, x: COLS + 1, hp:armoredHp, maxHp:armoredHp, speedBase: armoredSpeed, attack: armoredAttack, slowUntil:0, walkPhase: Math.random()*10, attacking:false, armored:true, brokenWings: hasBrokenWings });
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playZombieGroan(); }catch(e){}
    } else {
      // NORMAL ZOMBIE: HP 16 + level scaling, fixed speed 0.006
      const normalSpeed = 0.006;
      const normalAttack = 0.045;
      const hasBrokenWings = row < 2; // Top 2 rows get broken angel wings
      zombies.push({ id:Date.now()+Math.random(), row, x: COLS + 1, hp:baseHp, maxHp:baseHp, speedBase: normalSpeed, attack: normalAttack, slowUntil:0, walkPhase: Math.random()*10, attacking:false, brokenWings: hasBrokenWings });
      try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playZombieGroan(); }catch(e){}
    }
    levelSpawned++; }

  // WebAudio simple SFX generator
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playBeep(freq=440, type='sine', time=0.05, gain=0.05){ try{ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value = gain; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + time); } catch(e){} }
  function playPlace(){ playBeep(520,'sine',0.06,0.08); }
  function playShoot(){ playBeep(860,'sawtooth',0.06,0.12); }
  // Soft pea hit sound - gentle thud instead of harsh beep
  function playPeaHit(){ try{ const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate); const data = buf.getChannelData(0); for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.pow(1 - i/data.length, 2) * 0.3; } const src = audioCtx.createBufferSource(); src.buffer = buf; const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 800; const g = audioCtx.createGain(); g.gain.value = 0.06; src.connect(lp); lp.connect(g); g.connect(audioCtx.destination); src.start(); setTimeout(()=>{ src.disconnect(); lp.disconnect(); g.disconnect(); }, 100); } catch(e){} }
  // Thump sound for hammer impact (short, low "bup/bup")
  function playThump(){ try{ const dur = 0.06; const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate); const data = buf.getChannelData(0); for(let i=0;i<data.length;i++){ const env = Math.pow(1 - i/data.length, 2); data[i] = (Math.random()*2-1) * env * 0.35; } const src = audioCtx.createBufferSource(); src.buffer = buf; const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 900; const g = audioCtx.createGain(); g.gain.value = 0.08; src.connect(lp); lp.connect(g); g.connect(audioCtx.destination); src.start(); setTimeout(()=>{ try{ src.disconnect(); lp.disconnect(); g.disconnect(); }catch(e){} }, (dur+0.02)*1000); } catch(e){} }
  function playDeath(){ playExplosion(); }

  // Explosion (white-noise burst) - reduced volume
  function playExplosion(){ try{ const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate); const data = buf.getChannelData(0); for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * (1 - i/data.length); } const src = audioCtx.createBufferSource(); src.buffer = buf; const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.01); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.28); src.connect(g); g.connect(audioCtx.destination); src.start(); setTimeout(()=>{ src.disconnect(); g.disconnect(); }, 350); } catch(e){} }

  // richer death SFX: pitch drop + noise - LOW VOLUME
  function playDeathSFX(){ try{
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); const f0 = 220 + Math.random()*80;
      o.type = 'sawtooth'; o.frequency.setValueAtTime(f0, now); o.frequency.exponentialRampToValueAtTime(40, now + 0.5);
      g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.03, now + 0.02); g.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
      const hp = audioCtx.createBiquadFilter(); hp.type='lowpass'; hp.frequency.setValueAtTime(1200, now); hp.frequency.exponentialRampToValueAtTime(200, now + 0.6);
      const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate); const data = noiseBuf.getChannelData(0); for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * (1 - i/data.length); }
      const nsrc = audioCtx.createBufferSource(); nsrc.buffer = noiseBuf; const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.02, now); ng.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      o.connect(hp); hp.connect(g); g.connect(audioCtx.destination); nsrc.connect(ng); ng.connect(audioCtx.destination); o.start(now); o.stop(now + 0.6); nsrc.start(now); nsrc.stop(now + 0.22);
    } catch(e){} }

  function playZombieGroan(){ try{ if(!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value = 40 + Math.random()*30; g.gain.value = 0.02 + Math.random()*0.02; const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 220 + Math.random()*160; o.connect(bp); bp.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ try{ o.stop(); o.disconnect(); bp.disconnect(); g.disconnect(); }catch(e){} }, 800 + Math.random()*700); }catch(e){} }

  // zombie moan: DISABLED - was causing static/buzzing noise
  function startZombieMoan(){ /* disabled */ }
  function stopZombieMoan(){ try{ if(zombieMoanOsc){ zombieMoanOsc.stop(); zombieMoanOsc.disconnect(); } if(zombieMoanGain){ zombieMoanGain.disconnect(); } zombieMoanOsc = null; zombieMoanGain = null; zombieMoanPlaying = false; }catch(e){} }

  // Mower rumble
  function playMower(){ try{ const o1 = audioCtx.createOscillator(); const o2 = audioCtx.createOscillator(); const g = audioCtx.createGain(); const f = 120; o1.type='sawtooth'; o2.type='sine'; o1.frequency.value = f; o2.frequency.value = f*1.4; g.gain.value = 0.08; const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 800; o1.connect(lp); o2.connect(lp); lp.connect(g); g.connect(audioCtx.destination); o1.start(); o2.start(); setTimeout(()=>{ o1.stop(); o2.stop(); o1.disconnect(); o2.disconnect(); lp.disconnect(); g.disconnect(); }, 220); } catch(e){} }
  
  // Airplane engine sound - higher pitch whirring
  function playAirplane(){ try{ const o1 = audioCtx.createOscillator(); const o2 = audioCtx.createOscillator(); const g = audioCtx.createGain(); o1.type='sawtooth'; o2.type='triangle'; o1.frequency.value = 280; o2.frequency.value = 420; g.gain.value = 0.06; const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 200; o1.connect(hp); o2.connect(hp); hp.connect(g); g.connect(audioCtx.destination); o1.start(); o2.start(); setTimeout(()=>{ o1.stop(); o2.stop(); o1.disconnect(); o2.disconnect(); hp.disconnect(); g.disconnect(); }, 180); } catch(e){} }
  
  // Mower hit zombie - crunchy impact
  function playMowerHit(){ try{ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); const noise = audioCtx.createOscillator(); o.type='square'; o.frequency.value = 80; noise.type='sawtooth'; noise.frequency.value = 150; g.gain.value = 0.12; const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 400; o.connect(lp); noise.connect(lp); lp.connect(g); g.connect(audioCtx.destination); o.start(); noise.start(); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15); setTimeout(()=>{ o.stop(); noise.stop(); o.disconnect(); noise.disconnect(); lp.disconnect(); g.disconnect(); }, 150); } catch(e){} }
  
  // Airplane hit zombie - slicing whoosh
  function playAirplaneHit(){ try{ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value = 600; g.gain.value = 0.08; const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 300; o.connect(hp); hp.connect(g); g.connect(audioCtx.destination); o.start(); o.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.12); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12); setTimeout(()=>{ o.stop(); o.disconnect(); hp.disconnect(); g.disconnect(); }, 120); } catch(e){} }

  // simple background music loop (uses playBeep)
  let musicSeq = [440,0,523,0,659,0,784,0]; let musicIndex = 0; let musicInterval = null;
  function startMusic(){ if(musicInterval) return; musicIndex = 0; musicInterval = setInterval(()=>{ const f = musicSeq[musicIndex % musicSeq.length]; if(f>0){ try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(f,'sine',0.12,0.04); }catch(e){} } musicIndex++; }, 300); }
  function stopMusic(){ if(musicInterval){ clearInterval(musicInterval); musicInterval = null; } }

  function rowHasZombieAhead(row, col){ return zombies.some(z=> z.row===row && z.x > col + 0.2); }

  function update(dt){ particleStep(dt); const now = performance.now();
    // audio: start/stop moan depending on zombies present
    if(zombies.length > 0){ startZombieMoan(); } else { stopZombieMoan(); }
    for(const p of plants){ p.scale = Math.min(1, (now - (p.spawnT||0))/300);
      
      // CLOVER - handle topPlant behavior
      if(p.type === 'clover' && p.topPlant){
        p.topFireAcc = (p.topFireAcc || 0) + dt;
        const topType = p.topPlant;
        
        if(topType === 'sunflower'){
          if(p.topFireAcc > 4000){ p.topFireAcc = 0; sun += 25; spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, '#ffd166', 6); }
        }
        else if(topType === 'sunshroom'){
          if(p.topFireAcc > 6000){ 
            p.topFireAcc = 0; 
            const plantAge = now - (p.spawnT || now);
            const sunAmount = plantAge >= 30000 ? 25 : 15;
            sun += sunAmount; 
            spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, plantAge >= 30000 ? '#ffd166' : '#fff3b0', 8); 
          }
        }
        else if(topType === 'peashooter'){
          if(p.topFireAcc > 900){ if(rowHasZombieAhead(p.row,p.col)){ p.topFireAcc = 0; p.topLastShoot = now; bullets.push({ row:p.row, x: (p.col+0.85), speed:0.45, dmg:3, trail:[], slow:false, yOffset: -0.35, type: 'cannonpall' }); p.topLastShoot = now; try{ spawnSmoke((p.col+0.85)*CW, (p.row+0.15)*CH, 6); }catch(e){} } }
        }
        else if(topType === 'icepea'){
          if(p.topFireAcc > 900){ if(rowHasZombieAhead(p.row,p.col)){ p.topFireAcc = 0; p.topLastShoot = now; bullets.push({ row:p.row, x: (p.col+0.85), speed:0.45, dmg:2, trail:[], slow:true, yOffset: -0.35 }); } }
        }
        // top-mounted mushroom behavior removed
        else if(topType === 'gatling'){
          if(p.topFireAcc > (p.topGatlingRate || 420)){ if(rowHasZombieAhead(p.row,p.col)){ p.topFireAcc = 0; p.topLastShoot = now; bullets.push({ row:p.row, x: (p.col+0.85), speed:0.65, dmg:4, trail:[], slow:false, yOffset: -0.35 }); bullets.push({ row:p.row, x: (p.col+0.85), speed:0.65, dmg:4, trail:[], slow:false, yOffset: -0.35 }); } }
        }
        else if(topType === 'puffshroom'){
          if(p.topFireAcc > 1200){
            const nearZ = zombies.find(z=>z.row===p.row && z.x > p.col && z.x < p.col + 4 && !z.dead);
            if(nearZ){ p.topFireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.6), speed:0.35, dmg:4, trail:[], slow:false, spore:true }); }
          }
        }
        else if(topType === 'scaredyshroom'){
          const closeZ = zombies.find(z=>z.row===p.row && Math.abs(z.x - p.col) < 2 && !z.dead);
          p.topHiding = !!closeZ;
          if(!p.topHiding && p.topFireAcc > 800){
            if(rowHasZombieAhead(p.row,p.col)){ p.topFireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.6), speed:0.45, dmg:4, trail:[], slow:false }); }
          }
        }
        else if(topType === 'fumeshroom'){
          if(p.topFireAcc > 1000){
            const nearZ = zombies.find(z=>z.row===p.row && z.x > p.col && z.x < p.col + 4 && !z.dead);
            if(nearZ){
              p.topFireAcc = 0;
              for(const z of zombies){
                if(z.row===p.row && z.x > p.col && z.x < p.col + 4 && !z.dead){
                  z.hp -= 6; spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#9c27b0', 3);
                }
              }
            }
          }
        }
        else if(topType === 'embermush'){
          if(p.topFireAcc > 4500){
            p.topFireAcc = 0;
            for(const z of zombies){
              if(!z.dead && Math.abs(z.row - p.row) <= 2 && z.x > p.col - 1 && z.x < p.col + 3){
                z.hp -= 12; spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#ff8a65', 6);
              }
            }
            // ring-of-fire visual for top-mounted embermush
            const tcx = (p.col+0.5)*CW, tcy = (p.row+0.5)*CH;
            const trCount = 16;
            for(let i=0;i<trCount;i++){
              const ang = (i/trCount)*Math.PI*2;
              const sp = 0.8 + Math.random()*0.6;
              particles.push({ x: tcx, y: tcy, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, life: 400 + Math.random()*200, t:0, color: '#ff8a65', size: 4 + Math.random()*3, gravity: 0 });
            }
            spawnPlantParticles(tcx, tcy, '#ff7043', 10);
            // Tile-based ember ring for top-mounted variant
            try{
              const radius = (NIGHT_PLANT_EFFECTS && NIGHT_PLANT_EFFECTS.embermush && NIGHT_PLANT_EFFECTS.embermush.radius) ? NIGHT_PLANT_EFFECTS.embermush.radius : 2;
              const tiles = [];
              for(let dr = -radius; dr <= radius; dr++){
                for(let dc = -radius; dc <= radius; dc++){
                  if(Math.hypot(dr, dc) <= radius){ const tr = p.row + dr, tc = p.col + dc; if(tr>=0 && tr<ROWS && tc>=0 && tc<COLS) tiles.push({r:tr,c:tc}); }
                }
              }
              areaEffects.push({ type:'emberRing', tiles: tiles, created: now, life:700, plantId: (p.id||('top-'+p.col+'-'+p.row)) });
            }catch(e){}
          }
        }
        else if(topType === 'lumenmush'){
          p.topGlowAcc = (p.topGlowAcc || 0) + dt;
          if(p.topGlowAcc > 8000){
            p.topGlowAcc = 0;
            for(const q of plants){
              if(!q.dead && Math.abs(q.row - p.row) <= 2 && Math.abs(q.col - p.col) <= 2 && q.hp < (q.maxHp||12)){
                q.hp = Math.min(q.maxHp || 12, q.hp + (NIGHT_PLANT_EFFECTS.lumenmush.healAmount || 4));
                spawnPlantParticles((q.col+0.5)*CW, (q.row+0.5)*CH, '#b3e5fc', 8);
                // mark heal pulse and spawn gentle heal particles
                try{ q._healPulse = performance.now(); }catch(e){}
                const hx = (q.col+0.5)*CW, hy = (q.row+0.5)*CH;
                for(let i=0;i<10;i++){ const a = Math.random()*Math.PI*2; const s = 0.2 + Math.random()*0.6; particles.push({ x: hx, y: hy, vx: Math.cos(a)*s, vy: Math.sin(a)*s - 0.2, life: 600 + Math.random()*200, t:0, color:'#b3e5fc', size:4 + Math.random()*3, gravity: -0.02 }); }
              }
            }
          }
        }
      }
      
      if(p.type==='sunflower'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 4000){ p.fireAcc = 0; sun += 25; spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, '#ffd166', 6); } }
      else if(p.type==='peashooter'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 900){ if(rowHasZombieAhead(p.row,p.col)){ p.fireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.85), speed:0.45, dmg:3, trail:[], slow:false, type:'cannonpall' }); p.lastShoot = now; try{ spawnSmoke((p.col+0.85)*CW, (p.row+0.5)*CH, 6); }catch(e){} } } }
      else if(p.type==='sunpea'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 900){ if(rowHasZombieAhead(p.row,p.col)){ p.fireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.85), speed:0.45, dmg:3, trail:[], slow:false, type:'sunshot' }); p.lastShoot = now; } } }
      else if(p.type==='gatling'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > (p.gatlingRate || 500)){ if(rowHasZombieAhead(p.row,p.col)){ p.fireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.85), speed:0.65, dmg:4, trail:[], slow:false }); bullets.push({ row:p.row, x: (p.col+0.85), speed:0.65, dmg:4, trail:[], slow:false }); p.lastShoot = now; try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playShoot(); }catch(e){} } } }
      else if(p.type==='icepea'){ p.fireAcc = (p.fireAcc||0) + dt; if(p.fireAcc > 900){ if(rowHasZombieAhead(p.row,p.col)){ p.fireAcc = 0; bullets.push({ row:p.row, x: (p.col+0.85), speed:0.45, dmg:2, trail:[], slow:true }); p.lastShoot = now; } } }
      else if(p.type==='cherry'){
        if(!p.explodeAt) p.explodeAt = now + 500;
        if(now >= p.explodeAt && !p.exploded){ // explode once
          p.exploded = true;
          p.immortal = false; // after explosion it can be damaged normally
          // Hiá»‡u á»©ng vá»¥ ná»• lá»›n hÆ¡n
          spawnPlantParticles((p.col+0.5)*CW,(p.row+0.5)*CH,'#ff7b7b',80); // tÄƒng sá»‘ lÆ°á»£ng háº¡t ná»•
          // ThÃªm khÃ³i lá»›n khi ná»•
          spawnSmoke((p.col+0.5)*CW,(p.row+0.5)*CH, 24); // nhiá»u khÃ³i hÆ¡n bÃ¬nh thÆ°á»ng
          // damage zombies in a 3x3 tile area centered on the cherry (rows & cols within Â±1)
          for(let zi=zombies.length-1; zi>=0; zi--){
            const z = zombies[zi];
            const zcol = Math.floor(z.x);
            if(Math.abs(z.row - p.row) <= 1 && Math.abs(zcol - p.col) <= 1){
              // Boss requires 2 cherry bomb hits to die
              if(z.boss){
                z.cherryHits = (z.cherryHits || 0) + 1;
                if(z.cherryHits >= 2){
                  z.hp -= 9999; // kill boss after 2nd hit
                } else {
                  z.hp -= z.maxHp * 0.4; // first hit does 40% damage
                  spawnPlantParticles((z.x)*CW, (z.row+0.5)*CH, '#ffeb3b', 20); // visual feedback
                }
              } else {
                z.hp -= 9999; // ensure death for non-boss
              }
            }
          }
          try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playDeath(); } catch(e){}
          // remove the cherry plant after a short delay so particles/sfx can play
          setTimeout(()=>{ removePlantObj(p); }, 60);
        }
      }
      else if(p.type==='sunshroom'){ 
        p.fireAcc = (p.fireAcc||0) + dt; 
        if(p.fireAcc > 6000){ 
          p.fireAcc = 0; 
          // After 30 seconds since planting, produce +25 sun instead of +15
          const plantAge = now - (p.spawnT || now);
          const sunAmount = plantAge >= 30000 ? 25 : 15;
          sun += sunAmount; 
          spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, plantAge >= 30000 ? '#ffd166' : '#fff3b0', 8); 
        } 
      }
      // SQUASH (BÃ ÄAO) - jumps and squashes ALL zombies within +1 tile range
      // Only activates when zombie is within +-1 tile of squash position
      else if(p.type==='squash'){ 
        if(!p.jumping && !p.jumped){
          // Find zombie within +-1 tile range (col and row)
          let targetZ = null;
          let minDist = Infinity;
          for(const z of zombies){
            // Only target zombies within +-1 tile horizontally and same row or adjacent row
            if(!z.dead && Math.abs(z.x - p.col) <= 2 && Math.abs(z.row - p.row) <= 1){
              const dist = Math.abs(z.x - p.col) + Math.abs(z.row - p.row)*0.5;
              if(dist < minDist){
                minDist = dist;
                targetZ = z;
              }
            }
          }
          if(targetZ){
            p.jumping = true;
            p.targetZ = targetZ;
            p.targetCol = Math.floor(targetZ.x); // landing position
            p.jumpPhase = 0;
            p.startCol = p.col;
            p.startRow = p.row;
          }
        }
        if(p.jumping){
          p.jumpPhase += dt * 0.003;
          if(p.jumpPhase >= 1){
            // Land and deal damage to ALL zombies in landing zone (+1 tile from right)
            const landCol = p.targetCol || Math.floor(p.targetZ.x);
            const landRow = p.targetZ.row;
            let hitCount = 0;
            for(const z of zombies){
              // Hit zombies in the landing column range and within one row vertically
              if(!z.dead && Math.abs(z.row - landRow) <= 1 && z.x >= landCol - 0.5 && z.x <= landCol + 1.5){
                // Damage scales with zombie's max HP (more damage to armored)
                const baseDmg = 20;
                const bonusDmg = (z.maxHp || 14) * 0.5; // 50% of zombie's max HP as bonus
                const totalDmg = baseDmg + bonusDmg;
                z.hp -= totalDmg;
                spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#a5d6a7', 15);
                spawnGoreParticles(z.x*CW, (z.row+0.5)*CH, 10);
                hitCount++;
              }
            }
            if(hitCount > 0){
              try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(200,'square',0.15,0.15); }catch(e){}
            }
            p.jumped = true;
            p.jumping = false;
            // Remove squash after landing
            setTimeout(()=>{ removePlantObj(p); }, 300);
          }
        }
      }
      // PUFF-SHROOM - free small mushroom that shoots weak short-range spores
      else if(p.type==='puffshroom'){ 
        p.fireAcc = (p.fireAcc||0) + dt; 
        if(p.fireAcc > 1200){ 
          // only shoot if zombie is within 3 tiles
          const nearZ = zombies.find(z=> z.row===p.row && z.x > p.col && z.x < p.col + 4);
          if(nearZ){ 
            p.fireAcc = 0; 
            bullets.push({ row:p.row, x: (p.col+0.5), speed:0.35, dmg:8, trail:[], slow:false, maxDist: p.col + 3.5 }); // dmg x2
            p.lastShoot = now; 
          } 
        } 
      }
      // THORNROOT (replaces Spikeweed) - periodic thorn burst that damages and nudges zombies
      else if(p.type === 'thornroot'){
        p.thornAcc = (p.thornAcc || 0) + dt;
        if(p.thornAcc > (p.thornInterval || 4500)){
          p.thornAcc = 0;
          const cx = (p.col+0.5)*CW, cy = (p.row+0.5)*CH;
          for(const z of zombies){
            if(!z.dead && Math.abs(z.row - p.row) <= (p.thornRadius || 2) && z.x > p.col - (p.thornRadius || 2) && z.x < p.col + (p.thornRadius || 2) + 1){
              // immediate thorn damage
              z.hp -= (p.thornDamage || 8);
              // small knockback leftwards (respect tile left boundary)
              z.x = Math.max(z.x - 0.35, p.col + 0.2);
              spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#a52a2a', 8);
              // spawn visual spike projectile from thornroot toward the damaged zombie
              try{
                const dx = (z.x * CW) - cx; const dy = ((z.row + 0.5) * CH) - cy;
                const dist = Math.max(8, Math.hypot(dx,dy));
                const speed = 2.2 + Math.random() * 0.8;
                particles.push({ x: cx, y: cy, vx: dx/dist * speed, vy: dy/dist * speed, life: 500 + Math.random()*300, t:0, color:'#8b0000', size:3 + Math.random()*3, gravity:0, spike:true });
              }catch(e){}
              // Apply bleeding stack: 2% max HP per second, stacks up to 3, duration 6000ms
              try{
                const nowLocal = performance.now();
                z.bleedStacks = Math.min(3, (z.bleedStacks || 0) + 1);
                z.bleedExpire = nowLocal + 6000;
                z.bleedTickAcc = z.bleedTickAcc || 0;
                z.bleedTintUntil = nowLocal + 800;
                // bleed visual spurts
                for(let bi=0; bi<6; bi++) particles.push({ x: z.x*CW + (Math.random()-0.5)*20, y: (z.row+0.5)*CH + (Math.random()-0.5)*12, vx: (Math.random()-0.5)*0.6, vy: -0.2 - Math.random()*0.6, life: 600 + Math.random()*200, t:0, color:'#c62828', size:2 + Math.random()*3, gravity:0.05 });
              }catch(e){}
            }
          }
          // visual thorn burst
          const ringN = 18;
          for(let i=0;i<ringN;i++){ const a=(i/ringN)*Math.PI*2; const s=1.0+Math.random()*0.8; particles.push({ x:cx, y:cy, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:420+Math.random()*260, t:0, color:'#8b0000', size:3+Math.random()*4, gravity:0 }); }
          spawnPlantParticles(cx, cy, '#ff7043', 12);
          try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(320,'square',0.08,0.02); }catch(e){}
        }
      }
      // EMBER-SHROOM - periodic area fire pulse (short cooldown)
      else if(p.type === 'embermush'){
        p.fireAcc = (p.fireAcc||0) + dt;
        if(p.fireAcc > 4500){
          p.fireAcc = 0;
          // damage area
          for(const z of zombies){
            if(!z.dead && Math.abs(z.row - p.row) <= 2 && z.x > p.col - 1 && z.x < p.col + 3){
              z.hp -= 12;
              spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#ff8a65', 6);
            }
          }
          // visual ring-of-fire effect: spawn outward-moving ring particles
          const cx = (p.col+0.5)*CW, cy = (p.row+0.5)*CH;
          const ringCount = 20;
          for(let i=0;i<ringCount;i++){
            const ang = (i/ringCount) * Math.PI * 2;
            const speed = 0.9 + Math.random()*0.6;
            // particles pushed outward in a ring with short life
            particles.push({ x: cx, y: cy, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, life: 400 + Math.random()*200, t:0, color: '#ff8a65', size: 4 + Math.random()*3, gravity: 0 });
          }
          // small scorch sparks
          spawnPlantParticles(cx, cy, '#ff7043', 12);
          // Tile-based ember ring effect to highlight affected tiles
          try{
            const radius = (NIGHT_PLANT_EFFECTS && NIGHT_PLANT_EFFECTS.embermush && NIGHT_PLANT_EFFECTS.embermush.radius) ? NIGHT_PLANT_EFFECTS.embermush.radius : 2;
            const tiles = [];
            for(let dr = -radius; dr <= radius; dr++){
              for(let dc = -radius; dc <= radius; dc++){
                if(Math.hypot(dr, dc) <= radius){
                  const tr = p.row + dr, tc = p.col + dc;
                  if(tr >= 0 && tr < ROWS && tc >= 0 && tc < COLS) tiles.push({r:tr, c:tc});
                }
              }
            }
            areaEffects.push({ type: 'emberRing', tiles: tiles, created: now, life: 700, plantId: p.id });
          }catch(e){}
        }
      }
      // LUMEN-SHROOM - passive illumination + occasional small heal to nearby plants
      else if(p.type === 'lumenmush'){
        p.glowAcc = (p.glowAcc||0) + dt;
        // small periodic light particle
        if(Math.random() < 0.01) spawnPlantParticles((p.col+0.5)*CW + (Math.random()-0.5)*20, (p.row+0.5)*CH + (Math.random()-0.5)*10, '#b3e5fc', 2);
        if(p.glowAcc > 8000){
          p.glowAcc = 0;
          for(const q of plants){
            if(!q.dead && Math.abs(q.row - p.row) <= 2 && Math.abs(q.col - p.col) <= 2 && q.hp < (q.maxHp||12)){
              q.hp = Math.min(q.maxHp || 12, q.hp + (NIGHT_PLANT_EFFECTS.lumenmush.healAmount || 4));
              spawnPlantParticles((q.col+0.5)*CW, (q.row+0.5)*CH, '#b3e5fc', 8);
              // mark heal pulse and spawn gentle heal particles
              try{ q._healPulse = performance.now(); }catch(e){}
              const hx = (q.col+0.5)*CW, hy = (q.row+0.5)*CH;
              for(let i=0;i<10;i++){ const a = Math.random()*Math.PI*2; const s = 0.2 + Math.random()*0.6; particles.push({ x: hx, y: hy, vx: Math.cos(a)*s, vy: Math.sin(a)*s - 0.2, life: 600 + Math.random()*200, t:0, color:'#b3e5fc', size:4 + Math.random()*3, gravity: -0.02 }); }
            }
          }
        }
      }
      // SCAREDY-SHROOM - long range but hides when zombies close
      else if(p.type==='scaredyshroom'){ 
        const nearbyZ = zombies.find(z=> z.row===p.row && z.x > p.col && z.x < p.col + 2);
        p.hiding = !!nearbyZ;
        if(!p.hiding){
          p.fireAcc = (p.fireAcc||0) + dt; 
          if(p.fireAcc > 1000){ 
            if(rowHasZombieAhead(p.row,p.col)){ 
              p.fireAcc = 0; 
              bullets.push({ row:p.row, x: (p.col+0.5), speed:0.5, dmg:8, trail:[], slow:false }); // dmg x2
              p.lastShoot = now; 
            } 
          } 
        }
      }
      // FUME-SHROOM - shoots fumes that hit all zombies in range (pierce)
      else if(p.type==='fumeshroom'){ 
        p.fireAcc = (p.fireAcc||0) + dt;
        if(p.fireAcc > 1200){
          if(rowHasZombieAhead(p.row,p.col)){
            p.fireAcc = 0;
            // damage all zombies in the row ahead
            for(const z of zombies){
              if(z.row === p.row && z.x > p.col){
                z.hp -= 6;
                spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#9575cd', 5);
              }
            }
            // Bubble effect removed
            p.lastShoot = now;
          }
        }
      }
      // removed mushroom handling
      // HYPNO-SHROOM - when eaten, hypnotizes the zombie (turns it against others)
      else if(p.type==='hypnoshroom'){ 
        // Mark this plant as hypno - zombie eating it will be hypnotized
        p.hypno = true;
        p.onHypnotize = function(zombie){
          if(zombie && !zombie.hypnotized){
            zombie.hp *= 2;
            zombie.maxHp = zombie.hp;
          }
        };
      }
      // STRAW-SHROOM (Náº¤M RÆ M) - throws spores that arc high and land on zombies
      else if(p.type==='strawshroom'){ 
        p.fireAcc = (p.fireAcc||0) + dt;
        if(p.fireAcc > 1800){
          // Find any zombie ahead
          const targetZ = zombies.find(z=> z.row===p.row && z.x > p.col && !z.dead);
          if(targetZ){
            p.fireAcc = 0;
            // Create arcing spore projectile
            const spore = {
              startX: (p.col+0.5)*CW,
              startY: (p.row+0.5)*CH,
              targetX: targetZ.x*CW,
              targetY: (targetZ.row+0.5)*CH,
              targetZ: targetZ,
              row: p.row,
              phase: 0, // 0 to 1
              dmg: 4
            };
            if(!window.spores) window.spores = [];
            window.spores.push(spore);
            p.lastShoot = now;
            spawnPlantParticles((p.col+0.5)*CW, (p.row+0.3)*CH, '#ffb74d', 5);
          }
        }
      }
      // ICE-SHROOM - freezes all zombies on screen for 5 seconds (one-time use)
      else if(p.type==='iceshroom'){ 
        if(!p.exploded){
          p.exploded = true;
          // freeze all zombies
          for(const z of zombies){
            z.slowUntil = performance.now() + 5000;
            spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#90caf9', 8);
          }
          spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, '#e3f2fd', 30);
          try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(1200,'sine',0.15,0.1); }catch(e){}
          setTimeout(()=>{ removePlantObj(p); }, 200);
        }
      }
      // DOOM-SHROOM - huge explosion that kills all zombies in 3x3 area (one-time use)
      else if(p.type==='doomshroom'){ 
        if(!p.explodeAt) p.explodeAt = now + 500;
        if(now >= p.explodeAt && !p.exploded){
          p.exploded = true;
          spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, '#424242', 60);
          spawnGoreParticles((p.col+0.5)*CW, (p.row+0.5)*CH, 40);
          // kill all zombies in Â±1 row and Â±2 columns
          for(let zi=zombies.length-1; zi>=0; zi--){
            const z = zombies[zi];
            const zcol = Math.floor(z.x);
            if(Math.abs(z.row - p.row) <= 1 && Math.abs(zcol - p.col) <= 2){
              z.hp -= 9999;
            }
          }
          try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playExplosion(); playBeep(80,'sawtooth',0.3,0.2); }catch(e){}
          setTimeout(()=>{ removePlantObj(p); }, 100);
        }
      }
      // GLOOM-SHROOM - shoots in all directions (hits zombies in adjacent rows too)
      else if(p.type==='gloomshroom'){ 
        p.fireAcc = (p.fireAcc||0) + dt; 
        if(p.fireAcc > 1400){ 
          p.fireAcc = 0;
          // damage zombies in current row and adjacent rows within 2 tiles
          for(const z of zombies){
            if(Math.abs(z.row - p.row) <= 1 && Math.abs(z.x - p.col) < 2){
              z.hp -= 8;
              spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#7e57c2', 4);
            }
          }
          spawnPlantParticles((p.col+0.5)*CW, (p.row+0.5)*CH, '#9575cd', 8); 
          p.lastShoot = now; 
        } 
      }
    }

    // trigger lawnmower when zombie reaches leftmost cell (only living zombies)
    for(const z of zombies){ if(!z.dead && Math.floor(z.x) <= 0){ const mower = lawnmowers.find(m=>m.row===z.row && m.active && !m.moving); if(mower){ mower.moving = true; mower.active = false; mower.x = 0; try{ if(audioCtx.state==='suspended') audioCtx.resume(); if(mower.row < 2) playAirplane(); else playMower(); }catch(e){} } } }

    for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; b.x += b.speed * dt/16; b.trail.push({x:b.x,y:b.row,t:0}); if(b.trail.length>6) b.trail.shift(); if(b.x > COLS+1 || (b.maxDist && b.x > b.maxDist)) bullets.splice(i,1); else { for(let j=0;j<zombies.length;j++){ const z = zombies[j]; if(z.row===b.row && Math.abs(z.x - b.x) < 0.5){ z.hp -= b.dmg; if(b.slow){ const tintUntil = performance.now() + 2000; z.slowUntil = Math.max(z.slowUntil || 0, tintUntil); z.slowTintUntil = Math.max(z.slowTintUntil || 0, tintUntil); }
            // Visuals/sfx per projectile type
            if(b.type === 'cannonpall'){
              spawnPlantParticles((b.x)*CW, (b.row+0.5)*CH, '#ff7043', 30);
              spawnGoreParticles((b.x)*CW, (b.row+0.5)*CH, 12);
              try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playExplosion(); }catch(e){}
            } else if(b.type === 'sunshot'){
              // Sunshot: bright red sun projectile that explodes on contact
              spawnPlantParticles((b.x)*CW, (b.row+0.5)*CH, '#ff5252', 28);
              spawnGoreParticles((b.x)*CW, (b.row+0.5)*CH, 8);
              try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playExplosion(); }catch(e){}
              // If this hit killed the zombie, 50% chance to drop a +25 sun
              if(z.hp <= 0){ if(Math.random() < 0.5){ const fx = b.x*CW; const fy = (b.row+0.5)*CH; fallingSuns.push({ id:Date.now()+Math.random(), x: fx, y: fy, vy:0, r:22, seed: Math.random()*1000, targetY: fy, restUntil: performance.now() + 5000 }); } }
            } else {
              spawnPlantParticles((b.x)*CW, (b.row+0.5)*CH, '#fff', 10);
              try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playPeaHit(); } catch(e){}
            }
            bullets.splice(i,1);
            break; } } } }

    // STRAW-SHROOM SPORES - arcing projectiles
    if(window.spores){
      for(let i=window.spores.length-1; i>=0; i--){
        const s = window.spores[i];
        s.phase += dt * 0.002; // speed of arc
        if(s.phase >= 1){
          // Land and deal damage
          if(s.targetZ && !s.targetZ.dead){
            s.targetZ.hp -= s.dmg;
            spawnPlantParticles(s.targetX, s.targetY, '#ffb74d', 8);
            // Area damage: half dmg to zombies within Â±1 row and Â±1 col of target
            const targetCol = Math.floor(s.targetZ.x);
            const targetRow = s.targetZ.row;
            for(const z of zombies){
              if(z !== s.targetZ && !z.dead && Math.abs(z.row - targetRow) <= 1 && Math.abs(Math.floor(z.x) - targetCol) <= 1){
                z.hp -= Math.floor(s.dmg/2);
                spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#ffb74d', 4);
              }
            }
          }
          window.spores.splice(i, 1);
        }
      }
    }

    // expire areaEffects (tile overlays like ember rings)
    if(areaEffects && areaEffects.length){
      for(let ai = areaEffects.length-1; ai>=0; ai--){
        const af = areaEffects[ai]; if(now - (af.created||0) > (af.life||600)) areaEffects.splice(ai,1);
      }
    }

    for(let i=zombies.length-1;i>=0;i--){ const z = zombies[i]; const now2 = performance.now(); const prevHp = z.hp; const speedFactor = (z.slowUntil && z.slowUntil > now2) ? 0.5 : 1;
      
      // HYPNOTIZED ZOMBIE: attacks other zombies instead of moving left
      if(z.hypnotized){
        // If there are non-hypnotized zombies in the same row, all attack the hypnotized zombie
        let attackers = zombies.filter(oz => oz !== z && !oz.hypnotized && oz.row === z.row && !oz.dead && Math.abs(oz.x - z.x) < 0.8);
        if(attackers.length > 0){
          for(const oz of attackers){
            // All attackers stop and attack the hypnotized zombie
            z.hp -= (oz.attack || 0.045) * dt/16;
            oz.hp -= (z.attack || 0.045) * dt/16;
            if(Math.random() < 0.05) spawnPlantParticles(oz.x*CW, (oz.row+0.5)*CH, '#e91e63', 3);
            if(Math.random() < 0.05) spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#e91e63', 3);
          }
        } else {
          z.x += Math.abs(z.speedBase || 0.006) * speedFactor * ZOMBIE_SPEED_SCALE * gameSpeedMultiplier * dt/16; // move right
        }
        // remove if off screen right
        if(z.x > COLS + 2){ zombies.splice(i,1); levelKilled++; continue; }
      } else {
        // only move if not currently attacking a plant
        if(!z.attacking){ z.x -= (z.speedBase || z.speed) * speedFactor * ZOMBIE_SPEED_SCALE * gameSpeedMultiplier * dt/16; }
      }
      
      if(!z.hypnotized && Math.floor(z.x) <= 0){ // zombie reached left edge â€” check mower
        const mowerAvail = lawnmowers.find(m=>m.row===z.row && (m.moving || m.active));
        if(!mowerAvail || (!mowerAvail.moving && !mowerAvail.active)){ 
          running = false; 
          showGameOver();
          return; 
        }
        if(mowerAvail && mowerAvail.moving){ /* mower will handle kill */ }
      }
      const col = Math.floor(z.x);
      // Apply magnet DPS while magnet slow is active (1.5 damage per second)
      if(z.magnetSlowUntil && z.magnetSlowUntil > now2){
        z.hp -= 1.5 * dt / 1000; // 1.5 HP per second scaled by dt
        if(Math.random() < 0.12) spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#b2ebf2', 2);
      }
      // Bleeding (from Thornroot stacks) - deals % maxHp per second per stack
      if(z.bleedStacks && z.bleedStacks > 0){
        // expire stacks when time's up
        if(z.bleedExpire && now2 > z.bleedExpire){ z.bleedStacks = 0; z.bleedTickAcc = 0; }
        else {
          z.bleedTickAcc = (z.bleedTickAcc || 0) + dt;
          const tickInterval = 1000; // per-second tick
          while(z.bleedTickAcc >= tickInterval){
            z.bleedTickAcc -= tickInterval;
            const dmg = (0.02 * (z.maxHp || 20)) * (z.bleedStacks || 1); // 2% max HP per stack per second
            z.hp -= dmg;
            spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#ff5252', 6);
            try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); playBeep(420,'sine',0.04,0.02); }catch(e){}
          }
        }
        // subtle red tint flash while bleeding
        if(z.bleedExpire && z.bleedExpire > now2){ z.bleedTintUntil = Math.max(z.bleedTintUntil||0, now2 + 200); }
      }
      // magnets slow nearby zombies
        // Magnets (including top-mounted on clover) slow zombies in a 3x3 tile area and apply a short slow tint + magnet DPS
        for(const mp of plants){
          const isMag = mp.magnet || mp.topMagnet;
          if(!isMag) continue;
          const centerRow = mp.row;
          const centerCol = mp.col;
          // 3x3 tile area centered on magnet: rows +/-1 and cols +/-1
          if(Math.abs(z.row - centerRow) <= 1 && Math.abs(Math.floor(z.x) - centerCol) <= 1){
            const until = performance.now() + 1200;
            z.slowUntil = Math.max(z.slowUntil || 0, until);
            z.magnetSlowUntil = Math.max(z.magnetSlowUntil || 0, until);
            z.slowTintUntil = Math.max(z.slowTintUntil || 0, until);
          }
        }
      
      // Check for spiker damage SEPARATELY (spiker always damages zombies walking over it or standing nearby)
      // Check both current tile and adjacent tile (zombie might be pushed to col+0.6 by wallnut)
      const spikerPlant = plants.find(p=>p.row===z.row && p.type==='spiker' && Math.abs(p.col - z.x) < 1.0);
      if(spikerPlant && !z.hypnotized && !z.dead){
        const spikeD = (spikerPlant.thornStepDamage || 0.6) * dt/16;
        z.hp -= spikeD;
        if(Math.random() < 0.08) spawnPlantParticles((z.x)*CW, (z.row+0.5)*CH, '#ffb3b3', 4);
      }
      
      // Find blocking plant (non-spiker)
      const plant = plants.find(p=>p.row===z.row && p.col===col && p.type!=='spiker');
      if(plant && !z.hypnotized && !z.dead){
          // zombie is attacking this plant; apply this zombie's attack DPS
          const dmg = (z.attack || 0.045) * dt/16;
          // respect immortal flag (e.g., cherry bomb placed) â€” do not reduce hp while immortal
          if(plant.type === 'minibomb'){
            // Mines trigger when zombie steps on the patch: consume mines until zombie dies or mines exhausted
            if(plant.mines && plant.mines.length){
              while(plant.mines.length > 0 && z.hp > 0){
                plant.mines.pop();
                z.hp -= (plant.mineDamage || 5);
                spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#ff8a65', 6);
                spawnGoreParticles(z.x*CW, (z.row+0.5)*CH, 4);
                try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playExplosion(); }catch(e){}
                // if zombie still alive, it continues (mines consumed)
              }
              // if no mines left, remove the minibomb plant
              if(plant.mines.length === 0){ removePlantObj(plant); }
            } else {
              // fallback: normal hp damage if somehow no mines
              if(!plant.immortal){ plant.hp -= dmg; }
            }
          } else {
            if(!plant.immortal){
              // If this is a clover with a top-mounted plant, damage the topPlant first
              if(plant.type === 'clover' && plant.topPlant){
                plant.topHp -= dmg;
                // generic removal when HP depleted for top-mounted plant
                if(plant.topHp <= 0){
                  if(plant.topFogKeys && plant.topFogKeys.length){ for(const k of plant.topFogKeys){ try{ if(illuminated[k]){ illuminated[k] = Math.max(0, illuminated[k]-1); if(illuminated[k] <= 0) delete illuminated[k]; } }catch(e){} } try{ delete plant.topFogKeys; }catch(e){} }
                  spawnPlantParticles((plant.col+0.5)*CW, (plant.row+0.5)*CH, '#ffab91', 16);
                  plant.topPlant = null; plant.topHp = 0; plant.topMaxHp = 0; plant.topFireAcc = 0; plant.topGatling = false; plant.topMagnet = false;
                }
              } else {
                plant.hp -= dmg;
              }
            }
          }
            // ground-mounted mushroom behavior removed

            z.attacking = true;
          // prevent zombie from moving into the plant's tile
          z.x = Math.max(z.x, plant.col + 0.6);
          if(plant.hp<=0){
            // HYPNO-SHROOM: when eaten, hypnotize this zombie
            if(plant.hypno && !z.hypnotized){
              z.hypnotized = true;
              z.speedBase = -Math.abs(z.speedBase || 0.006); // walk backwards
              if(plant.onHypnotize) plant.onHypnotize(z);
              spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#e91e63', 15);
              try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playBeep(600,'sine',0.2,0.1); }catch(e){}
            }
            removePlantObj(plant);
          }
      } else { z.attacking = false; }
      // advance walkPhase for animation
      z.walkPhase = (z.walkPhase || 0) + dt*0.02;
      
      // BOMB ZOMBIE: Explode at 50% HP (once)
      if(z.bomb && !z.hasExploded50 && z.hp <= z.maxHp * 0.5 && z.hp > 0){
        z.hasExploded50 = true;
        const explosionDmg = z.maxHp * 0.25; // 25% of max HP as damage
        const explosionRange = 1.5; // tiles
        // Damage nearby plants
        for(const p of plants){
          const dist = Math.abs(p.col - z.x) + Math.abs(p.row - z.row);
          if(dist <= explosionRange && !p.immortal){
            p.hp -= explosionDmg;
          }
        }
        // Explosion effects
        spawnGoreParticles(z.x*CW,(z.row+0.5)*CH, 30);
        spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#ff6600',20);
        spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#ffcc00',15);
        try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playExplosion(); }catch(e){}
      }
      
        // small hit effect when HP drops but zombie still alive (works for flying side zombies too)
        if(prevHp > z.hp && z.hp > 0){
          spawnPlantParticles(z.x*CW, (z.row+0.5)*CH, '#ffb3b3', 6);
        }

        if(z.hp<=0 && !z.dead){ // enter death/ragdoll phase - EXPLOSIVE BLOOD BURST
            z.dead = true; z.deathTimer = 0; z.deathDur = 1000 + Math.random()*700; z.vx = -0.08 - Math.random()*0.06; z.ry = 0; z.rot = 0; z.alpha = 1;
            
            // BOMB ZOMBIE: Final explosion on death (50% max HP damage)
            if(z.bomb){
              const deathDmg = z.maxHp * 0.5; // 50% of max HP as damage
              const explosionRange = 2.0; // larger range on death
              // Damage nearby plants
              for(const p of plants){
                const dist = Math.abs(p.col - z.x) + Math.abs(p.row - z.row);
                if(dist <= explosionRange && !p.immortal){
                  p.hp -= deathDmg;
                }
              }
              // Massive explosion effects
              spawnGoreParticles(z.x*CW,(z.row+0.5)*CH, 60);
              spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#ff3300',30);
              spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#ffaa00',25);
              spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#ffff00',15);
              try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playExplosion(); playExplosion(); }catch(e){}
            } else {
              // Normal zombie death
              spawnGoreParticles(z.x*CW,(z.row+0.5)*CH, 45 + Math.floor(Math.random()*20));
              spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#ff0000',15);
              spawnPlantParticles(z.x*CW,(z.row+0.5)*CH,'#8b0000',10);
            }
            try{ if(audioCtx.state === 'suspended') audioCtx.resume(); playDeathSFX(); playBeep(120,'square',0.12,0.14); playZombieGroan(); } catch(e){}
            levelKilled++;
            // Instantly remove zombie - no sliding corpse animation
            zombies.splice(i,1);
            continue;
          }
          // if all zombies for this level have spawned and all are killed -> level complete
          if(levelSpawned >= levelTarget && levelKilled >= levelTarget){
            // pause and show overlay
                running = false;
                if(currentLevel >= 20){
                  document.getElementById('winOverlay').style.display = 'flex';
                } else {
                  document.getElementById('levelTitle').textContent = `Level ${currentLevel} Complete`;
                  document.getElementById('levelText').textContent = `You cleared ${levelTarget} zombies.`;
                  document.getElementById('levelOverlay').style.display = 'flex';
                }
              // Hide nextLevelBtn if on last level
              if(nextLevelBtn) {
                if(currentLevel >= 20) {
                  nextLevelBtn.style.display = 'none';
                } else {
                  nextLevelBtn.style.display = '';
                }
              }
          }
        }

    // lawnmowers moving across row: destroy zombies in path and remove when off-screen
    for(let mi = lawnmowers.length - 1; mi >= 0; mi--){
      try{
        const m = lawnmowers[mi];
        if(!m) continue;
        if(m.moving){
          m.x += (m.speed || 0.25) * dt/16;
          // Play continuous engine sound periodically
          if(Math.random() < 0.02) { try{ if(audioCtx.state==='suspended') audioCtx.resume(); if(m.row < 2) playAirplane(); else playMower(); }catch(e){} }
          for(let zi = zombies.length - 1; zi >= 0; zi--){
            const z = zombies[zi];
                if(z && z.row === m.row && z.x <= m.x + 0.6){
              spawnPlantParticles((m.x) * CW, (m.row + 0.5) * CH, '#ffb86b', 12);
              // Only play hit sound on first zombie hit
              if(!m.hitFirst){ 
                m.hitFirst = true;
                try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); if(m.row < 2) playAirplaneHit(); else playMowerHit(); }catch(e){} 
              }
                  // count mower kills toward level progress
                  levelKilled++;
                  zombies.splice(zi, 1);
            }
          }
          if(m.x > COLS + 1){ lawnmowers.splice(mi, 1); }
        }
      }catch(err){ console.error('Lawnmower loop error', err); }
    }

    // Check level completion here as well (catches mower kills and other removals)
    if(levelSpawned >= levelTarget && levelKilled >= levelTarget && zombies.length === 0){
      running = false;
      document.getElementById('levelTitle').textContent = `Level ${currentLevel} Complete`;
      document.getElementById('levelText').textContent = `You cleared ${levelTarget} zombies.`;
      document.getElementById('levelOverlay').style.display = 'flex';
    }

    // Sun drop spawner & physics (day only)
    if(running && !isNightLevel()){
      const nowt = performance.now();
      if(!lastSunDrop) lastSunDrop = nowt;
      // Custom sun drop logic for levels 1-10
      let sunInterval = SUN_DROP_INTERVAL;
      let allowDrop = true;
      if(currentLevel >= 1 && currentLevel <= 5){
        sunInterval = 10000; // 10s
      } else if(currentLevel >= 6 && currentLevel <= 10){
        sunInterval = 15000; // 15s
        allowDrop = Math.random() < 0.75; // 75% chance
      }
      if(nowt - lastSunDrop >= sunInterval && allowDrop){
        lastSunDrop = nowt;
        // spawn above screen at random X, target a random ground row (rows 2..ROWS-1)
        const sx = 40 + Math.random() * Math.max(0, W - 80);
        const targetRow = 2 + Math.floor(Math.random() * Math.max(1, ROWS - 2));
        const targetY = (targetRow + 0.5) * CH;
        fallingSuns.push({ id: Date.now() + Math.random(), x: sx, y: -24, vy: 0, r: 18, seed: Math.random()*1000, targetY: targetY, restUntil: 0 });
      }
      // update physics for falling suns
      for(let si = fallingSuns.length - 1; si >= 0; si--){
        const s = fallingSuns[si];
        s.vy += 0.0009 * dt; // gravity-ish
        s.y += s.vy * dt/16;
        if(!s.restUntil && s.y >= s.targetY){ s.y = s.targetY; s.vy = 0; s.restUntil = performance.now() + 5000; }
        if(s.restUntil && performance.now() > s.restUntil){ fallingSuns.splice(si,1); }
      }

      // Rain update & spawn for gloomy levels 5-10
      if(currentLevel >= 6 && currentLevel <= 10){
        // spawn proportional to width and dt
        const spawnCount = Math.max(0, Math.floor((W/12) * (dt/1000) * RAIN_SPAWN_COEFF));
        for(let k=0;k<spawnCount;k++){
          const rx = Math.random() * W;
          rainDrops.push({ id: Date.now() + Math.random(), x: rx, y: -10 - Math.random()*60, vy: 0.6 + Math.random()*0.6, len: 8 + Math.random() * (RAIN_MAX_LEN-8), alpha: 0.5 + Math.random()*0.4 });
        }
        // update raindrops
        for(let ri = rainDrops.length - 1; ri >= 0; ri--){
          const rd = rainDrops[ri];
          rd.vy += 0.0012 * dt;
          rd.y += rd.vy * dt/16;
          if(rd.y > H*0.92){ rainDrops.splice(ri,1); }
        }
      }
    }

    spawnAcc += dt;
    // dynamic spawn cap based on elapsed run time
    const _elapsedForCap = performance.now() - (gameStartTime || performance.now());
    // early game: fewer simultaneous zombies; increase at 40s and 70s
    // keep cap at 3 for first 40s, 5 for 40-70s, and keep 5 thereafter (no further increase)
    const earlyCap = _elapsedForCap < 40000 ? 3 : 5;
    // spawn only if under cap; add a bit of jitter to interval
    if(spawnAcc > SPAWN_INTERVAL + Math.random()*1200){ spawnAcc = 0; if(zombies.length < earlyCap) spawnZombie(); }
    updateUI();
  }

  // global runtime error display so users can see exceptions in-page
  window.addEventListener('error', (ev)=>{
    try{ const msg = ev.message + ' at ' + ev.filename + ':' + ev.lineno; hud.textContent = 'ERROR: ' + msg; running = false; menuOverlay.style.display = 'flex'; document.getElementById('menuCard').innerHTML = `<h1>Runtime Error</h1><pre style="text-align:left;white-space:pre-wrap;max-height:240px;overflow:auto">${msg}</pre><button id="reloadBtn">Reload</button>`; document.getElementById('reloadBtn').onclick=()=>location.reload(); }catch(e){}
  });
  window.addEventListener('unhandledrejection', (ev)=>{ try{ const msg = (ev.reason && ev.reason.message) || String(ev.reason); hud.textContent = 'Promise Rejection: '+msg; running=false; menuOverlay.style.display='flex'; }catch(e){} });

  // Helper: check if current level is night (11-20)
  function isNightLevel(){ return currentLevel >= 11 && currentLevel <= 20; }

  function render(){ 
    ctx.clearRect(0,0,W,H); 
    const grd = ctx.createLinearGradient(0,0,0,H); 
    const now = performance.now();
    
    // Day/Night background based on level
    if(isNightLevel()){
      // NIGHT background (levels 11-20) - dark blue/purple tones with parallax layers
      
      // Sky gradient
      const nightGrd = ctx.createLinearGradient(0,0,0,H*0.45);
      nightGrd.addColorStop(0,'#0d1b2a'); // very dark blue
      nightGrd.addColorStop(0.4,'#1b263b');
      nightGrd.addColorStop(0.7,'#2d3a4f');
      nightGrd.addColorStop(1,'#3d4f5f');
      ctx.fillStyle = nightGrd;
      ctx.fillRect(0,0,W,H*0.45);
      
      // Grass gradient
      const grassGrd = ctx.createLinearGradient(0,H*0.35,0,H);
      grassGrd.addColorStop(0,'#1e4620');
      grassGrd.addColorStop(0.3,'#173218');
      grassGrd.addColorStop(0.6,'#0f2410');
      grassGrd.addColorStop(1,'#081208');
      ctx.fillStyle = grassGrd;
      ctx.fillRect(0,H*0.35,W,H*0.65);
      
      // Twinkling stars with different sizes and brightness
      for(let i=0; i<60; i++){
        const sx = (Math.sin(i*127.1 + 0.1)*0.5+0.5)*W;
        const sy = (Math.sin(i*311.7)*0.5+0.5)*H*0.35;
        const twinkle = Math.sin(now/300 + i*1.7)*0.5 + 0.5;
        const ss = 0.5 + twinkle * 1.5 + (i%5)*0.3;
        const alpha = 0.4 + twinkle * 0.6;
        ctx.fillStyle = `rgba(255,255,${220 + Math.floor(twinkle*35)},${alpha})`;
        ctx.beginPath(); ctx.arc(sx, sy, ss, 0, Math.PI*2); ctx.fill();
      }
      
      // Shooting star occasionally
      const shootingStar = Math.sin(now/5000) > 0.95;
      if(shootingStar){
        const ssX = (now/10) % W;
        const ssY = H*0.1 + Math.sin(ssX/100)*20;
        const ssGrd = ctx.createLinearGradient(ssX-50, ssY, ssX, ssY);
        ssGrd.addColorStop(0, 'rgba(255,255,255,0)');
        ssGrd.addColorStop(1, 'rgba(255,255,255,0.9)');
        ctx.strokeStyle = ssGrd;
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(ssX-50, ssY+25); ctx.lineTo(ssX, ssY); ctx.stroke();
      }
      
      // Moon with glow and craters
      const moonX = W*0.85, moonY = H*0.12, moonR = 32;
      // Outer glow
      const moonGlow = ctx.createRadialGradient(moonX, moonY, moonR*0.5, moonX, moonY, moonR*2.5);
      moonGlow.addColorStop(0, 'rgba(255,250,220,0.3)');
      moonGlow.addColorStop(0.5, 'rgba(255,250,220,0.1)');
      moonGlow.addColorStop(1, 'rgba(255,250,220,0)');
      ctx.fillStyle = moonGlow;
      ctx.fillRect(moonX-moonR*3, moonY-moonR*3, moonR*6, moonR*6);
      // Moon body
      ctx.fillStyle = '#fffde7';
      ctx.beginPath(); ctx.arc(moonX, moonY, moonR, 0, Math.PI*2); ctx.fill();
      // Craters
      ctx.fillStyle = 'rgba(200,195,180,0.4)';
      ctx.beginPath(); ctx.arc(moonX-8, moonY-5, 6, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(moonX+10, moonY+8, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(moonX+3, moonY-12, 3, 0, Math.PI*2); ctx.fill();
      
      // Night clouds (dark silhouettes)
      ctx.fillStyle = 'rgba(20,30,50,0.6)';
      const cloudOffset = (now/80) % (W+200) - 100;
      ctx.beginPath(); ctx.ellipse((W*0.2 + cloudOffset*0.3)%W, H*0.25, 60, 25, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse((W*0.6 + cloudOffset*0.2)%W, H*0.18, 45, 20, 0, 0, Math.PI*2); ctx.fill();
      
      // Distant trees silhouette
      ctx.fillStyle = '#0a1a0a';
      for(let i=0; i<12; i++){
        const tx = i * (W/10) + Math.sin(i*3.7)*30;
        const ty = H*0.38;
        const th = 40 + Math.sin(i*2.3)*15;
        const tw = 25 + Math.sin(i*1.7)*10;
        // Tree trunk
        ctx.fillRect(tx-3, ty, 6, th*0.4);
        // Tree crown (triangle)
        ctx.beginPath();
        ctx.moveTo(tx, ty - th*0.3);
        ctx.lineTo(tx - tw, ty + th*0.1);
        ctx.lineTo(tx + tw, ty + th*0.1);
        ctx.closePath();
        ctx.fill();
      }
      
      // Fireflies
      for(let i=0; i<15; i++){
        const ffX = (Math.sin(now/2000 + i*5.3)*0.4 + 0.5)*W;
        const ffY = H*0.4 + (Math.sin(now/1500 + i*3.7)*0.3 + 0.5)*H*0.5;
        const ffAlpha = Math.sin(now/400 + i*2.1)*0.5 + 0.5;
        const ffGlow = ctx.createRadialGradient(ffX, ffY, 0, ffX, ffY, 8);
        ffGlow.addColorStop(0, `rgba(180,255,100,${ffAlpha*0.8})`);
        ffGlow.addColorStop(0.5, `rgba(150,255,80,${ffAlpha*0.3})`);
        ffGlow.addColorStop(1, 'rgba(100,200,50,0)');
        ctx.fillStyle = ffGlow;
        ctx.fillRect(ffX-10, ffY-10, 20, 20);
      }
      
      // Grid lines darker for night
      ctx.strokeStyle='rgba(0,0,0,0.25)';
      
      // Draw grass blades swaying (avoid bottom 3 rows)
      ctx.fillStyle = '#1a3d1c';
      const grassCutoffY = (ROWS - 3) * CH; // do not draw blades whose base is below this
      for(let i=0; i<80; i++){
        const gx = (i/80)*W + Math.sin(i*7.3)*10;
        const gy = H*0.38 + (i%5)*2;
        if(gy >= grassCutoffY) continue; // skip blades in bottom 3 rows
        const gh = 15 + Math.sin(i*2.1)*8;
        const sway = Math.sin(now/800 + i*0.5)*4;
        ctx.beginPath();
        ctx.moveTo(gx, gy);
        ctx.quadraticCurveTo(gx + sway, gy - gh/2, gx + sway*1.5, gy - gh);
        ctx.quadraticCurveTo(gx + sway, gy - gh/2, gx + 3, gy);
        ctx.fill();
      }
      
    } else {
      // DAY background (levels 1-10) - bright sunny 2D landscape
      
      // Sky gradient with more depth
      const isGloom = currentLevel >= 6 && currentLevel <= 10;
      if(isGloom){
        // darker, overcast sky for levels 5-10
        const gloomGrd = ctx.createLinearGradient(0,0,0,H*0.45);
        gloomGrd.addColorStop(0,'#2b2f33');
        gloomGrd.addColorStop(0.5,'#2f3133');
        gloomGrd.addColorStop(1,'#3a3a3a');
        ctx.fillStyle = gloomGrd;
        ctx.fillRect(0,0,W,H*0.45);
        // big dark clouds (animated using drawCloud)
        ctx.fillStyle = 'rgba(20,20,25,0.88)';
        const cloudOffsetG = (now/60) % (W+400) - 200;
        drawCloud(ctx, (W*0.15 + cloudOffsetG*0.4)%W, H*0.12, 2.2);
        drawCloud(ctx, (W*0.5 + cloudOffsetG*0.3)%W, H*0.08, 1.8);
        drawCloud(ctx, (W*0.82 + cloudOffsetG*0.22)%W, H*0.14, 2.0);
        // subtle overlay to darken the scene
        ctx.fillStyle='rgba(8,12,18,0.22)'; ctx.fillRect(0,0,W,H*0.45);
      } else {
        const skyGrd = ctx.createLinearGradient(0,0,0,H*0.4);
        skyGrd.addColorStop(0,'#4fc3f7'); // bright sky
        skyGrd.addColorStop(0.3,'#81d4fa');
        skyGrd.addColorStop(0.6,'#b3e5fc');
        skyGrd.addColorStop(1,'#e1f5fe'); // horizon haze
        ctx.fillStyle = skyGrd;
        ctx.fillRect(0,0,W,H*0.45);
      }
      
      // Grass gradient with layers
      const grassGrd = ctx.createLinearGradient(0,H*0.35,0,H);
      grassGrd.addColorStop(0,'#7cb342');
      grassGrd.addColorStop(0.2,'#689f38');
      grassGrd.addColorStop(0.5,'#558b2f');
      grassGrd.addColorStop(0.8,'#33691e');
      grassGrd.addColorStop(1,'#1b5e20');
      ctx.fillStyle = grassGrd;
      ctx.fillRect(0,H*0.35,W,H*0.65);
      
      // Sun (normal or dimmed during gloomy levels)
      const sunX = W*0.9, sunY = H*0.1;
      if(!isGloom){
        const sunR = 35;
        // Sun rays (rotating)
        ctx.save();
        ctx.translate(sunX, sunY);
        ctx.rotate(now/10000);
        for(let i=0; i<12; i++){
          ctx.rotate(Math.PI/6);
          const rayGrd = ctx.createLinearGradient(0, -sunR*1.2, 0, -sunR*3);
          rayGrd.addColorStop(0, 'rgba(255,235,59,0.6)');
          rayGrd.addColorStop(1, 'rgba(255,235,59,0)');
          ctx.fillStyle = rayGrd;
          ctx.beginPath();
          ctx.moveTo(-8, -sunR*1.2);
          ctx.lineTo(0, -sunR*3);
          ctx.lineTo(8, -sunR*1.2);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
        // Sun glow
        const sunGlow = ctx.createRadialGradient(sunX, sunY, sunR*0.5, sunX, sunY, sunR*2.5);
        sunGlow.addColorStop(0, 'rgba(255,245,157,0.8)');
        sunGlow.addColorStop(0.4, 'rgba(255,235,59,0.3)');
        sunGlow.addColorStop(1, 'rgba(255,235,59,0)');
        ctx.fillStyle = sunGlow;
        ctx.fillRect(sunX-sunR*3, sunY-sunR*3, sunR*6, sunR*6);
        // Sun body
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath(); ctx.arc(sunX, sunY, sunR, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff59d';
        ctx.beginPath(); ctx.arc(sunX-8, sunY-8, sunR*0.3, 0, Math.PI*2); ctx.fill(); // highlight
      } else {
        // Dimmed sun: smaller, faint glow and mostly occluded by clouds
        const sunR = 18;
        // faint glow
        const sunGlow = ctx.createRadialGradient(sunX, sunY, sunR*0.3, sunX, sunY, sunR*1.8);
        sunGlow.addColorStop(0, 'rgba(255,235,59,0.25)');
        sunGlow.addColorStop(0.6, 'rgba(255,235,59,0.06)');
        sunGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = sunGlow;
        ctx.fillRect(sunX-sunR*3, sunY-sunR*3, sunR*6, sunR*6);
        // dim sun body
        ctx.fillStyle = 'rgba(255,235,59,0.28)';
        ctx.beginPath(); ctx.arc(sunX, sunY, sunR, 0, Math.PI*2); ctx.fill();
        // small washed highlight
        ctx.fillStyle = 'rgba(255,245,200,0.12)';
        ctx.beginPath(); ctx.arc(sunX-5, sunY-5, sunR*0.2, 0, Math.PI*2); ctx.fill();
        // draw heavier cloud shapes over the sun to occlude it further
        ctx.fillStyle = 'rgba(18,18,20,0.95)';
        drawCloud(ctx, sunX - 10, sunY - 6, 1.6);
        drawCloud(ctx, sunX + 20, sunY - 10, 1.2);
        drawCloud(ctx, sunX + 46, sunY + 8, 1.0);
      }
      
      // Animated clouds with parallax
      const cloudSpeed1 = (now/100) % (W+300);
      const cloudSpeed2 = (now/150) % (W+300);
      const cloudSpeed3 = (now/80) % (W+300);
      
      // Far clouds (slower, smaller, lighter)
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      drawCloud(ctx, cloudSpeed1 - 150, H*0.06, 0.6);
      drawCloud(ctx, cloudSpeed2 - 100 + W*0.3, H*0.1, 0.5);
      
      // Near clouds (faster, bigger, whiter)
      if(isGloom){
        ctx.fillStyle = 'rgba(40,40,45,0.85)';
        drawCloud(ctx, cloudSpeed3 - 150, H*0.14, 1.4);
        drawCloud(ctx, cloudSpeed1*0.7 + W*0.4, H*0.08, 1.2);
        drawCloud(ctx, cloudSpeed2*0.8 + W*0.6, H*0.18, 1.3);
      } else {
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        drawCloud(ctx, cloudSpeed3 - 150, H*0.14, 1.0);
        drawCloud(ctx, cloudSpeed1*0.7 + W*0.4, H*0.08, 0.9);
        drawCloud(ctx, cloudSpeed2*0.8 + W*0.6, H*0.18, 0.8);
      }
      
      // Distant hills (parallax background)
      ctx.fillStyle = '#81c784';
      ctx.beginPath();
      ctx.moveTo(0, H*0.38);
      for(let x=0; x<=W; x+=50){
        const hillY = H*0.36 + Math.sin(x/200 + 0.5)*12 + Math.sin(x/80)*5;
        ctx.lineTo(x, hillY);
      }
      ctx.lineTo(W, H*0.45);
      ctx.lineTo(0, H*0.45);
      ctx.closePath();
      ctx.fill();
      
      // Fence at horizon

      // Draw rain for gloomy levels
      if(isGloom && rainDrops && rainDrops.length){
        ctx.save();
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(170,200,255,0.55)';
        ctx.beginPath();
        for(let i=0;i<rainDrops.length;i++){
          const rd = rainDrops[i];
          const dx = -rd.vy * rd.len * 0.9;
          ctx.moveTo(rd.x + dx*0.1, rd.y - rd.len*0.2);
          ctx.lineTo(rd.x + dx, rd.y + rd.len);
        }
        ctx.stroke();
        ctx.restore();
      }
      ctx.fillStyle = '#5d4037';
      const fenceY = H*0.36;
      for(let i=0; i<W/40; i++){
        const fx = i*40 + 20;
        // Fence post
        ctx.fillRect(fx-3, fenceY-20, 6, 25);
        // Fence cap
        ctx.beginPath();
        ctx.moveTo(fx-5, fenceY-20);
        ctx.lineTo(fx, fenceY-28);
        ctx.lineTo(fx+5, fenceY-20);
        ctx.closePath();
        ctx.fill();
      }
      // Fence rails
      ctx.fillRect(0, fenceY-15, W, 4);
      ctx.fillRect(0, fenceY-5, W, 4);
      
      // Decorative flowers scattered
      const flowerColors = ['#e91e63', '#ff5722', '#ffeb3b', '#9c27b0', '#3f51b5'];
      for(let i=0; i<25; i++){
        const fx = (Math.sin(i*73.7)*0.5+0.5)*W;
        const fy = H*0.39 + (i%5)*3 + Math.sin(i*2.3)*5;
        const fc = flowerColors[i % flowerColors.length];
        const sway = Math.sin(now/600 + i*0.8)*2;
        // Stem
        ctx.strokeStyle = '#388e3c';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(fx, fy+10);
        ctx.quadraticCurveTo(fx+sway, fy+5, fx+sway*1.5, fy);
        ctx.stroke();
        // Flower
        ctx.fillStyle = fc;
        ctx.beginPath(); ctx.arc(fx+sway*1.5, fy, 4+Math.sin(i)*1, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath(); ctx.arc(fx+sway*1.5, fy, 2, 0, Math.PI*2); ctx.fill();
      }
      
      // Grass blades (foreground, more detail) - skip bottom 3 rows
      const grassCutoffY_day = (ROWS - 3) * CH;
      for(let layer=0; layer<2; layer++){
        ctx.fillStyle = layer===0 ? '#558b2f' : '#689f38';
        for(let i=0; i<100; i++){
          const gx = (i/100)*W + Math.sin(i*7.3 + layer*50)*15;
          const gy = H*0.38 + layer*5 + (i%3)*2;
          if(gy >= grassCutoffY_day) continue;
          const gh = 12 + Math.sin(i*2.1)*6 + layer*5;
          const sway = Math.sin(now/500 + i*0.3 + layer)*3;
          ctx.beginPath();
          ctx.moveTo(gx, gy);
          ctx.quadraticCurveTo(gx + sway, gy - gh/2, gx + sway*1.5, gy - gh);
          ctx.quadraticCurveTo(gx + sway + 2, gy - gh/2, gx + 4, gy);
          ctx.fill();
        }
      }
      
      // Butterflies
      for(let i=0; i<5; i++){
        const bx = (Math.sin(now/3000 + i*4.2)*0.3 + 0.5)*W + i*100;
        const by = H*0.25 + Math.sin(now/800 + i*2.7)*40;
        const wingFlap = Math.sin(now/80 + i)*0.5;
        ctx.fillStyle = i%2===0 ? '#ff9800' : '#e91e63';
        // Wings
        ctx.save();
        ctx.translate(bx, by);
        ctx.scale(1, Math.abs(wingFlap)+0.3);
        ctx.beginPath(); ctx.ellipse(-4, 0, 6, 4, -0.3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(4, 0, 6, 4, 0.3, 0, Math.PI*2); ctx.fill();
        ctx.restore();
        // Body
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(bx-1, by-3, 2, 6);
      }
      
      // Grid lines lighter for day
      ctx.strokeStyle='rgba(0,0,0,0.08)';
    }
    
    // Draw grid cells with subtle tile pattern
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ 
      // Alternating tile shading for depth
      const tileShade = (r+c)%2 === 0 ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.03)';
      ctx.fillStyle = tileShade;
      ctx.fillRect(c*CW+2, r*CH+2, CW-4, CH-4);
      ctx.strokeRect(c*CW+1, r*CH+1, CW-2, CH-2); 
    }

    // Render any active areaEffects (tile overlays)
    if(areaEffects && areaEffects.length){
      for(const ae of areaEffects){
        if(!ae.tiles || !ae.tiles.length) continue;
        const age = now - (ae.created||0);
        const tLife = ae.life || 600;
        const alphaBase = Math.max(0, 1 - age / tLife);
        ctx.save(); ctx.globalCompositeOperation = 'lighter';
        for(const tt of ae.tiles){
          const rx = tt.c * CW, ry = tt.r * CH;
          // pulsing orange/red glow for ember ring
          if(ae.type === 'emberRing'){
            const glow = ctx.createRadialGradient(rx + CW*0.5, ry + CH*0.45, 0, rx + CW*0.5, ry + CH*0.45, Math.max(CW, CH) * 0.9);
            glow.addColorStop(0, `rgba(255,160,120,${0.9 * alphaBase})`);
            glow.addColorStop(0.5, `rgba(255,120,60,${0.55 * alphaBase})`);
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glow; ctx.beginPath(); ctx.ellipse(rx + CW*0.5, ry + CH*0.45, CW*0.6, CH*0.45, 0, 0, Math.PI*2); ctx.fill();
            // thin border to mark tile
            ctx.strokeStyle = `rgba(255,120,60,${0.6 * alphaBase})`; ctx.lineWidth = 2; ctx.strokeRect(rx+3, ry+3, CW-6, CH-6);
          }
        }
        ctx.restore();
      }
    }

    // Draw placement/selection preview highlight if hovering a cell while a seed selected or hammer active
    if(hoverCol >= 0 && hoverRow >= 0){
      const hx = hoverCol * CW + 4; const hy = hoverRow * CH + 4; const hw = CW - 8; const hh = CH - 8;
      ctx.save();
      // color depends on mode: green for planting, orange for hammer
      if(hammerMode){ ctx.fillStyle = 'rgba(255,193,7,0.18)'; ctx.strokeStyle = 'rgba(255,193,7,0.45)'; }
      else { ctx.fillStyle = 'rgba(76,175,80,0.12)'; ctx.strokeStyle = 'rgba(76,175,80,0.5)'; }
      // subtle rounded rect
      const rrad = 8;
      ctx.beginPath(); ctx.moveTo(hx+rrad, hy); ctx.arcTo(hx+hw, hy, hx+hw, hy+hh, rrad); ctx.arcTo(hx+hw, hy+hh, hx, hy+hh, rrad); ctx.arcTo(hx, hy+hh, hx, hy, rrad); ctx.arcTo(hx, hy, hx+hw, hy, rrad); ctx.closePath();
      ctx.fill(); ctx.lineWidth = 2; ctx.stroke();
      // small glow
      ctx.shadowColor = (hammerMode ? 'rgba(255,193,7,0.35)' : 'rgba(76,175,80,0.25)'); ctx.shadowBlur = 16;
      ctx.fill(); ctx.restore();
    }

    // Foreground: swaying grass per tile for visual interest
    // Skip top 2 rows (rows 0 and 1) as requested
    (function drawTileGrass(){
      ctx.save();
      ctx.globalAlpha = 0.98;
      for(let r=2; r<ROWS-3; r++){
        // base Y near bottom of the tile so grass grows from ground
        const baseY = r*CH + CH*0.78;
        for(let c=0; c<COLS; c++){
          const cellLeft = c*CW, cellRight = (c+1)*CW;
          const cx = c*CW + CW*0.5;
          // deterministic seed per cell for varied phase
          const seed = (c*31 + r*17) & 0xffff;
          const basePhase = Math.sin(now/700 + seed*0.11);
          const bladesPerCell = 6; // increased density
          for(let b=0; b<bladesPerCell; b++){
            const subSeed = seed + b*13;
            const phase = Math.sin(now/(650 + (b*20)) + subSeed*0.09);
            const sway = phase * Math.min(12, CH*0.16) * (0.6 + (b/bladesPerCell)*0.6);
            const gh = CH*0.18 + (Math.sin(subSeed*0.21 + now/1000)*4) + (b%2)*1.5;
            // spread blades horizontally within the tile
            const offsetX = ((b / bladesPerCell) - 0.5) * (CW*0.6) + Math.sin(subSeed*0.33)*2;
            const bx = cx + offsetX;
            // slightly vary color per row and blade for depth
            if((r + b) % 3 === 0) ctx.fillStyle = '#3e7b2a';
            else if((r + b) % 3 === 1) ctx.fillStyle = '#4caf50';
            else ctx.fillStyle = '#2e7d32';
            ctx.beginPath();
            ctx.moveTo(bx - 2, baseY);
            ctx.quadraticCurveTo(bx - sway*0.6, baseY - gh*0.45, bx, baseY - gh);
            ctx.quadraticCurveTo(bx + sway*0.4, baseY - gh*0.45, bx + 2, baseY);
            ctx.closePath();
            ctx.fill();
            // thin highlight blade
            ctx.fillStyle = 'rgba(255,255,255,0.025)';
            ctx.beginPath();
            ctx.moveTo(bx + 2.5, baseY);
            ctx.quadraticCurveTo(bx + 2.5 - sway*0.5, baseY - gh*0.28, bx + 4, baseY - gh*0.5);
            ctx.quadraticCurveTo(bx + 4 + sway*0.15, baseY - gh*0.28, bx + 5.5, baseY);
            ctx.closePath();
            ctx.fill();
          }
        }
      }
      ctx.restore();
    })();

    // Draw round number at (22, H - 32) as requested
    ctx.save();
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    // Äáº·t dÃ²ng Round vÃ o chÃ­nh giá»¯a khoáº£ng tá»« viá»n gá»— (dÆ°á»›i cÃ¹ng) Ä‘áº¿n mÃ©p trÃªn Ã´ trá»“ng cÃ¢y Ä‘áº§u tiÃªn
    // Äáº·t chá»¯ Round vÃ o giá»¯a khung tiáº¿n trÃ¬nh (progress bar)
    const progressBarWidth = 320;
    const progressBarHeight = 32;
    const roundX = 675;
    const roundY = H - progressBarHeight + progressBarHeight / 2;
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillText(`Round ${currentLevel}`, roundX + 2, roundY + 2); // shadow
    ctx.fillStyle = '#fffde7';
    ctx.fillText(`Round ${currentLevel}`, roundX, roundY);
    ctx.restore();
    // (screen shake removed)
    ctx.save();

    for(const p of particles){ const alpha = 1 - p.t/p.life; ctx.fillStyle = p.color; ctx.globalAlpha = alpha; ctx.beginPath(); const size = p.size || Math.max(1,4*(1-alpha)); ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }

    // draw falling suns (day only)
    if(!isNightLevel()){
      for(const s of fallingSuns){
        ctx.save();
        const nowt = performance.now();
        const pulse = 1 + Math.sin(nowt/200 + (s.seed||s.x)) * 0.06 + 0.03;
        const sr = s.r * pulse;
        // larger glow
        const g = ctx.createRadialGradient(s.x, s.y, sr*0.08, s.x, s.y, sr*2.8 + (s.r*0.6));
        g.addColorStop(0, 'rgba(255,250,180,0.95)');
        g.addColorStop(0.35, 'rgba(255,235,59,0.45)');
        g.addColorStop(1, 'rgba(255,235,59,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(s.x, s.y, sr*1.9, 0, Math.PI*2); ctx.fill();
        // main body (slightly larger)
        ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(s.x, s.y, sr*0.95, 0, Math.PI*2); ctx.fill();
        // highlight
        ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.arc(s.x - sr*0.28, s.y - sr*0.28, sr*0.4, 0, Math.PI*2); ctx.fill();
        // small sparkling lights around
        for(let k=0;k<6;k++){
          const ang = (k/6) * Math.PI*2 + nowt/700 + (s.seed||0);
          const rdist = sr*1.35 + Math.sin(nowt/260 + k)*2;
          const sxp = s.x + Math.cos(ang) * rdist;
          const syp = s.y + Math.sin(ang) * rdist * 0.8;
          const alpha = 0.35 + 0.5 * (0.5 + 0.5*Math.sin(nowt/200 + k + (s.seed||0)));
          ctx.fillStyle = `rgba(255,250,200,${Math.min(1,alpha)})`;
          ctx.beginPath(); ctx.arc(sxp, syp, Math.max(1.2, sr*0.08), 0, Math.PI*2); ctx.fill();
        }
        // simple eyes to keep friendly look
        ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.beginPath(); ctx.arc(s.x - sr*0.18, s.y - sr*0.02, sr*0.14, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(s.x + sr*0.18, s.y - sr*0.02, sr*0.14, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    // draw lawnmowers (icons on the left or moving across) - top 2 rows use airplanes
    for(const m of lawnmowers){ 
      const mx = (m.moving ? m.x*CW : 0.28*CW) + 12; 
      const my = (m.row + 0.5)*CH; 
      // Top 2 rows (row 0 and 1) use airplane, rest use lawnmower
      let img;
      if(m.row < 2){
        // Airplane for top 2 rows
        img = isNightLevel() ? spriteImages.airplaneNight : spriteImages.airplane;
      } else {
        img = spriteImages.lawnmower;
      }
      const isPlane = m.row < 2;
      // Adjust airplane and lawnmower sizes: airplane kept, mower reduced by extra 0.05
      const planeMw = CW*(0.7 + 0.15);
      const planeMh = CH*(0.5 + 0.15);
      // mower offset reduced by additional 0.05 per user request
      const mowerMw = CW*(0.58 + 0.15 - 0.05);
      const mowerMh = CH*(0.48 + 0.15 - 0.05);
      const mw = isPlane ? planeMw : mowerMw;
      const mh = isPlane ? planeMh : mowerMh;
      ctx.save(); 
      ctx.translate(mx, my); 
      if(m.moving){ 
        ctx.globalAlpha = 1; 
        if(isPlane){
          // Airplane wobble animation when flying
          ctx.rotate(Math.sin(performance.now()/100 + m.row)*0.08);
          // Propeller spin effect - draw spinning blur
          ctx.fillStyle = 'rgba(100,100,100,0.3)';
          const propAngle = performance.now()/20;
          ctx.save();
          ctx.translate(mw*0.45, 0);
          ctx.rotate(propAngle);
          ctx.fillRect(-2, -12, 4, 24);
          ctx.restore();
        } else {
          ctx.rotate(Math.sin(performance.now()/60 + m.row)*0.04); 
        }
      } else { 
        ctx.globalAlpha = 0.9; 
        if(isPlane){
          // Idle airplane slight hover
          ctx.translate(0, Math.sin(performance.now()/400)*2);
        }
      }
      ctx.drawImage(img, -mw/2, -mh/2, mw, mh);

      // moving effects: spinning blade blur and motion streak for ground mowers
      if(m.moving && !isPlane){
        const t = performance.now();
        // approximate wheel positions relative to drawn image
        const wheelLX = -mw * 0.24;
        const wheelRX = mw * 0.12;
        const wheelY = mh * 0.33;
        const spinSpeed = (m.speed || 0.25) * 0.08;
        const angle = t * 0.03 * (1 + spinSpeed * 6);

        // subtle motion streak behind mower (to the left when moving right)
        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = '#000';
        const streakW = mw * 0.8, streakH = mh * 0.35;
        ctx.beginPath();
        ctx.ellipse(-mw*0.6, 0, streakW, streakH, 0, Math.PI*1.3, Math.PI*1.7);
        ctx.fill();
        ctx.restore();

        // spinning blur at wheels
        for(const wx of [wheelLX, wheelRX]){
          ctx.save();
          ctx.translate(wx, wheelY);
          ctx.rotate(angle * (wx === wheelLX ? 1 : -1));

          // blurred ring
          const radius = Math.max(6, Math.min(14, mw * 0.08));
          const rg = ctx.createRadialGradient(0,0,radius*0.25, 0,0,radius);
          rg.addColorStop(0, 'rgba(255,255,255,0.25)');
          rg.addColorStop(0.6, 'rgba(200,200,200,0.08)');
          rg.addColorStop(1, 'rgba(120,120,120,0)');
          ctx.fillStyle = rg;
          ctx.beginPath(); ctx.arc(0,0,radius,0,Math.PI*2); ctx.fill();

          // spoke blur: several thin blades rotated
          ctx.globalAlpha = 0.28;
          ctx.fillStyle = 'rgba(240,240,240,0.85)';
          for(let s=0;s<6;s++){
            ctx.save(); ctx.rotate((s/6)*Math.PI*2);
            ctx.fillRect(-radius*0.02, -radius*0.9, radius*0.04, radius*0.7);
            ctx.restore();
          }

          ctx.restore();
        }
      }

      ctx.restore(); 
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2D ANIMATED PLANT DRAWING FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // SUNFLOWER - cheerful with animated petals
    function draw2DSunflower(ctx, p, x, y, w, h, now) {
      const bob = Math.sin(now/350 + p.col)*3;
      const pulse = 1 + 0.05 * Math.sin(now/250 + p.col);
      const petalWave = now/200;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if ((typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) && typeof p.row === 'number' && p.row < 2) yShift = 18;
      ctx.translate(x, y + bob + yShift);
      ctx.scale(p.scale * pulse, p.scale * pulse);
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, h*0.4, w*0.3, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Stem
      ctx.fillStyle = '#2e7d32';
      ctx.beginPath();
      ctx.moveTo(-w*0.04, h*0.1);
      ctx.quadraticCurveTo(-w*0.06, h*0.25, -w*0.03, h*0.4);
      ctx.lineTo(w*0.03, h*0.4);
      ctx.quadraticCurveTo(w*0.06, h*0.25, w*0.04, h*0.1);
      ctx.fill();
      
      // Leaves on stem
      ctx.fillStyle = '#43a047';
      ctx.beginPath();
      ctx.ellipse(-w*0.12, h*0.25, w*0.1, h*0.05, -0.5, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.1, h*0.32, w*0.08, h*0.04, 0.4, 0, Math.PI*2);
      ctx.fill();
      
      // Petals (12 animated petals)
      for(let i = 0; i < 12; i++) {
        ctx.save();
        const angle = (i / 12) * Math.PI * 2;
        const petalPulse = 1 + 0.1 * Math.sin(petalWave + i * 0.5);
        ctx.rotate(angle);
        ctx.translate(0, -h*0.18 * petalPulse);
        
        // Petal gradient
        const petalGrd = ctx.createRadialGradient(0, -h*0.08, 0, 0, -h*0.08, h*0.12);
        petalGrd.addColorStop(0, '#fff176');
        petalGrd.addColorStop(0.6, '#ffeb3b');
        petalGrd.addColorStop(1, '#fbc02d');
        ctx.fillStyle = petalGrd;
        
        ctx.beginPath();
        ctx.ellipse(0, -h*0.08, w*0.08, h*0.1, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      
      // Center face
      const faceGrd = ctx.createRadialGradient(0, -h*0.05, 0, 0, -h*0.05, w*0.18);
      faceGrd.addColorStop(0, '#8d6e63');
      faceGrd.addColorStop(0.7, '#5d4037');
      faceGrd.addColorStop(1, '#3e2723');
      ctx.fillStyle = faceGrd;
      ctx.beginPath();
      ctx.arc(0, -h*0.05, w*0.18, 0, Math.PI*2);
      ctx.fill();
      
      // Eyes (happy)
      ctx.fillStyle = '#1a1a1a';
      const blink = Math.sin(now/1500) > 0.95 ? 0.1 : 1;
      ctx.beginPath();
      ctx.ellipse(-w*0.07, -h*0.08, w*0.03, h*0.03 * blink, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.07, -h*0.08, w*0.03, h*0.03 * blink, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(-w*0.08, -h*0.09, w*0.012, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.06, -h*0.09, w*0.012, 0, Math.PI*2);
      ctx.fill();
      
      // Smile
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, -h*0.03, w*0.08, 0.2, Math.PI - 0.2);
      ctx.stroke();
      
      // Cheeks
      ctx.fillStyle = 'rgba(255,138,128,0.4)';
      ctx.beginPath();
      ctx.ellipse(-w*0.12, -h*0.02, w*0.04, h*0.025, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.12, -h*0.02, w*0.04, h*0.025, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Sun glow
      const glowSize = w*0.4 + Math.sin(now/200)*w*0.05;
      const glow = ctx.createRadialGradient(0, -h*0.05, w*0.15, 0, -h*0.05, glowSize);
      glow.addColorStop(0, 'rgba(255,235,59,0.3)');
      glow.addColorStop(1, 'rgba(255,193,7,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, -h*0.05, glowSize, 0, Math.PI*2);
      ctx.fill();
      
      ctx.restore();
    }
    
    // PEASHOOTER - with animated mouth and stem
    function draw2DPeashooter(ctx, p, x, y, w, h, now) {
      const bob = Math.sin(now/400 + p.col)*2;
      const recoil = (p.lastShoot && now - p.lastShoot < 180) ? 8 * (1 - (now - p.lastShoot)/180) : 0;
      const mouthOpen = recoil > 0 ? 0.3 : 0;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if ((typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) && typeof p.row === 'number' && p.row < 2) yShift = 18;
      ctx.translate(x + recoil, y + bob + yShift);
      ctx.scale(p.scale, p.scale);
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, h*0.4, w*0.25, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Stem -> support mast (metal)
      ctx.fillStyle = '#3a3a3a';
      ctx.beginPath();
      ctx.roundRect(-w*0.04, h*0.02, w*0.08, h*0.42, 4);
      ctx.fill();
      // Support ribs (subtle highlights)
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillRect(-w*0.03, h*0.08, w*0.06, h*0.008);

      // Small support plates (replace leaves)
      ctx.fillStyle = '#2f2f2f';
      ctx.beginPath(); ctx.roundRect(-w*0.22, h*0.18, w*0.14, h*0.06, 3); ctx.fill();
      ctx.beginPath(); ctx.roundRect(w*0.08, h*0.22, w*0.12, h*0.05, 3); ctx.fill();

      // Head/body -> metallic cannon housing
      const headGrd = ctx.createRadialGradient(-w*0.02, -h*0.12, 0, 0, -h*0.02, w*0.3);
      headGrd.addColorStop(0, '#cfcfcf');
      headGrd.addColorStop(0.5, '#9e9e9e');
      headGrd.addColorStop(1, '#424242');
      ctx.fillStyle = headGrd;
      ctx.beginPath();
      ctx.ellipse(0, -h*0.05, w*0.28, h*0.22, 0, 0, Math.PI*2);
      ctx.fill();
      // Head highlight stripe
      ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.beginPath(); ctx.ellipse(-w*0.08, -h*0.12, w*0.08, h*0.04, -0.4, 0, Math.PI*2); ctx.fill();
      
      // Cannon-like muzzle (visual only) - recoil handled by translate(recoil)
      ctx.save();
      ctx.translate(w*0.18, -h*0.06);
      // Main barrel body (longer, thicker)
      ctx.fillStyle = '#3b3b3b';
      ctx.beginPath();
      ctx.roundRect(0, -h*0.06, w*0.5, h*0.12, 6);
      ctx.fill();
      // Barrel shading (top highlight)
      const barrelGrd = ctx.createLinearGradient(0, -h*0.06, 0, h*0.06);
      barrelGrd.addColorStop(0, 'rgba(255,255,255,0.08)');
      barrelGrd.addColorStop(0.5, 'rgba(0,0,0,0.08)');
      barrelGrd.addColorStop(1, 'rgba(0,0,0,0.25)');
      ctx.fillStyle = barrelGrd;
      ctx.beginPath(); ctx.roundRect(0, -h*0.06, w*0.5, h*0.12, 6); ctx.fill();
      // Inner barrel rim (deep) with gradient
      const rimX = w*0.5 - w*0.07;
      const rimGrd = ctx.createRadialGradient(rimX, 0, w*0.01, rimX, 0, w*0.08);
      rimGrd.addColorStop(0, '#111'); rimGrd.addColorStop(1, '#222');
      ctx.fillStyle = rimGrd;
      ctx.beginPath(); ctx.ellipse(rimX, 0, w*0.08, h*0.05, 0, 0, Math.PI*2); ctx.fill();

      // Mounting collar between head and barrel
      ctx.fillStyle = '#2e2e2e';
      ctx.beginPath(); ctx.roundRect(-w*0.03, -h*0.035, w*0.08, h*0.07, 3); ctx.fill();
      // Little bolts / rivets
      ctx.fillStyle = '#555';
      for(let b=0;b<3;b++){ ctx.beginPath(); ctx.arc(-w*0.01 + b*w*0.03, -h*0.02, w*0.01, 0, Math.PI*2); ctx.fill(); }

      // Support bracket under barrel
      ctx.fillStyle = '#2a2a2a';
      ctx.beginPath(); ctx.roundRect(w*0.06, h*0.04, w*0.18, h*0.04, 3); ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.beginPath(); ctx.ellipse(w*0.2, h*0.12, w*0.12, h*0.03, 0, 0, Math.PI*2); ctx.fill();

      // Muzzle flash when shooting (bright, layered)
      if(recoil > 0) {
        const a = Math.min(1, recoil/8);
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = `rgba(255,200,120,${0.9*a})`;
        ctx.beginPath(); ctx.ellipse(w*0.56 + recoil*0.2, 0, 12 + recoil*1.4, 8 + recoil*0.8, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = `rgba(255,120,40,${0.6*a})`;
        ctx.beginPath(); ctx.ellipse(w*0.58 + recoil*0.25, 0, 6 + recoil, 4 + recoil*0.5, 0, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
      ctx.restore();
      
      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-w*0.08, -h*0.12, w*0.07, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.05, -h*0.12, w*0.06, h*0.055, 0, 0, Math.PI*2);
      ctx.fill();
      // Pupils (look right when shooting)
      const pupilOffset = recoil > 0 ? w*0.02 : 0;
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(-w*0.06 + pupilOffset, -h*0.12, w*0.03, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.07 + pupilOffset, -h*0.12, w*0.025, 0, Math.PI*2);
      ctx.fill();
      
      // Eyebrows (determined look)
      ctx.strokeStyle = '#2e7d32';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-w*0.14, -h*0.18);
      ctx.lineTo(-w*0.02, -h*0.16);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w*0.0, -h*0.17);
      ctx.lineTo(w*0.1, -h*0.18);
      ctx.stroke();
      
      // Muzzle flash when shooting
      if(recoil > 0) {
        ctx.fillStyle = `rgba(197,225,165,${0.8 * recoil/8})`;
        ctx.beginPath();
        ctx.arc(w*0.4, -h*0.05, 8 + recoil, 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    // WALLNUT - sturdy with face
    function draw2DWallnut(ctx, p, x, y, w, h, now) {
      const bob = Math.sin(now/500 + p.col)*1.5;
      const hpRatio = p.hp / (p.maxHp || 40);
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if ((typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) && typeof p.row === 'number' && p.row < 2) yShift = 18;
      ctx.translate(x, y + bob + yShift);
      ctx.scale((p.scale||1)*0.66, (p.scale||1)*0.66); // now 2x the previous (1/3) size = 2/3 original
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(0, h*0.35, w*0.3, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Main body - steel/gray tough look
      const bodyGrd = ctx.createRadialGradient(-w*0.08, -h*0.1, 0, 0, 0, w*0.35);
      bodyGrd.addColorStop(0, '#b0bec5'); // light steel
      bodyGrd.addColorStop(0.5, '#78909c'); // mid steel
      bodyGrd.addColorStop(1, '#263238'); // dark steel
      ctx.fillStyle = bodyGrd;
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.32, h*0.35, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Steel shell lines
      ctx.strokeStyle = '#37474f';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      ctx.moveTo(-w*0.2, -h*0.2);
      ctx.quadraticCurveTo(0, -h*0.3, w*0.2, -h*0.2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-w*0.25, 0);
      ctx.quadraticCurveTo(-w*0.15, h*0.1, 0, h*0.15);
      ctx.quadraticCurveTo(w*0.15, h*0.1, w*0.25, 0);
      ctx.stroke();
      
      // Cracks when damaged
      if(hpRatio < 0.7) {
        ctx.strokeStyle = '#5d4037';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-w*0.1, -h*0.15);
        ctx.lineTo(-w*0.05, h*0.05);
        ctx.lineTo(-w*0.15, h*0.1);
        ctx.stroke();
      }
      if(hpRatio < 0.4) {
        ctx.beginPath();
        ctx.moveTo(w*0.08, -h*0.1);
        ctx.lineTo(w*0.15, h*0.08);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, h*0.1);
        ctx.lineTo(w*0.05, h*0.25);
        ctx.stroke();
      }
      
      // Eyes (worried when low HP)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-w*0.1, -h*0.08, w*0.07, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.1, -h*0.08, w*0.07, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#3e2723';
      ctx.beginPath();
      ctx.arc(-w*0.1, -h*0.07, w*0.035, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.1, -h*0.07, w*0.035, 0, Math.PI*2);
      ctx.fill();
      
      // Eyebrows (more worried when damaged)
      ctx.strokeStyle = '#5d4037';
      ctx.lineWidth = 3;
      if(hpRatio < 0.5) {
        // Worried eyebrows
        ctx.beginPath();
        ctx.moveTo(-w*0.16, -h*0.18);
        ctx.lineTo(-w*0.04, -h*0.14);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(w*0.04, -h*0.14);
        ctx.lineTo(w*0.16, -h*0.18);
        ctx.stroke();
      } else {
        // Determined eyebrows
        ctx.beginPath();
        ctx.moveTo(-w*0.15, -h*0.15);
        ctx.lineTo(-w*0.05, -h*0.16);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(w*0.05, -h*0.16);
        ctx.lineTo(w*0.15, -h*0.15);
        ctx.stroke();
      }
      
      // Mouth
      ctx.strokeStyle = '#3e2723';
      ctx.lineWidth = 2;
      if(hpRatio < 0.3) {
        // Grimace
        ctx.beginPath();
        ctx.moveTo(-w*0.1, h*0.08);
        ctx.lineTo(w*0.1, h*0.08);
        ctx.stroke();
      } else {
        // Slight frown
        ctx.beginPath();
        ctx.arc(0, h*0.15, w*0.08, Math.PI + 0.3, -0.3);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    // CHERRY BOMB - angry red cherries
    function draw2DCherryBomb(ctx, p, x, y, w, h, now) {
      const timeToExplode = p.explodeAt ? p.explodeAt - now : 99999;
      const shake = timeToExplode < 400 ? Math.sin(now/20) * (1 - timeToExplode/400) * 6 : 0;
      const pulse = 1 + (timeToExplode < 500 ? (1 - timeToExplode/500) * 0.15 : 0);
      const bob = Math.sin(now/150 + p.col)*5;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if ((typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) && typeof p.row === 'number' && p.row < 2) yShift = 18;
      ctx.translate(x + shake, y + bob + yShift);
      ctx.scale(p.scale * pulse, p.scale * pulse);
      
      // Glow when about to explode
      if(timeToExplode < 500) {
        const intensity = (1 - timeToExplode/500) * 0.6;
        const glowSize = w*0.5 + Math.sin(now/50)*w*0.1;
        const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        glow.addColorStop(0, `rgba(255,82,82,${intensity})`);
        glow.addColorStop(1, 'rgba(255,0,0,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Stem
      ctx.strokeStyle = '#33691e';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-w*0.1, -h*0.25);
      ctx.quadraticCurveTo(0, -h*0.4, w*0.1, -h*0.25);
      ctx.stroke();
      
      // Leaf
      ctx.fillStyle = '#558b2f';
      ctx.beginPath();
      ctx.ellipse(0, -h*0.35, w*0.12, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      

      // --- Left cherry (angry face) ---
      ctx.save();
      ctx.translate(-w*0.15, 0);
      ctx.fillStyle = '#d32f2f';
      ctx.beginPath(); ctx.arc(0, 0, w*0.18, 0, Math.PI*2); ctx.fill();
      ctx.save(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(-w*0.05, -h*0.08, w*0.06, h*0.03, -0.5, 0, Math.PI*2); ctx.fill(); ctx.restore();
      // Máº¯t to, trÃ²ng nhá», sÃ¡t nhau
      for(let i=0;i<2;i++){
        const ex = -w*0.045 + i*w*0.055;
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(ex, -h*0.018, w*0.028, h*0.028, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.ellipse(ex, -h*0.018, w*0.011, h*0.011, 0, 0, Math.PI*2); ctx.fill();
      }
      // LÃ´ng mÃ y dÃ y, nhÃ­u, chÃ©o xuá»‘ng sÃ¡t máº¯t
      ctx.strokeStyle = '#7f1010'; ctx.lineWidth = 3.2;
      ctx.beginPath(); ctx.moveTo(-w*0.07, -h*0.045); ctx.lineTo(-w*0.015, -h*0.03); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w*0.015, -h*0.03); ctx.lineTo(w*0.06, -h*0.045); ctx.stroke();
      // Miá»‡ng cong xuá»‘ng, rá»™ng, kiá»ƒu gáº§m gá»«
      ctx.save(); ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 3.2;
      ctx.beginPath(); ctx.moveTo(-w*0.06, h*0.07); ctx.quadraticCurveTo(0, h*0.13, w*0.06, h*0.07); ctx.stroke();
      // RÄƒng tráº¯ng (tÃ¹y chá»n)
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(-w*0.03, h*0.1); ctx.lineTo(-w*0.01, h*0.1); ctx.moveTo(0.01, h*0.1); ctx.lineTo(0.03, h*0.1); ctx.stroke();
      ctx.restore();
      ctx.restore();

      // --- Right cherry (angry face) ---
      ctx.save();
      ctx.translate(w*0.15, 0);
      ctx.fillStyle = '#d32f2f';
      ctx.beginPath(); ctx.arc(0, 0, w*0.18, 0, Math.PI*2); ctx.fill();
      ctx.save(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(w*0.05, -h*0.08, w*0.06, h*0.03, 0.5, 0, Math.PI*2); ctx.fill(); ctx.restore();
      for(let i=0;i<2;i++){
        const ex = -w*0.015 + i*w*0.055;
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(ex, -h*0.018, w*0.028, h*0.028, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.ellipse(ex, -h*0.018, w*0.011, h*0.011, 0, 0, Math.PI*2); ctx.fill();
      }
      ctx.strokeStyle = '#7f1010'; ctx.lineWidth = 3.2;
      ctx.beginPath(); ctx.moveTo(-w*0.04, -h*0.045); ctx.lineTo(w*0.01, -h*0.03); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w*0.04, -h*0.03); ctx.lineTo(w*0.07, -h*0.045); ctx.stroke();
      ctx.save(); ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 3.2;
      ctx.beginPath(); ctx.moveTo(-w*0.06, h*0.07); ctx.quadraticCurveTo(0, h*0.13, w*0.06, h*0.07); ctx.stroke();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(-w*0.03, h*0.1); ctx.lineTo(-w*0.01, h*0.1); ctx.moveTo(0.01, h*0.1); ctx.lineTo(0.03, h*0.1); ctx.stroke();
      ctx.restore();
      ctx.restore();

      // Extra: fiery sparks between cherries
      for(let i=0;i<8;i++){
        const ang = Math.PI/2 + (i/8)*Math.PI;
        const rx = Math.cos(ang)*w*0.13;
        const ry = Math.sin(ang)*h*0.09;
        ctx.save();
        ctx.globalAlpha = 0.5 + 0.5*Math.sin(now/80 + i);
        ctx.fillStyle = `rgba(255,60,0,${0.7-Math.abs(Math.sin(now/80+i))*0.3})`;
        ctx.beginPath(); ctx.arc(rx, ry, 2.2+Math.abs(Math.sin(now/80+i))*1.2, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
      
      ctx.restore();
    }
    
    // ICE PEA - frozen peashooter variant
    function draw2DIcePea(ctx, p, x, y, w, h, now) {
      const bob = Math.sin(now/400 + p.col)*2;
      const recoil = (p.lastShoot && now - p.lastShoot < 180) ? 8 * (1 - (now - p.lastShoot)/180) : 0;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if ((typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) && typeof p.row === 'number' && p.row < 2) yShift = 18;
      ctx.translate(x + recoil, y + bob + yShift);
      ctx.scale(p.scale, p.scale);
      
      // Frost particles
      if(Math.random() < 0.05) {
        spawnPlantParticles(x + w*0.3, y - h*0.1, '#b3e5fc', 2);
      }
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(0, h*0.4, w*0.25, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Stem (icy)
      ctx.fillStyle = '#4dd0e1';
      ctx.beginPath();
      ctx.moveTo(-w*0.05, h*0.05);
      ctx.quadraticCurveTo(-w*0.08, h*0.2, -w*0.04, h*0.38);
      ctx.lineTo(w*0.04, h*0.38);
      ctx.quadraticCurveTo(w*0.08, h*0.2, w*0.05, h*0.05);
      ctx.fill();
      
      // Ice leaves
      ctx.fillStyle = '#80deea';
      ctx.beginPath();
      ctx.ellipse(-w*0.15, h*0.2, w*0.12, h*0.05, -0.6, 0, Math.PI*2);
      ctx.fill();
      
      // Head body (icy blue)
      const headGrd = ctx.createRadialGradient(-w*0.05, -h*0.12, 0, 0, -h*0.05, w*0.3);
      headGrd.addColorStop(0, '#e0f7fa');
      headGrd.addColorStop(0.5, '#4dd0e1');
      headGrd.addColorStop(1, '#0097a7');
      ctx.fillStyle = headGrd;
      ctx.beginPath();
      ctx.ellipse(0, -h*0.05, w*0.25, h*0.2, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Ice crystals on head
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      for(let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(-w*0.15 + i*w*0.1, -h*0.2);
        ctx.lineTo(-w*0.12 + i*w*0.1, -h*0.28);
        ctx.lineTo(-w*0.09 + i*w*0.1, -h*0.2);
        ctx.fill();
      }
      
      // Mouth tube
      ctx.fillStyle = '#00838f';
      ctx.beginPath();
      ctx.ellipse(w*0.28, -h*0.05, w*0.12, h*0.08, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#006064';
      ctx.beginPath();
      ctx.ellipse(w*0.3, -h*0.05, w*0.08, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-w*0.08, -h*0.1, w*0.06, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.05, -h*0.1, w*0.055, h*0.048, 0, 0, Math.PI*2);
      ctx.fill();
      // Blue pupils
      ctx.fillStyle = '#0277bd';
      ctx.beginPath();
      ctx.arc(-w*0.06, -h*0.1, w*0.025, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.06, -h*0.1, w*0.022, 0, Math.PI*2);
      ctx.fill();
      
      // Frost aura
      const frostGlow = ctx.createRadialGradient(0, -h*0.05, w*0.1, 0, -h*0.05, w*0.4);
      frostGlow.addColorStop(0, 'rgba(77,208,225,0.2)');
      frostGlow.addColorStop(1, 'rgba(77,208,225,0)');
      ctx.fillStyle = frostGlow;
      ctx.beginPath();
      ctx.arc(0, -h*0.05, w*0.4, 0, Math.PI*2);
      ctx.fill();
      
      // Muzzle flash
      if(recoil > 0) {
        ctx.fillStyle = `rgba(79,195,247,${0.8 * recoil/8})`;
        ctx.beginPath();
        ctx.arc(w*0.4, -h*0.05, 8 + recoil, 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    // HYPNO-SHROOM - swirly hypnotic mushroom
    function draw2DHypnoShroom(ctx, p, x, y, w, h, now) {
      const bob = Math.sin(now/350 + p.col)*3;
      const sway = Math.sin(now/500)*0.05;
      const spiralPhase = now/300;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if (typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) yShift = 18;
      ctx.translate(x, y + bob + yShift);
      ctx.rotate(sway);
      ctx.scale(p.scale, p.scale);
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, h*0.35, w*0.25, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Stem
      ctx.fillStyle = '#e1bee7';
      ctx.beginPath();
      ctx.moveTo(-w*0.06, h*0.1);
      ctx.quadraticCurveTo(-w*0.08, h*0.25, -w*0.05, h*0.38);
      ctx.lineTo(w*0.05, h*0.38);
      ctx.quadraticCurveTo(w*0.08, h*0.25, w*0.06, h*0.1);
      ctx.fill();
      
      // Cap
      const capGrd = ctx.createRadialGradient(0, -h*0.1, 0, 0, -h*0.05, w*0.35);
      capGrd.addColorStop(0, '#ce93d8');
      capGrd.addColorStop(0.6, '#ab47bc');
      capGrd.addColorStop(1, '#7b1fa2');
      ctx.fillStyle = capGrd;
      ctx.beginPath();
      ctx.ellipse(0, -h*0.05, w*0.32, h*0.2, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Hypnotic spirals on cap
      ctx.strokeStyle = '#4a148c';
      ctx.lineWidth = 2;
      for(let s = 0; s < 2; s++) {
        ctx.beginPath();
        for(let i = 0; i < 20; i++) {
          const angle = spiralPhase + i * 0.3 + s * Math.PI;
          const r = w*0.05 + i * w*0.012;
          const sx = Math.cos(angle) * r;
          const sy = Math.sin(angle) * r * 0.6 - h*0.05;
          if(i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
      
      // Eyes (swirly)
      ctx.save();
      ctx.translate(-w*0.1, -h*0.08);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(0, 0, w*0.06, 0, Math.PI*2);
      ctx.fill();
      // Spiral pupil
      ctx.strokeStyle = '#4a148c';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for(let i = 0; i < 12; i++) {
        const angle = spiralPhase*2 + i * 0.5;
        const r = i * w*0.004;
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        if(i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.restore();
      
      ctx.save();
      ctx.translate(w*0.1, -h*0.08);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(0, 0, w*0.06, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#4a148c';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for(let i = 0; i < 12; i++) {
        const angle = -spiralPhase*2 + i * 0.5;
        const r = i * w*0.004;
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        if(i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.restore();
      
      // Mysterious smile
      ctx.strokeStyle = '#4a148c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, h*0.02, w*0.08, 0.2, Math.PI - 0.2);
      ctx.stroke();
      
      // Hypno aura
      const auraPhase = now/400;
      for(let r = 0; r < 3; r++) {
        const auraR = w*0.3 + r*w*0.1 + Math.sin(auraPhase + r)*w*0.05;
        ctx.strokeStyle = `rgba(156,39,176,${0.3 - r*0.1})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -h*0.05, auraR, 0, Math.PI*2);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    // Generic mushroom for night plants
    function draw2DMushroom(ctx, p, x, y, w, h, now, capColor1, capColor2, stemColor) {
      const bob = Math.sin(now/400 + p.col)*2;
      const sway = Math.sin(now/600)*0.03;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if ((typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) && typeof p.row === 'number' && p.row < 2) yShift = 18;
      ctx.translate(x, y + bob + yShift);
      ctx.rotate(sway);
      ctx.scale(p.scale, p.scale);
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, h*0.35, w*0.22, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Stem
      ctx.fillStyle = stemColor;
      ctx.beginPath();
      ctx.moveTo(-w*0.08, h*0.05);
      ctx.quadraticCurveTo(-w*0.1, h*0.2, -w*0.06, h*0.35);
      ctx.lineTo(w*0.06, h*0.35);
      ctx.quadraticCurveTo(w*0.1, h*0.2, w*0.08, h*0.05);
      ctx.fill();
      
      // Cap
      const capGrd = ctx.createRadialGradient(-w*0.05, -h*0.12, 0, 0, -h*0.05, w*0.3);
      capGrd.addColorStop(0, capColor1);
      capGrd.addColorStop(1, capColor2);
      ctx.fillStyle = capGrd;
      ctx.beginPath();
      ctx.ellipse(0, -h*0.05, w*0.28, h*0.18, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Spots on cap
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.beginPath();
      ctx.arc(-w*0.1, -h*0.12, w*0.04, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.08, -h*0.08, w*0.03, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.0, -h*0.15, w*0.025, 0, Math.PI*2);
      ctx.fill();

      // Special animated details for Ember and Lumen mushrooms
      try{
        if(p.type === 'embermush'){
          // ember charge glow based on fireAcc progress
          const charge = Math.min(1, (p.fireAcc||0) / 4500);
          // cap ember glow
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.4 + 0.6 * charge;
          const emberGrd = ctx.createRadialGradient(0, -h*0.08, 0, 0, -h*0.08, w*0.45);
          emberGrd.addColorStop(0, 'rgba(255,200,140,0.9)');
          emberGrd.addColorStop(0.5, 'rgba(255,120,60,0.6)');
          emberGrd.addColorStop(1, 'rgba(120,30,10,0)');
          ctx.fillStyle = emberGrd;
          ctx.beginPath(); ctx.ellipse(0, -h*0.08, w*0.36 * (1+0.2*charge), h*0.22 * (1+0.2*charge), 0, 0, Math.PI*2); ctx.fill();
          ctx.restore();

          // small ember particles orbiting cap
          const emberCount = 6;
          for(let i=0;i<emberCount;i++){
            const a = (i/emberCount) * Math.PI*2 + (now/400) * (0.5 + (i%2)*0.2);
            const r = w*0.32 + Math.sin(now/300 + i) * 4;
            const ex = Math.cos(a) * r, ey = -h*0.08 + Math.sin(a) * (h*0.06);
            const s = 2 + Math.abs(Math.sin(now/200 + i)) * 2 * (0.5 + charge);
            ctx.beginPath(); ctx.fillStyle = 'rgba(255,' + (160+Math.floor(80*charge)) + ',80,' + (0.6+0.4*charge) + ')'; ctx.arc(ex, ey, s, 0, Math.PI*2); ctx.fill();
          }
        }
        else if(p.type === 'lumenmush'){
          // soft halo glow
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          const halo = ctx.createRadialGradient(0, -h*0.08, 0, 0, -h*0.08, w*0.7);
          halo.addColorStop(0, 'rgba(180,235,255,0.9)');
          halo.addColorStop(0.4, 'rgba(160,225,255,0.55)');
          halo.addColorStop(1, 'rgba(120,200,255,0)');
          ctx.fillStyle = halo; ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.ellipse(0, -h*0.08, w*0.5, h*0.28, 0, 0, Math.PI*2); ctx.fill();
          ctx.restore();

          // floating plus signs (healing particles) - some timed, some on heal pulse
          const plusCount = 5;
          for(let i=0;i<plusCount;i++){
            const a = (i/plusCount) * Math.PI*2 + (now/800) * (i%2?1:-1);
            const rr = w*0.28 + Math.sin(now/500 + i) * 6;
            const px = Math.cos(a) * rr, py = -h*0.08 + Math.sin(a) * 6;
            ctx.save(); ctx.translate(px, py); ctx.rotate((now/500 + i)*0.2);
            ctx.fillStyle = 'rgba(200,250,255,0.85)';
            ctx.fillRect(-2, -6, 4, 12); ctx.fillRect(-6, -2, 12, 4);
            ctx.restore();
          }
        }
      }catch(e){}
      
      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-w*0.08, -h*0.02, w*0.05, h*0.04, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.08, -h*0.02, w*0.05, h*0.04, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(-w*0.07, -h*0.01, w*0.025, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.09, -h*0.01, w*0.025, 0, Math.PI*2);
      ctx.fill();
      
      ctx.restore();
    }
    
    // GATLING PEA - multi-barreled
    function draw2DGatling(ctx, p, x, y, w, h, now) {
      const bob = Math.sin(now/400 + p.col)*2;
      const recoil = (p.lastShoot && now - p.lastShoot < 180) ? 6 * (1 - (now - p.lastShoot)/180) : 0;
      const barrelSpin = now/100;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if (typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) yShift = 18;
      ctx.translate(x + recoil, y + bob + yShift);
      ctx.scale(p.scale, p.scale);
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(0, h*0.4, w*0.28, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Stem
      ctx.fillStyle = '#2e7d32';
      ctx.beginPath();
      ctx.moveTo(-w*0.06, h*0.08);
      ctx.quadraticCurveTo(-w*0.1, h*0.22, -w*0.05, h*0.38);
      ctx.lineTo(w*0.05, h*0.38);
      ctx.quadraticCurveTo(w*0.1, h*0.22, w*0.06, h*0.08);
      ctx.fill();
      
      // Helmet
      ctx.fillStyle = '#5d4037';
      ctx.beginPath();
      ctx.arc(0, -h*0.18, w*0.2, Math.PI, 0);
      ctx.fill();
      ctx.fillStyle = '#4e342e';
      ctx.fillRect(-w*0.2, -h*0.18, w*0.4, h*0.05);
      
      // Head body
      const headGrd = ctx.createRadialGradient(-w*0.05, -h*0.08, 0, 0, -h*0.02, w*0.28);
      headGrd.addColorStop(0, '#81c784');
      headGrd.addColorStop(0.6, '#4caf50');
      headGrd.addColorStop(1, '#2e7d32');
      ctx.fillStyle = headGrd;
      ctx.beginPath();
      ctx.ellipse(0, -h*0.02, w*0.26, h*0.18, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Gatling barrels (4 rotating)
      ctx.save();
      ctx.translate(w*0.25, -h*0.02);
      ctx.rotate(barrelSpin);
      ctx.fillStyle = '#388e3c';
      for(let b = 0; b < 4; b++) {
        ctx.save();
        ctx.rotate(b * Math.PI/2);
        ctx.fillRect(-w*0.03, -h*0.12, w*0.06, h*0.1);
        ctx.fillStyle = '#2e7d32';
        ctx.beginPath();
        ctx.arc(0, -h*0.12, w*0.04, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#388e3c';
        ctx.restore();
      }
      // Center hub
      ctx.fillStyle = '#1b5e20';
      ctx.beginPath();
      ctx.arc(0, 0, w*0.06, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      // Eyes (determined)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-w*0.1, -h*0.06, w*0.06, h*0.05, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(-w*0.08, -h*0.05, w*0.03, 0, Math.PI*2);
      ctx.fill();
      
      // Muzzle flash
      if(recoil > 0) {
        ctx.fillStyle = `rgba(197,225,165,${0.9 * recoil/6})`;
        for(let f = 0; f < 4; f++) {
          const angle = barrelSpin + f * Math.PI/2;
          ctx.beginPath();
          ctx.arc(w*0.4 + Math.cos(angle)*w*0.08, -h*0.02 + Math.sin(angle)*h*0.08, 5 + recoil, 0, Math.PI*2);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }
    
    // SQUASH - angry and ready to jump
    function draw2DSquash(ctx, p, x, y, w, h, now) {
      const jumpPhase = p.jumping ? p.jumpPhase : 0;
      const bob = p.jumping ? 0 : Math.sin(now/300 + p.col)*3;
      const angry = p.targetZ ? 1 : 0;
      
      ctx.save();
      // Apply extra vertical shift ONLY for in-game plants (not toolbar)
      let yShift = 0;
      if (typeof p.isToolbarIcon === 'undefined' || !p.isToolbarIcon) yShift = 18;
      ctx.translate(x, y + bob + yShift);
      if(p.jumping) ctx.rotate(jumpPhase * 0.5);
      ctx.scale(p.scale, p.scale);
      
      // Shadow
      if(!p.jumping) {
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.ellipse(0, h*0.35, w*0.3, h*0.06, 0, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Body
      const bodyGrd = ctx.createRadialGradient(-w*0.05, -h*0.05, 0, 0, 0, w*0.35);
      bodyGrd.addColorStop(0, '#a5d6a7');
      bodyGrd.addColorStop(0.6, '#66bb6a');
      bodyGrd.addColorStop(1, '#388e3c');
      ctx.fillStyle = bodyGrd;
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.32, h*0.28, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Stem
      ctx.fillStyle = '#33691e';
      ctx.beginPath();
      ctx.moveTo(-w*0.03, -h*0.25);
      ctx.quadraticCurveTo(0, -h*0.35, w*0.05, -h*0.28);
      ctx.lineTo(w*0.02, -h*0.25);
      ctx.quadraticCurveTo(0, -h*0.3, -w*0.01, -h*0.25);
      ctx.fill();
      
      // Leaves
      ctx.fillStyle = '#43a047';
      ctx.beginPath();
      ctx.ellipse(-w*0.12, -h*0.22, w*0.08, h*0.04, -0.8, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.1, -h*0.2, w*0.07, h*0.035, 0.6, 0, Math.PI*2);
      ctx.fill();
      
      // Eyes (angry when targeting)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(-w*0.12, -h*0.05, w*0.08, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(w*0.12, -h*0.05, w*0.08, h*0.06, 0, 0, Math.PI*2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = angry ? '#d32f2f' : '#1a1a1a';
      ctx.beginPath();
      ctx.arc(-w*0.1, -h*0.04, w*0.04, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w*0.14, -h*0.04, w*0.04, 0, Math.PI*2);
      ctx.fill();
      
      // Angry eyebrows
      ctx.strokeStyle = '#2e7d32';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-w*0.2, -h*0.15);
      ctx.lineTo(-w*0.05, -h*0.1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w*0.05, -h*0.1);
      ctx.lineTo(w*0.2, -h*0.15);
      ctx.stroke();
      
      // Frown
      ctx.strokeStyle = '#1b5e20';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, h*0.15, w*0.1, Math.PI + 0.3, -0.3);
      ctx.stroke();
      
      ctx.restore();
    }

    for(const p of plants){ 
      let x=(p.col+0.5)*CW, y=(p.row+0.5)*CH - 8 + (p.row < 2 ? PLANT_ZOMBIE_SHIFT : 0); // Nudge top-rows down so they're visible
      const img = spriteImages[p.type] || spriteImages.sunflower; 
      const w=CW*0.85, h=CH*1.0; // Bigger plants to fill cells nicely
      const now = performance.now(); 
      // Heal glow overlay when plant was recently healed
      if(p._healPulse){
        const ht = now - p._healPulse;
        if(ht < 700){
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.6 * (1 - ht / 700);
          ctx.fillStyle = '#b3e5fc';
          const scale = 1 + ht / 700;
          ctx.beginPath(); ctx.ellipse(x, y, w * 0.55 * scale, h * 0.38 * scale, 0, 0, Math.PI*2); ctx.fill();
          ctx.restore();
        } else { try{ delete p._healPulse; }catch(e){} }
      }
      
      // CLOVER - special spinning propeller animation (side view - flattened)
      if(p.type === 'clover'){
        ctx.save();
        ctx.translate(x, y + 15); // Move down a bit since flattened
        
        // Flatten for side view angle
        ctx.scale(1, 0.4); // Compress vertically for side view
        
        // Draw shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(0, h*0.6, w*0.45, h*0.1, 0, 0, Math.PI*2);
        ctx.fill();
        
        // Stem (doesn't rotate) - shorter since side view
        ctx.fillStyle = '#388e3c';
        ctx.fillRect(-5, 15, 10, 35);
        
        // Rotating propeller (4 leaves)
        const spinSpeed = now / 100; // Faster spinning for propeller effect
        ctx.save();
        ctx.rotate(spinSpeed);
        
        // Draw 4 heart-shaped leaves
        for(let i = 0; i < 4; i++){
          ctx.save();
          ctx.rotate(i * Math.PI / 2);
          
          // Leaf gradient
          const leafGrd = ctx.createRadialGradient(-15, -25, 0, -10, -20, 30);
          leafGrd.addColorStop(0, '#c8e6c9');
          leafGrd.addColorStop(0.5, '#66bb6a');
          leafGrd.addColorStop(1, '#2e7d32');
          ctx.fillStyle = leafGrd;
          
          // Heart-shaped leaf (bigger for visibility)
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.bezierCurveTo(-15, -25, -30, -28, -25, -45);
          ctx.bezierCurveTo(-18, -58, 0, -52, 0, -40);
          ctx.bezierCurveTo(0, -52, 18, -58, 25, -45);
          ctx.bezierCurveTo(30, -28, 15, -25, 0, -8);
          ctx.fill();
          
          // Leaf vein
          ctx.strokeStyle = 'rgba(67, 160, 71, 0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(0, -38);
          ctx.stroke();
          
          ctx.restore();
        }
        ctx.restore();
        
        // Center hub
        ctx.fillStyle = '#4caf50';
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#81c784';
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Lucky "4" symbol
        ctx.fillStyle = '#1b5e20';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('4', 0, 1);
        
        // Sparkle effects
        const sparklePhase = now / 500;
        ctx.fillStyle = `rgba(255,235,59,${0.5 + Math.sin(sparklePhase)*0.3})`;
        for(let i = 0; i < 4; i++){
          const angle = sparklePhase + i * Math.PI / 2;
          const sparkX = Math.cos(angle) * 35;
          const sparkY = Math.sin(angle) * 35;
          ctx.beginPath();
          ctx.arc(sparkX, sparkY, 2 + Math.sin(sparklePhase + i)*1, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore(); // RESTORE clover scale(1, 0.4) FIRST before drawing top plant
        
        // Draw top plant if exists using 2D functions - OUTSIDE of clover scale context
        if(p.topPlant){
          ctx.save();
          ctx.translate(x, y - CH*0.5); // Position above clover; center the top-plant over the same cell
          // Draw plant at FULL normal size above clover (same as regular plants)
          const topW = CW * 0.85;
          const topH = CH * 1.0;
          const topBob = Math.sin(now/400 + p.col)*2;
          const topX = 0;
          const topY = topBob; // Just bob animation, position handled by translate
          // Create a fake plant object for drawing with proper lastShoot for animation
          const fakePlant = { 
            ...p, 
            type: p.topPlant, 
            scale: 1, 
            lastShoot: p.topLastShoot || 0,
            col: p.col,
            row: p.row,
            id: p.id
          };
          // Draw using 2D functions based on plant type
          switch(p.topPlant) {
            case 'sunflower':
              draw2DSunflower(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'peashooter':
              draw2DPeashooter(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'wallnut':
              draw2DWallnut(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'cherry':
              draw2DCherryBomb(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'icepea':
              draw2DIcePea(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'hypnoshroom':
              draw2DHypnoShroom(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'gatling':
              draw2DGatling(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'squash':
              draw2DSquash(ctx, fakePlant, topX, topY, topW, topH, now);
              break;
            case 'puffshroom':
              draw2DMushroom(ctx, fakePlant, topX, topY, topW, topH, now, '#a1887f', '#6d4c41', '#d7ccc8');
              break;
            case 'sunshroom':
              draw2DMushroom(ctx, fakePlant, topX, topY, topW, topH, now, '#ffcc80', '#ff9800', '#fff3e0');
              break;
            case 'fumeshroom':
              draw2DMushroom(ctx, fakePlant, topX, topY, topW, topH, now, '#90a4ae', '#546e7a', '#cfd8dc');
              break;
            case 'scaredyshroom':
              draw2DMushroom(ctx, fakePlant, topX, topY, topW, topH, now, '#fff59d', '#fdd835', '#fffde7');
              break;
            case 'strawshroom':
              draw2DMushroom(ctx, fakePlant, topX, topY, topW, topH, now, '#ffab91', '#ff5722', '#fbe9e7');
              break;
            case 'embermush':
              draw2DMushroom(ctx, fakePlant, topX, topY, topW, topH, now, '#ff8a65', '#d84315', '#ffccbc');
              break;
            case 'lumenmush':
              draw2DMushroom(ctx, fakePlant, topX, topY, topW, topH, now, '#b3e5fc', '#81d4fa', '#e1f5fe');
              break;
            default:
              // Fallback to sprite
              const topImg = spriteImages[p.topPlant] || spriteImages.sunflower;
              ctx.drawImage(topImg, -topW/2, -topH/2 + topBob, topW, topH);
          }
          ctx.restore();
        }
        
        // Draw clover health bar below the clover (visible for top rows only)
        {
          const barW = w * 0.7, barH = 8;
          // clover was translated and scaled earlier; use original x,y (center) and draw under foot
          const barX = x - barW / 2;
          const barY = y + h * 0.45; // below the clover
          // background / border
          ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
          const hpPct = Math.max(0, p.hp) / (p.maxHp || 20);
          const hpGrd = ctx.createLinearGradient(barX, 0, barX + barW, 0);
          hpGrd.addColorStop(0, hpPct > 0.5 ? '#2ecc71' : (hpPct > 0.25 ? '#ffb74d' : '#ff3b3b'));
          hpGrd.addColorStop(1, hpPct > 0.5 ? '#27ae60' : (hpPct > 0.25 ? '#ff9800' : '#e53935'));
          ctx.fillStyle = hpGrd; ctx.fillRect(barX, barY, barW * hpPct, barH);
        }
        continue; // Skip normal plant rendering for clover
      }
      
      // SQUASH jumping animation
      if(p.type === 'squash' && p.jumping && p.targetZ){
        const t = p.jumpPhase;
        const targetX = p.targetZ.x * CW;
        const targetY = (p.targetZ.row + 0.5) * CH;
        // Move towards target with arc
        x = p.startCol*CW + CW*0.5 + (targetX - (p.startCol*CW + CW*0.5)) * t;
        y = p.startRow*CH + CH*0.5 + (targetY - (p.startRow*CH + CH*0.5)) * t - 100 * Math.sin(t * Math.PI);
        // Draw shadow on ground
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(x, targetY + h*0.3, w*0.4 * (1-t*0.5), h*0.1, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      
      // === USE 2D DRAWING FUNCTIONS ===
      switch(p.type) {
        case 'sunflower':
          draw2DSunflower(ctx, p, x, y, w, h, now);
          break;
        case 'peashooter':
          draw2DPeashooter(ctx, p, x, y, w, h, now);
          break;
        case 'wallnut':
          draw2DWallnut(ctx, p, x, y, w, h, now);
          break;
        case 'cherry':
          draw2DCherryBomb(ctx, p, x, y, w, h, now);
          break;
        case 'icepea':
          draw2DIcePea(ctx, p, x, y, w, h, now);
          break;
        case 'hypnoshroom':
          draw2DHypnoShroom(ctx, p, x, y, w, h, now);
          break;
        case 'gatling':
          draw2DGatling(ctx, p, x, y, w, h, now);
          break;
        case 'squash':
          draw2DSquash(ctx, p, x, y, w, h, now);
          break;
        case 'puffshroom':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#a1887f', '#6d4c41', '#d7ccc8');
          break;
        case 'embermush':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#ff8a65', '#d84315', '#ffccbc');
          break;
        case 'lumenmush':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#b3e5fc', '#81d4fa', '#e1f5fe');
          break;
        case 'embermush':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#ff8a65', '#d84315', '#ffccbc');
          break;
        case 'lumenmush':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#b3e5fc', '#81d4fa', '#e1f5fe');
          break;
          case 'sunpea':
            // Sunpea: full sun replaces head+body; stalk is yellow
            {
              const sunpeaBob = Math.sin(now/400 + p.col)*2;
              const recoil = (p.lastShoot && now - p.lastShoot < 180) ? 8 * (1 - (now - p.lastShoot)/180) : 0;
              ctx.save();
              ctx.translate(x + recoil, y + sunpeaBob - h*0.05);
              ctx.scale(p.scale, p.scale);

              // Shadow
              ctx.fillStyle = 'rgba(0,0,0,0.22)';
              ctx.beginPath(); ctx.ellipse(0, h*0.38, w*0.22, h*0.05, 0, 0, Math.PI*2); ctx.fill();

              // Yellow stalk (rounded)
              const stalkX = -w*0.04;
              const stalkW = w*0.08;
              const stalkH = h*0.42;
              const stalkGrd = ctx.createLinearGradient(stalkX, 0, stalkX+stalkW, 0);
              stalkGrd.addColorStop(0, '#fff59d'); stalkGrd.addColorStop(0.5, '#ffeb3b'); stalkGrd.addColorStop(1, '#ffc107');
              ctx.fillStyle = stalkGrd;
              ctx.beginPath(); ctx.roundRect(stalkX, h*0.02, stalkW, stalkH, 6); ctx.fill();
              // subtle stalk highlight
              ctx.fillStyle = 'rgba(255,255,255,0.18)'; ctx.fillRect(stalkX + stalkW*0.18, h*0.06, stalkW*0.14, stalkH*0.06);

              // Sun head (centered above stalk)
              const sr = w*0.22;
              const sunY = -h*0.12;
              const sgr = ctx.createRadialGradient(0, sunY, sr*0.15, 0, sunY, sr*1.1);
              sgr.addColorStop(0, '#fff9c4'); sgr.addColorStop(0.35, '#fff176'); sgr.addColorStop(0.8, '#ffd54f'); sgr.addColorStop(1, '#ff8f00');
              // sun core
              ctx.fillStyle = sgr; ctx.beginPath(); ctx.arc(0, sunY, sr, 0, Math.PI*2); ctx.fill();

              // Sun rays
              ctx.save();
              ctx.translate(0, sunY);
              ctx.rotate((now/1000) % (Math.PI*2) * 0.05);
              ctx.fillStyle = 'rgba(255,193,7,0.85)';
              for(let r=0;r<10;r++){
                const ang = (r/10)*Math.PI*2;
                const rx = Math.cos(ang) * (sr + 6);
                const ry = Math.sin(ang) * (sr + 6);
                ctx.beginPath(); ctx.ellipse(rx, ry, 6, 14, ang, 0, Math.PI*2); ctx.fill();
              }
              ctx.restore();

              // Face: eyes
              ctx.fillStyle = '#000';
              ctx.beginPath(); ctx.arc(-sr*0.22, sunY - sr*0.06, sr*0.11, 0, Math.PI*2); ctx.fill();
              ctx.beginPath(); ctx.arc(sr*0.18, sunY - sr*0.06, sr*0.11, 0, Math.PI*2); ctx.fill();
              // Mouth (animated when shooting)
              const mouthOpen = (p.lastShoot && now - p.lastShoot < 180) ? 1 : 0;
              ctx.fillStyle = '#b71c1c';
              ctx.beginPath(); ctx.ellipse(0, sunY + sr*0.18, sr*0.3, sr*0.12 + mouthOpen*sr*0.12, 0, 0, Math.PI*2); ctx.fill();

              ctx.restore();
            }
            break;
          case 'minibomb':
            // Draw cluster of small mines inside tile
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(p.scale, p.scale);
            const seed = p.id || 0;
            const mines = p.mines || [];
            for(let mi=0; mi<mines.length; mi++){
              const ang = (mi/Math.max(1,mines.length)) * Math.PI*2 + (seed%7)*0.23;
              const rx = Math.cos(ang) * w*0.18 + (mi%2? -6:6);
              const ry = Math.sin(ang) * h*0.12 + (mi%3? 4:-4);
              ctx.fillStyle = '#37474f'; ctx.beginPath(); ctx.arc(rx, ry, 8, 0, Math.PI*2); ctx.fill();
              ctx.fillStyle = '#ff7043'; ctx.beginPath(); ctx.arc(rx-3, ry-3, 3,0,Math.PI*2); ctx.fill();
            }
            ctx.restore();
            break;
        case 'sunshroom':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#ffcc80', '#ff9800', '#fff3e0');
          break;
        case 'fumeshroom':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#90a4ae', '#546e7a', '#cfd8dc');
          break;
        case 'scaredyshroom':
          ctx.save();
          if(p.hiding) {
            ctx.globalAlpha = 0.5;
            ctx.scale(0.5, 0.5);
            ctx.translate(x, y);
          }
          draw2DMushroom(ctx, p, p.hiding ? 0 : x, p.hiding ? 0 : y, w, h, now, '#fff59d', '#fdd835', '#fffde7');
          ctx.restore();
          break;
        case 'strawshroom':
          draw2DMushroom(ctx, p, x, y, w, h, now, '#ffab91', '#ff5722', '#fbe9e7');
          break;
        default:
          // Fallback to sprite-based rendering for unknown types
          const img = spriteImages[p.type] || spriteImages.sunflower;
          const bob = Math.sin(now/400 + p.col)*3;
          ctx.save();
          ctx.translate(x, y + bob);
          ctx.scale(p.scale, p.scale);
          ctx.drawImage(img, -w/2, -h/2, w, h);
          ctx.restore();
      }
      
      // Health bar: show under-foot for non-clover plants/mushrooms on rows >= 2
      // Exception: minibomb patches should not display a health bar (they detonate on contact)
      if(p.type !== 'clover' && p.row >= 2 && p.type !== 'minibomb'){
        const hpPct = Math.max(0, p.hp / (p.maxHp || 12));
        const barW = w * 0.7, barH = 8, barX = x - barW / 2, barY = y + h * 0.45;
        // darker background/border to make the bar pop
        ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
        const hpGrd = ctx.createLinearGradient(barX, 0, barX + barW, 0);
        hpGrd.addColorStop(0, hpPct > 0.5 ? '#2ecc71' : (hpPct > 0.25 ? '#ffb74d' : '#ff3b3b'));
        hpGrd.addColorStop(1, hpPct > 0.5 ? '#27ae60' : (hpPct > 0.25 ? '#ff9800' : '#e53935'));
        ctx.fillStyle = hpGrd; ctx.fillRect(barX, barY, barW * hpPct, barH);
        // subtle highlight edge
        ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barW, barH);
      }
    }

    for(const b of bullets){
      const yOff = (b.yOffset || 0) * CH;
      // Trail
      for(const t of b.trail){
        ctx.globalAlpha = 0.18;
        if(b.type === 'cannonpall'){
          ctx.fillStyle = '#333';
          ctx.beginPath(); ctx.arc(t.x*CW, (t.y+0.5)*CH + yOff, 8, 0, Math.PI*2); ctx.fill();
        } else {
          ctx.fillStyle = b.slow? '#bfefff' : '#dfffdc';
          ctx.beginPath(); ctx.arc(t.x*CW, (t.y+0.5)*CH + yOff, 6, 0, Math.PI*2); ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
      // Main projectile
      if(b.type === 'cannonpall'){
        // Cannonball look: solid black with subtle highlight
        ctx.fillStyle = '#0b0b0b';
        ctx.beginPath(); ctx.arc(b.x*CW, (b.row+0.5)*CH + yOff, 10, 0, Math.PI*2); ctx.fill();
        // highlight
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.beginPath(); ctx.ellipse(b.x*CW - 3, (b.row+0.5)*CH + yOff - 2, 4, 2.5, -0.6, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle = b.slow? '#9fe8ff' : '#e0ffd4';
        ctx.beginPath(); ctx.arc(b.x*CW, (b.row+0.5)*CH + yOff, 6, 0, Math.PI*2); ctx.fill();
      }
      // Sunshot visual (larger, reddish)
      if(b.type === 'sunshot'){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = '#ff5252';
        ctx.beginPath(); ctx.arc(b.x*CW, (b.row+0.5)*CH + yOff, 10, 0, Math.PI*2); ctx.fill();
        const sg = ctx.createRadialGradient(b.x*CW, (b.row+0.5)*CH + yOff, 0, b.x*CW, (b.row+0.5)*CH + yOff, 28);
        sg.addColorStop(0, 'rgba(255,120,120,0.45)'); sg.addColorStop(1, 'rgba(255,120,120,0)');
        ctx.fillStyle = sg; ctx.fillRect(b.x*CW-28, (b.row+0.5)*CH + yOff-28, 56, 56);
        ctx.restore();
      }
    }

    // Draw arcing spores from Straw-shroom
    if(window.spores){
      for(const s of window.spores){
        const t = s.phase;
        // Parabolic arc: x moves linearly, y arcs up then down
        const currentX = s.startX + (s.targetX - s.startX) * t;
        const arcHeight = 80; // pixels high at peak
        const currentY = s.startY + (s.targetY - s.startY) * t - arcHeight * Math.sin(t * Math.PI);
        // Draw spore
        ctx.save();
        ctx.fillStyle = '#ffb74d';
        ctx.strokeStyle = '#f57c00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(currentX, currentY, 8, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        // Highlight
        ctx.fillStyle = '#fff8e1';
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(currentX - 2, currentY - 2, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.restore();
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2D FLYING ZOMBIE FOR TOP 2 ROWS - Horizontal with wings
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function draw2DZombieSide(ctx, z, x, y, zw, zh, now, isDead) {
      const bossScale = z.boss ? 1.4 : 1;
      const hpRatio = z.hp / (z.maxHp || 14);
      
      // Animation - improved wing dynamics (asymmetric powerful downstroke,
      // staggered feather lag, and body reaction)
      const base = Math.sin(now / 80); // base oscillation
      const power = Math.sign(base) * Math.pow(Math.abs(base), 3); // emphasize downstroke
      const wingFlap = power * 0.9; // main rotation applied to wing roots
      const floatBob = Math.sin(now / 300) * 2 + Math.abs(power) * 3; // body bobs more on strong flaps
      
      // Colors
      let skinColor = '#6b7c5b';
      let skinDark = '#4a5c3b';
      let clothesColor = '#3a2820';
      let bloodColor = '#8b0000';
      let fleshColor = '#8b4a4a';
      let wingColor = '#2a2a3a';
      let wingInner = '#4a4a5a';
      
      if(z.bomb) {
        skinColor = '#5c6b4b';
        skinDark = '#3c4b2b';
        clothesColor = '#4a3020';
        bloodColor = '#ff4400';
        wingColor = '#3a2a1a';
        wingInner = '#5a4a3a';
      }
      if(z.armored) {
        skinColor = '#5a6c4b';
        skinDark = '#3a4c2b';
        clothesColor = '#2a2a2a';
      }
      if(z.boss) {
        skinColor = '#7b3a4c';
        skinDark = '#5b1a2c';
        clothesColor = '#1a0a0a';
        wingColor = '#1a0a1a';
        wingInner = '#3a1a2a';
      }
      if(z.hypnotized) {
        skinColor = '#8a5caa';
        skinDark = '#6a3c8a';
        wingColor = '#3a2a4a';
        wingInner = '#5a4a6a';
      }
      
      if(hpRatio < 0.5) {
        skinColor = '#5a6c4b';
        skinDark = '#3a4c2b';
      }
      
      ctx.save();
      ctx.translate(x, y + floatBob);
      
      const scale = bossScale * 0.7;
      
      // Rotate to be horizontal (flying position) - head pointing left
      ctx.rotate(-Math.PI / 2 + Math.sin(now/400) * 0.03);
      
      // Dead zombies fade
      if(isDead) {
        ctx.globalAlpha = 0.4;
        ctx.rotate(0.3);
      }
      
      // NO SHADOW for flying zombies
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // LUCIFER ZOMBIE WINGS - Dark fallen angel style
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      ctx.save();
      ctx.translate(0, -zh*0.02*scale);
      
      // Left wing (top when horizontal) - Lucifer style with feathers
      ctx.save();
      ctx.rotate(wingFlap + 0.2);
      
      // Wing base/arm bone
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 5*scale;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-zw*0.15*scale, -zh*0.15*scale, -zw*0.35*scale, -zh*0.25*scale);
      ctx.stroke();
      
      // Primary feathers (long, dark, tattered)
      const featherCount = 7;
      for(let f = 0; f < featherCount; f++) {
        const progress = f / (featherCount - 1);
        const baseX = -zw*0.08*scale - progress * zw*0.27*scale;
        const baseY = -zh*0.05*scale - progress * zh*0.2*scale;
        const featherLen = zh*0.25*scale + (1 - Math.abs(progress - 0.5) * 2) * zh*0.15*scale;
        // per-feather lag to create ripple: lag increases with progress
        const featherPhase = base - progress * 0.12;
        const featherPower = Math.sign(featherPhase) * Math.pow(Math.abs(featherPhase), 3);
        const featherAngle = -0.6 + featherPower * 0.9 * (1 - progress);

        ctx.save();
        ctx.translate(baseX, baseY);
        ctx.rotate(featherAngle);
        
        // Feather shaft
        ctx.strokeStyle = '#0a0a0a';
        ctx.lineWidth = 2*scale;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -featherLen);
        ctx.stroke();
        
        // Feather vanes (tattered, zombie-like)
        ctx.fillStyle = wingColor;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-zw*0.04*scale, -featherLen*0.3, -zw*0.05*scale, -featherLen*0.6);
        ctx.quadraticCurveTo(-zw*0.03*scale, -featherLen*0.8, 0, -featherLen);
        ctx.quadraticCurveTo(zw*0.025*scale, -featherLen*0.75, zw*0.035*scale, -featherLen*0.5);
        ctx.quadraticCurveTo(zw*0.03*scale, -featherLen*0.25, 0, 0);
        ctx.fill();
        
        // Tattered gaps in feather
        if(f % 2 === 0) {
          ctx.fillStyle = 'rgba(0,0,0,0)';
          ctx.globalCompositeOperation = 'destination-out';
          ctx.beginPath();
          ctx.ellipse(-zw*0.02*scale, -featherLen*0.4, zw*0.015*scale, featherLen*0.08, 0.3, 0, Math.PI*2);
          ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        }
        
        ctx.restore();
      }
      
      // Secondary feathers (shorter, more damaged)
      for(let f = 0; f < 4; f++) {
        const progress = f / 3;
        const baseX = -zw*0.05*scale - progress * zw*0.15*scale;
        const baseY = -zh*0.02*scale - progress * zh*0.08*scale;
        
        ctx.save();
        ctx.translate(baseX, baseY);
        ctx.rotate(-0.5 - progress * 0.3);
        
        ctx.fillStyle = wingInner;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-zw*0.02*scale, -zh*0.08*scale, 0, -zh*0.12*scale);
        ctx.quadraticCurveTo(zw*0.015*scale, -zh*0.06*scale, 0, 0);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Blood/decay on wing
      ctx.fillStyle = '#4a1a1a';
      ctx.beginPath();
      ctx.ellipse(-zw*0.2*scale, -zh*0.15*scale, zw*0.03*scale, zh*0.02*scale, 0.5, 0, Math.PI*2);
      ctx.fill();
      
      ctx.restore(); // Left wing
      
      // Right wing (bottom when horizontal) - Mirror of left
      ctx.save();
      ctx.rotate(-wingFlap - 0.2);
      
      // Wing base/arm bone
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 5*scale;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(zw*0.15*scale, zh*0.15*scale, zw*0.35*scale, zh*0.25*scale);
      ctx.stroke();
      
      // Primary feathers
      for(let f = 0; f < featherCount; f++) {
        const progress = f / (featherCount - 1);
        const baseX = zw*0.08*scale + progress * zw*0.27*scale;
        const baseY = zh*0.05*scale + progress * zh*0.2*scale;
        const featherLen = zh*0.25*scale + (1 - Math.abs(progress - 0.5) * 2) * zh*0.15*scale;
        const featherPhase = base - progress * 0.12;
        const featherPower = Math.sign(featherPhase) * Math.pow(Math.abs(featherPhase), 3);
        const featherAngle = 0.6 + featherPower * 0.9 * (1 - progress);

        ctx.save();
        ctx.translate(baseX, baseY);
        ctx.rotate(featherAngle);
        
        // Feather shaft
        ctx.strokeStyle = '#0a0a0a';
        ctx.lineWidth = 2*scale;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, featherLen);
        ctx.stroke();
        
        // Feather vanes
        ctx.fillStyle = wingColor;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(zw*0.04*scale, featherLen*0.3, zw*0.05*scale, featherLen*0.6);
        ctx.quadraticCurveTo(zw*0.03*scale, featherLen*0.8, 0, featherLen);
        ctx.quadraticCurveTo(-zw*0.025*scale, featherLen*0.75, -zw*0.035*scale, featherLen*0.5);
        ctx.quadraticCurveTo(-zw*0.03*scale, featherLen*0.25, 0, 0);
        ctx.fill();
        
        // Tattered gaps
        if(f % 2 === 1) {
          ctx.fillStyle = 'rgba(0,0,0,0)';
          ctx.globalCompositeOperation = 'destination-out';
          ctx.beginPath();
          ctx.ellipse(zw*0.02*scale, featherLen*0.5, zw*0.012*scale, featherLen*0.06, -0.3, 0, Math.PI*2);
          ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        }
        
        ctx.restore();
      }
      
      // Secondary feathers
      for(let f = 0; f < 4; f++) {
        const progress = f / 3;
        const baseX = zw*0.05*scale + progress * zw*0.15*scale;
        const baseY = zh*0.02*scale + progress * zh*0.08*scale;
        
        ctx.save();
        ctx.translate(baseX, baseY);
        ctx.rotate(0.5 + progress * 0.3);
        
        ctx.fillStyle = wingInner;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(zw*0.02*scale, zh*0.08*scale, 0, zh*0.12*scale);
        ctx.quadraticCurveTo(-zw*0.015*scale, zh*0.06*scale, 0, 0);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Blood/decay on wing
      ctx.fillStyle = '#4a1a1a';
      ctx.beginPath();
      ctx.ellipse(zw*0.25*scale, zh*0.18*scale, zw*0.025*scale, zh*0.018*scale, -0.4, 0, Math.PI*2);
      ctx.fill();
      
      ctx.restore(); // Right wing
      
      ctx.restore(); // Wings
      
      // === LEGS (static, dangling) ===
      // Back leg
      ctx.save();
      ctx.translate(zw*0.05*scale, zh*0.12*scale);
      ctx.rotate(0.2); // Static angle
      ctx.globalAlpha = isDead ? 0.35 : 0.7;
      ctx.fillStyle = clothesColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.05*scale, 0, zw*0.1*scale, zh*0.18*scale, 3*scale);
      ctx.fill();
      ctx.translate(0, zh*0.16*scale);
      ctx.rotate(0.3);
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.roundRect(-zw*0.04*scale, 0, zw*0.08*scale, zh*0.15*scale, 2*scale);
      ctx.fill();
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(0, zh*0.15*scale, zw*0.06*scale, zh*0.03*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      // Front leg
      ctx.save();
      ctx.translate(zw*0.02*scale, zh*0.12*scale);
      ctx.rotate(0.15); // Static angle
      ctx.globalAlpha = isDead ? 0.4 : 1;
      ctx.fillStyle = clothesColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.06*scale, 0, zw*0.12*scale, zh*0.2*scale, 3*scale);
      ctx.fill();
      ctx.translate(0, zh*0.18*scale);
      ctx.rotate(0.25);
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.05*scale, 0, zw*0.1*scale, zh*0.17*scale, 2*scale);
      ctx.fill();
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(0, zh*0.17*scale, zw*0.07*scale, zh*0.035*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      ctx.globalAlpha = isDead ? 0.4 : 1;
      
      // === TORSO ===
      ctx.fillStyle = clothesColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.09*scale, -zh*0.18*scale, zw*0.18*scale, zh*0.33*scale, 5*scale);
      ctx.fill();
      
      // Torn shirt showing flesh
      ctx.fillStyle = fleshColor;
      ctx.beginPath();
      ctx.ellipse(zw*0.03*scale, -zh*0.02*scale, zw*0.035*scale, zh*0.04*scale, 0.2, 0, Math.PI*2);
      ctx.fill();
      
      // === ARMS (static, reaching forward) ===
      // Back arm (curved downward)
      ctx.save();
      ctx.translate(zw*0.04*scale, zh*0.08*scale);
      ctx.rotate(0.8); // curve downward
      ctx.globalAlpha = isDead ? 0.3 : 0.6;
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.roundRect(-zw*0.04*scale, 0, zw*0.08*scale, zh*0.14*scale, 2*scale);
      ctx.fill();
      ctx.translate(0, zh*0.12*scale);
      ctx.rotate(0.3);
      ctx.beginPath();
      ctx.roundRect(-zw*0.035*scale, 0, zw*0.07*scale, zh*0.12*scale, 2*scale);
      ctx.fill();
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(0, zh*0.13*scale, zw*0.035*scale, zh*0.025*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      ctx.globalAlpha = isDead ? 0.4 : 1;

      // Front arm (curved downward)
      ctx.save();
      ctx.translate(-zw*0.01*scale, zh*0.08*scale);
      ctx.rotate(0.9); // curve downward
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.045*scale, 0, zw*0.09*scale, zh*0.15*scale, 2*scale);
      ctx.fill();
      ctx.fillStyle = clothesColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.05*scale, 0, zw*0.1*scale, zh*0.05*scale, 2*scale);
      ctx.fill();
      ctx.translate(0, zh*0.13*scale);
      ctx.rotate(0.4);
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.roundRect(-zw*0.04*scale, 0, zw*0.08*scale, zh*0.13*scale, 2*scale);
      ctx.fill();
      // Hand with claws
      ctx.translate(0, zh*0.12*scale);
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.ellipse(0, zh*0.015*scale, zw*0.04*scale, zh*0.03*scale, 0, 0, Math.PI*2);
      ctx.fill();
      // Clawed fingers
      for(let f = 0; f < 3; f++) {
        ctx.fillStyle = skinDark;
        ctx.save();
        ctx.translate(-zw*0.02*scale + f*zw*0.015*scale, zh*0.025*scale);
        ctx.rotate(-0.15 + f*0.12);
        ctx.beginPath();
        ctx.roundRect(-zw*0.01*scale, 0, zw*0.02*scale, zh*0.05*scale, 1*scale);
        ctx.fill();
        ctx.fillStyle = '#3a3a3a';
        ctx.beginPath();
        ctx.moveTo(-zw*0.006*scale, zh*0.045*scale);
        ctx.lineTo(0, zh*0.06*scale);
        ctx.lineTo(zw*0.006*scale, zh*0.045*scale);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();
      
      // === HEAD (side profile - facing forward/left in flying position) ===
      ctx.save();
      ctx.translate(0, -zh*0.24*scale);
      
      // Head shape - oval from side
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.ellipse(0, 0, zw*0.12*scale, zh*0.1*scale, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Back of head
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(zw*0.06*scale, -zh*0.015*scale, zw*0.07*scale, zh*0.08*scale, 0.15, 0, Math.PI*2);
      ctx.fill();
      
      // Hair
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.ellipse(zw*0.03*scale, -zh*0.08*scale, zw*0.08*scale, zh*0.04*scale, 0, 0, Math.PI*2);
      ctx.fill();
      // Messy strands
      for(let h = 0; h < 4; h++) {
        ctx.strokeStyle = '#0a0a0a';
        ctx.lineWidth = 1.5*scale;
        ctx.beginPath();
        ctx.moveTo(zw*0.03*scale, -zh*0.08*scale);
        const angle = -0.4 + h * 0.25;
        ctx.quadraticCurveTo(
          zw*0.05*scale + Math.cos(angle)*zw*0.06*scale, 
          -zh*0.12*scale + Math.sin(angle)*zh*0.04*scale,
          zw*0.07*scale + Math.cos(angle)*zw*0.05*scale, 
          -zh*0.06*scale + Math.sin(angle)*zh*0.03*scale
        );
        ctx.stroke();
      }
      
      // Ear
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.ellipse(zw*0.1*scale, 0, zw*0.025*scale, zh*0.035*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(zw*0.1*scale, 0, zw*0.015*scale, zh*0.02*scale, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Eye
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.ellipse(-zw*0.04*scale, -zh*0.012*scale, zw*0.038*scale, zh*0.028*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffffaa';
      ctx.beginPath();
      ctx.ellipse(-zw*0.04*scale, -zh*0.012*scale, zw*0.032*scale, zh*0.022*scale, 0, 0, Math.PI*2);
      ctx.fill();
      // Bloodshot
      ctx.strokeStyle = '#aa2222';
      ctx.lineWidth = 0.5*scale;
      for(let v = 0; v < 3; v++) {
        ctx.beginPath();
        ctx.moveTo(-zw*0.04*scale, -zh*0.012*scale);
        const vAngle = v * 1.5;
        ctx.lineTo(-zw*0.04*scale + Math.cos(vAngle)*zw*0.03*scale, -zh*0.012*scale + Math.sin(vAngle)*zh*0.02*scale);
        ctx.stroke();
      }
      // Pupil
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(-zw*0.055*scale, -zh*0.012*scale, zw*0.015*scale, 0, Math.PI*2);
      ctx.fill();
      
      // Nose (side profile)
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.moveTo(-zw*0.08*scale, 0);
      ctx.lineTo(-zw*0.12*scale, zh*0.015*scale);
      ctx.lineTo(-zw*0.1*scale, zh*0.03*scale);
      ctx.lineTo(-zw*0.08*scale, zh*0.025*scale);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#2a1a1a';
      ctx.beginPath();
      ctx.ellipse(-zw*0.095*scale, zh*0.022*scale, zw*0.01*scale, zh*0.006*scale, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Mouth (open, groaning)
      ctx.fillStyle = '#2a0a0a';
      ctx.beginPath();
      ctx.ellipse(-zw*0.06*scale, zh*0.055*scale, zw*0.045*scale, zh*0.025*scale, 0, 0, Math.PI);
      ctx.fill();
      
      // Teeth
      ctx.fillStyle = '#bbbb88';
      for(let t = 0; t < 3; t++) {
        const tx = -zw*0.085*scale + t*zw*0.018*scale;
        ctx.beginPath();
        ctx.moveTo(tx, zh*0.045*scale);
        ctx.lineTo(tx - zw*0.005*scale, zh*0.045*scale + zh*0.015*scale);
        ctx.lineTo(tx + zw*0.006*scale, zh*0.045*scale + zh*0.015*scale);
        ctx.closePath();
        ctx.fill();
      }
      
      // Jaw
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.ellipse(-zw*0.03*scale, zh*0.075*scale, zw*0.055*scale, zh*0.03*scale, 0.25, 0, Math.PI*2);
      ctx.fill();
      
      // Blood from mouth
      if(!isDead) {
        ctx.fillStyle = bloodColor;
        ctx.beginPath();
        ctx.moveTo(-zw*0.08*scale, zh*0.07*scale);
        ctx.quadraticCurveTo(-zw*0.1*scale, zh*0.11*scale, -zw*0.07*scale, zh*0.13*scale);
        ctx.quadraticCurveTo(-zw*0.06*scale, zh*0.1*scale, -zw*0.08*scale, zh*0.07*scale);
        ctx.fill();
      }
      
      ctx.restore(); // Head
      
      // Bomb zombie pulsing glow
      if(z.bomb && !isDead) {
        const bombPulse = 0.4 + Math.sin(now/150) * 0.3;
        ctx.strokeStyle = `rgba(255, 100, 0, ${bombPulse})`;
        ctx.lineWidth = 3*scale;
        ctx.beginPath();
        ctx.arc(0, -zh*0.08*scale, zw*0.2*scale, 0, Math.PI*2);
        ctx.stroke();
      }
      
      // Boss crown
      if(z.boss && !isDead) {
        ctx.save();
        ctx.translate(0, -zh*0.35*scale);
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(-zw*0.06*scale, zh*0.015*scale);
        ctx.lineTo(-zw*0.04*scale, -zh*0.04*scale);
        ctx.lineTo(-zw*0.02*scale, 0);
        ctx.lineTo(0, -zh*0.06*scale);
        ctx.lineTo(zw*0.02*scale, 0);
        ctx.lineTo(zw*0.04*scale, -zh*0.04*scale);
        ctx.lineTo(zw*0.06*scale, zh*0.015*scale);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 1.5*scale;
        ctx.stroke();
        // Gem
        ctx.fillStyle = '#e53935';
        ctx.beginPath();
        ctx.arc(0, -zh*0.03*scale, zw*0.02*scale, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      

      // Armored helmet for flying zombies: 2D silver/gray
      const isFlying = z.brokenWings && z.row < 2;
      if(isFlying && z.armored && !isDead) {
        ctx.save();
        ctx.translate(0, -zh*0.3*scale);
        // Main helmet: silver gradient
        const helmetGrd = ctx.createLinearGradient(-zw*0.16*scale, 0, zw*0.16*scale, 0);
        helmetGrd.addColorStop(0, '#e0e0e0');
        helmetGrd.addColorStop(0.4, '#b0b0b0');
        helmetGrd.addColorStop(0.7, '#a0a0a0');
        helmetGrd.addColorStop(1, '#f5f5f5');
        ctx.fillStyle = helmetGrd;
        ctx.beginPath();
        ctx.ellipse(0, 0, zw*0.16*scale, zh*0.14*scale, 0, 0, Math.PI*2);
        ctx.fill();
        // Helmet outline (dark gray)
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2.5*scale;
        ctx.stroke();
        // Visor: dark gray
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.roundRect(-zw*0.12*scale, -zh*0.04*scale, zw*0.08*scale, zh*0.06*scale, 2*scale);
        ctx.fill();
        // Shine highlight
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(-zw*0.05*scale, -zh*0.06*scale, zw*0.05*scale, zh*0.03*scale, -0.2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        ctx.restore();
      }
      // Armored helmet for ground zombies (default)
      else if(z.armored && !isDead) {
        ctx.save();
        ctx.translate(0, -zh*0.3*scale);
        ctx.fillStyle = '#4a4a4a';
        ctx.beginPath();
        ctx.ellipse(0, 0, zw*0.16*scale, zh*0.14*scale, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 2*scale;
        ctx.stroke();
        // Visor
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.roundRect(-zw*0.12*scale, -zh*0.04*scale, zw*0.08*scale, zh*0.06*scale, 2*scale);
        ctx.fill();
        ctx.restore();
      }
      
      ctx.restore();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2D ANIMATED ZOMBIE DRAWING FUNCTION - GRUESOME EDITION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function draw2DZombie(ctx, z, x, y, zw, zh, now) {
      const walkCycle = (z.walkPhase || 0) + now/400;
      const isFlying = z.brokenWings && z.row < 2;
      const bossScale = z.boss ? 1.4 : 1;
      const hpRatio = z.hp / (z.maxHp || 14);
      
      // Animation values - reduced sway
      const legSwing = Math.sin(walkCycle * 2) * 0.15;
      const armSwing = Math.sin(walkCycle * 2 + Math.PI) * 0.12;
      const headBob = Math.sin(walkCycle * 1.2) * 0.03;
      const bodyBob = Math.abs(Math.sin(walkCycle * 2)) * 1;
      const bodyLean = Math.sin(walkCycle * 0.6) * 0.02;
      
      // Colors - more gruesome zombie colors
      let skinColor = '#6b7c5b'; // Pale rotting green
      let skinDark = '#4a5c3b'; // Darker rot
      let clothesColor = '#3a2820'; // Dirty brown torn clothes
      let boneColor = '#e8e0d0'; // Exposed bone color
      let bloodColor = '#8b0000'; // Dark blood
      let fleshColor = '#8b4a4a'; // Exposed flesh
      let hairColor = '#1a1a1a';
      
      if(z.bomb) {
        skinColor = '#5c6b4b'; // Greenish
        skinDark = '#3c4b2b';
        clothesColor = '#4a3020'; // Dark brown with orange tint
        bloodColor = '#ff4400'; // Orange-red for explosive
      }
      if(z.armored) {
        skinColor = '#5a6c4b';
        skinDark = '#3a4c2b';
        clothesColor = '#2a2a2a';
      }
      if(z.boss) {
        skinColor = '#7b3a4c';
        skinDark = '#5b1a2c';
        clothesColor = '#1a0a0a';
        bloodColor = '#660000';
      }
      if(z.hypnotized) {
        skinColor = '#8a5caa';
        skinDark = '#6a3c8a';
      }
      
      // More damaged = more gruesome
      if(hpRatio < 0.5) {
        skinColor = '#5a6c4b';
        skinDark = '#3a4c2b';
      }
      if(hpRatio < 0.3) {
        skinColor = '#4a5c3b';
        skinDark = '#2a3c1b';
      }
      
      ctx.save();
      ctx.translate(x, y + bodyBob);
      
      if(isFlying) {
        ctx.rotate(-Math.PI/2 + Math.sin(now/200) * 0.05);
      } else {
        ctx.rotate(bodyLean);
      }
      
      const scale = bossScale * 0.8;
      
      // Shadow (ground zombies only) - at feet (bottom of zombie)
      if(!isFlying) {
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.ellipse(0, zh*0.5*scale, zw*0.35*scale, zh*0.06*scale, 0, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Draw broken wings for flying zombies
      if(isFlying) {
        drawBrokenAngelWings(ctx, 0, 0, zw*1.1*scale, zh*1.1*scale, walkCycle);
      }
      
      // === BACK LEG (with exposed bone) ===
      ctx.save();
      ctx.translate(zw*0.08*scale, zh*0.15*scale);
      ctx.rotate(legSwing);
      // Thigh with torn pants
      ctx.fillStyle = clothesColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.08*scale, 0, zw*0.16*scale, zh*0.22*scale, 4*scale);
      ctx.fill();
      // Torn hole in pants showing flesh
      ctx.fillStyle = fleshColor;
      ctx.beginPath();
      ctx.ellipse(zw*0.02*scale, zh*0.1*scale, zw*0.04*scale, zh*0.03*scale, 0.3, 0, Math.PI*2);
      ctx.fill();
      // Shin with rotting skin
      ctx.translate(0, zh*0.2*scale);
      ctx.rotate(-legSwing * 0.5);
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.06*scale, 0, zw*0.12*scale, zh*0.18*scale, 3*scale);
      ctx.fill();
      // Exposed shin bone
      if(hpRatio < 0.7) {
        ctx.fillStyle = boneColor;
        ctx.beginPath();
        ctx.roundRect(-zw*0.02*scale, zh*0.02*scale, zw*0.04*scale, zh*0.12*scale, 2*scale);
        ctx.fill();
        ctx.strokeStyle = bloodColor;
        ctx.lineWidth = 1*scale;
        ctx.stroke();
      }
      // Foot (missing some toes)
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(-zw*0.02*scale, zh*0.19*scale, zw*0.1*scale, zh*0.04*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      // === FRONT LEG (damaged) ===
      ctx.save();
      ctx.translate(-zw*0.05*scale, zh*0.15*scale);
      ctx.rotate(-legSwing);
      // Thigh
      ctx.fillStyle = clothesColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.08*scale, 0, zw*0.16*scale, zh*0.22*scale, 4*scale);
      ctx.fill();
      // Bloody wound on thigh
      ctx.fillStyle = bloodColor;
      ctx.beginPath();
      ctx.ellipse(-zw*0.03*scale, zh*0.08*scale, zw*0.03*scale, zh*0.02*scale, -0.2, 0, Math.PI*2);
      ctx.fill();
      // Shin
      ctx.translate(0, zh*0.2*scale);
      ctx.rotate(legSwing * 0.5);
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.06*scale, 0, zw*0.12*scale, zh*0.18*scale, 3*scale);
      ctx.fill();
      // Rotting patches
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(zw*0.02*scale, zh*0.08*scale, zw*0.03*scale, zh*0.04*scale, 0.4, 0, Math.PI*2);
      ctx.fill();
      // Foot
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(-zw*0.02*scale, zh*0.19*scale, zw*0.1*scale, zh*0.04*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      // === BODY/TORSO ===
      ctx.save();
      if(z.bomb) {
        // Bomb replaces torso: draw strapped explosive that becomes more 'about to explode' as HP falls
        const bx = 0;
        const by = zh*0.02*scale;
        // Make the bomb noticeably larger so it fully covers the torso
        const maxBr = zw*0.32*scale;
        const hpPct = Math.max(0, Math.min(1, z.hp / (z.maxHp || 1)));
        const danger = 1 - hpPct; // 0 safe -> 1 critical
        const pulse = 0.98 + Math.sin(now/120) * 0.03 + danger * 0.06;
        const br = maxBr * (1 + danger*0.12) * pulse;

        // Bomb body (dark metal, shifts toward orange/red as danger increases)
        const bombGrd = ctx.createRadialGradient(bx - br*0.25, by - br*0.25, br*0.08, bx, by, br);
        const innerColor = danger > 0.6 ? '#3a0a00' : '#2a2a2a';
        bombGrd.addColorStop(0, innerColor);
        bombGrd.addColorStop(0.6, '#0f0f0f');
        bombGrd.addColorStop(1, '#000000');
        ctx.fillStyle = bombGrd; ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2); ctx.fill();

        // hazard stripes (opacity increases with danger)
        ctx.save(); ctx.translate(bx, by); ctx.rotate(Math.PI/8 + Math.sin(now/250)*0.02);
        const stripeCount = 5;
        for(let s= -stripeCount; s<=stripeCount; s++){
          const x = s * br*0.22;
          ctx.fillStyle = (s%2===0) ? `rgba(255,215,0,${0.25 + danger*0.6})` : `rgba(0,0,0,${0.35 + danger*0.4})`;
          ctx.beginPath(); ctx.rect(x - br*0.12, -br*0.9, br*0.24, br*1.8); ctx.fill();
        }
        ctx.restore();

        // cracks / scorch marks when damaged
        if(danger > 0.12){
          ctx.strokeStyle = `rgba(50,10,10,${0.25 + danger*0.5})`;
          ctx.lineWidth = 1.2*scale + danger*1.6*scale;
          for(let c=0;c<3 + Math.floor(danger*6); c++){
            const ax = bx + (Math.random()*2-1)*br*0.4;
            const ay = by + (Math.random()*2-1)*br*0.35;
            ctx.beginPath(); ctx.moveTo(ax, ay);
            const segs = 3 + Math.floor(Math.random()*3);
            for(let si=0; si<segs; si++) ctx.lineTo(ax + (Math.random()*2-1)*br*0.2*(si+1), ay + (Math.random()*2-1)*br*0.15*(si+1));
            ctx.stroke();
          }
        }

        // straps (simple across chest)
        ctx.strokeStyle = '#4a3a2a'; ctx.lineWidth = 2*scale;
        ctx.beginPath(); ctx.moveTo(bx - br*0.9, by - br*0.2); ctx.lineTo(bx + br*0.9, by + br*0.3); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx - br*0.9, by + br*0.2); ctx.lineTo(bx + br*0.9, by - br*0.3); ctx.stroke();

        // fuse and spark intensity increases with danger
        ctx.strokeStyle = '#7a4a20'; ctx.lineWidth = 2.2*scale;
        ctx.beginPath(); ctx.moveTo(bx, by - br*0.72); ctx.quadraticCurveTo(bx + br*0.55, by - br*1.12, bx + br*0.38, by - br*1.3); ctx.stroke();
        const sparkSize = 3 + Math.abs(Math.sin(now/60))*2 + danger*3;
        ctx.fillStyle = `rgba(255,${120 + Math.floor(Math.sin(now/30)*120)},0,${0.6 + danger*0.4})`;
        ctx.beginPath(); ctx.arc(bx+br*0.38, by - br*1.3, sparkSize*scale, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,255,140,0.7)'; ctx.beginPath(); ctx.arc(bx+br*0.38, by - br*1.3, sparkSize*0.5*scale, 0, Math.PI*2); ctx.fill();

        // pulsing warning glow based on danger
        const glowStrength = 0.18 + Math.min(0.9, danger*1.4);
        const glow = ctx.createRadialGradient(bx, by, br*0.15, bx, by, br*1.4 + danger*6);
        glow.addColorStop(0, `rgba(255,${80 + Math.floor(danger*120)},${20 + Math.floor(danger*50)},${glowStrength})`);
        glow.addColorStop(0.5, `rgba(255,60,10,${glowStrength*0.6})`);
        glow.addColorStop(1, 'rgba(255,0,0,0)');
        ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(bx, by, br*1.05 + danger*6, 0, Math.PI*2); ctx.fill();

        // LED / ticking light grows brighter as danger increases
        const ledAlpha = 0.35 + danger*0.9 + (Math.sin(now/140)+1)/4 * danger;
        ctx.fillStyle = `rgba(255,140,40,${Math.min(1, ledAlpha)})`;
        ctx.beginPath(); ctx.arc(bx + br*0.5, by, 3.2*scale + danger*1.8*scale, 0, Math.PI*2); ctx.fill();
      } else {
        // Torn shirt/jacket
        ctx.fillStyle = clothesColor;
        ctx.beginPath();
        ctx.roundRect(-zw*0.22*scale, -zh*0.15*scale, zw*0.44*scale, zh*0.35*scale, 6*scale);
        ctx.fill();
        
        // Exposed flesh under torn shirt
        ctx.fillStyle = fleshColor;
        ctx.beginPath();
        ctx.ellipse(-zw*0.05*scale, zh*0.0*scale, zw*0.1*scale, zh*0.08*scale, 0, 0, Math.PI*2);
        ctx.fill();
        
        // Exposed ribs (showing through torn flesh)
        ctx.strokeStyle = boneColor;
        ctx.lineWidth = 2.5*scale;
        for(let r = 0; r < 3; r++) {
          ctx.beginPath();
          ctx.moveTo(-zw*0.12*scale, -zh*0.02*scale + r*zh*0.04*scale);
          ctx.quadraticCurveTo(
            -zw*0.02*scale, -zh*0.04*scale + r*zh*0.04*scale,
            zw*0.04*scale, -zh*0.02*scale + r*zh*0.04*scale
          );
          ctx.stroke();
        }
        
        // Blood dripping from wound
        ctx.fillStyle = bloodColor;
        ctx.beginPath();
        ctx.moveTo(-zw*0.02*scale, zh*0.08*scale);
        ctx.lineTo(-zw*0.04*scale, zh*0.16*scale);
        ctx.lineTo(zw*0.0*scale, zh*0.14*scale);
        ctx.closePath();
        ctx.fill();
        
        // Torn edge effect
        ctx.fillStyle = skinColor;
        for(let i = 0; i < 3; i++) {
          const tx = -zw*0.15*scale + i * zw*0.12*scale;
          ctx.beginPath();
          ctx.arc(tx, zh*0.18*scale, zw*0.04*scale, 0, Math.PI);
          ctx.fill();
        }
      }
      ctx.restore();
      
      // === BACK ARM (skeletal) ===
      ctx.save();
      ctx.translate(zw*0.18*scale, -zh*0.08*scale);
      ctx.rotate(armSwing * 0.8 + 0.3);
      // Upper arm with rotting flesh
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.05*scale, 0, zw*0.1*scale, zh*0.18*scale, 4*scale);
      ctx.fill();
      // Exposed muscle
      ctx.fillStyle = fleshColor;
      ctx.beginPath();
      ctx.ellipse(zw*0.02*scale, zh*0.08*scale, zw*0.025*scale, zh*0.04*scale, 0, 0, Math.PI*2);
      ctx.fill();
      // Forearm
      ctx.translate(0, zh*0.16*scale);
      ctx.rotate(0.4 + Math.sin(walkCycle*2)*0.2);
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.045*scale, 0, zw*0.09*scale, zh*0.16*scale, 3*scale);
      ctx.fill();
      // Hand
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(0, zh*0.17*scale, zw*0.06*scale, zh*0.05*scale, 0.3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      // === FRONT ARM (reaching, more damaged) ===
      ctx.save();
      ctx.translate(-zw*0.18*scale, -zh*0.08*scale);
      ctx.rotate(-armSwing + 0.5 + Math.sin(now/400)*0.1);
      // Upper arm
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.05*scale, 0, zw*0.1*scale, zh*0.18*scale, 4*scale);
      ctx.fill();
      // Exposed arm bone
      if(hpRatio < 0.6) {
        ctx.fillStyle = boneColor;
        ctx.beginPath();
        ctx.roundRect(-zw*0.015*scale, zh*0.02*scale, zw*0.03*scale, zh*0.14*scale, 1*scale);
        ctx.fill();
      }
      // Forearm (extended forward)
      ctx.translate(0, zh*0.16*scale);
      ctx.rotate(-0.3 + Math.sin(walkCycle*2+1)*0.15);
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.045*scale, 0, zw*0.09*scale, zh*0.16*scale, 3*scale);
      ctx.fill();
      // Wrist wound
      ctx.fillStyle = bloodColor;
      ctx.beginPath();
      ctx.ellipse(0, zh*0.12*scale, zw*0.035*scale, zh*0.02*scale, 0, 0, Math.PI*2);
      ctx.fill();
      // Skeletal hand (clawing)
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.ellipse(0, zh*0.17*scale, zw*0.06*scale, zh*0.05*scale, -0.3, 0, Math.PI*2);
      ctx.fill();
      // Bony fingers with nails
      for(let f = 0; f < 4; f++) {
        ctx.save();
        ctx.translate(-zw*0.045*scale + f*zw*0.03*scale, zh*0.17*scale);
        ctx.rotate(-0.15 + f*0.1);
        // Finger bone
        ctx.fillStyle = skinDark;
        ctx.beginPath();
        ctx.roundRect(-zw*0.012*scale, 0, zw*0.024*scale, zh*0.06*scale, 1*scale);
        ctx.fill();
        // Fingernail (dirty/bloody)
        ctx.fillStyle = '#4a3a2a';
        ctx.beginPath();
        ctx.ellipse(0, zh*0.06*scale, zw*0.015*scale, zh*0.012*scale, 0, 0, Math.PI);
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();
      
      // === HEAD (gruesome face) ===
      ctx.save();
      ctx.translate(0, -zh*0.22*scale);
      ctx.rotate(headBob);
      
      // Neck with exposed tendons
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.06*scale, zh*0.02*scale, zw*0.12*scale, zh*0.1*scale, 3*scale);
      ctx.fill();
      // Neck wound
      ctx.fillStyle = fleshColor;
      ctx.beginPath();
      ctx.ellipse(zw*0.04*scale, zh*0.06*scale, zw*0.025*scale, zh*0.02*scale, 0.3, 0, Math.PI*2);
      ctx.fill();
      
      // Head shape
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.ellipse(0, -zh*0.05*scale, zw*0.18*scale, zh*0.14*scale, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Exposed skull patch
      if(hpRatio < 0.5) {
        ctx.fillStyle = boneColor;
        ctx.beginPath();
        ctx.ellipse(zw*0.1*scale, -zh*0.12*scale, zw*0.05*scale, zh*0.04*scale, 0.3, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = bloodColor;
        ctx.lineWidth = 1*scale;
        ctx.stroke();
      }
      
      // Hair (messy, falling out)
      ctx.fillStyle = hairColor;
      ctx.beginPath();
      ctx.ellipse(0, -zh*0.13*scale, zw*0.14*scale, zh*0.06*scale, 0, Math.PI, Math.PI*2);
      ctx.fill();
      // Sparse hair strands
      for(let h = 0; h < 4; h++) {
        if(h !== 2 || hpRatio > 0.4) { // Missing patch when damaged
          ctx.beginPath();
          ctx.moveTo(-zw*0.1*scale + h*zw*0.06*scale, -zh*0.14*scale);
          ctx.quadraticCurveTo(
            -zw*0.08*scale + h*zw*0.05*scale + Math.sin(now/300+h)*2, 
            -zh*0.2*scale,
            -zw*0.06*scale + h*zw*0.04*scale, 
            -zh*0.16*scale
          );
          ctx.strokeStyle = hairColor;
          ctx.lineWidth = 2*scale;
          ctx.stroke();
        }
      }
      
      // Eyes (dead, creepy)
      // Left eye (sunken, bloodshot)
      ctx.fillStyle = '#1a1a1a'; // Dark socket
      ctx.beginPath();
      ctx.ellipse(-zw*0.07*scale, -zh*0.05*scale, zw*0.055*scale, zh*0.045*scale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffffaa';
      ctx.beginPath();
      ctx.ellipse(-zw*0.07*scale, -zh*0.05*scale, zw*0.045*scale, zh*0.035*scale, 0, 0, Math.PI*2);
      ctx.fill();
      // Heavy bloodshot veins
      ctx.strokeStyle = '#aa2222';
      ctx.lineWidth = 0.8*scale;
      for(let v = 0; v < 5; v++) {
        ctx.beginPath();
        ctx.moveTo(-zw*0.07*scale, -zh*0.05*scale);
        const angle = (v / 5) * Math.PI * 2;
        ctx.lineTo(
          -zw*0.07*scale + Math.cos(angle) * zw*0.04*scale,
          -zh*0.05*scale + Math.sin(angle) * zh*0.03*scale
        );
        ctx.stroke();
      }
      // Dilated pupil
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(-zw*0.065*scale + Math.sin(now/500)*1, -zh*0.05*scale, zw*0.022*scale, 0, Math.PI*2);
      ctx.fill();
      
      // Right eye (droopy, nearly closed)
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.ellipse(zw*0.06*scale, -zh*0.03*scale, zw*0.045*scale, zh*0.035*scale, 0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ddddaa';
      ctx.beginPath();
      ctx.ellipse(zw*0.06*scale, -zh*0.025*scale, zw*0.035*scale, zh*0.02*scale, 0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(zw*0.062*scale, -zh*0.025*scale, zw*0.015*scale, 0, Math.PI*2);
      ctx.fill();
      
      // Droopy eyelid
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.ellipse(zw*0.06*scale, -zh*0.04*scale, zw*0.04*scale, zh*0.02*scale, 0.2, Math.PI, Math.PI*2);
      ctx.fill();
      
      // Nose (rotted away partially)
      ctx.fillStyle = skinDark;
      ctx.beginPath();
      ctx.moveTo(0, -zh*0.02*scale);
      ctx.lineTo(-zw*0.02*scale, zh*0.01*scale);
      ctx.lineTo(zw*0.02*scale, zh*0.01*scale);
      ctx.closePath();
      ctx.fill();
      // Nose hole
      ctx.fillStyle = '#2a1a1a';
      ctx.beginPath();
      ctx.ellipse(zw*0.01*scale, zh*0.0*scale, zw*0.012*scale, zh*0.008*scale, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Mouth (grotesque gaping maw)
      ctx.fillStyle = '#2a0a0a'; // Dark mouth interior
      ctx.beginPath();
      ctx.ellipse(0, zh*0.04*scale, zw*0.1*scale, zh*0.04*scale, 0, 0, Math.PI);
      ctx.fill();
      
      // Rotten teeth (irregular)
      ctx.fillStyle = '#bbbb88';
      const teethPattern = [true, false, true, true, false, true]; // Some missing
      for(let t = 0; t < 6; t++) {
        if(teethPattern[t]) {
          const toothX = -zw*0.07*scale + t*zw*0.028*scale;
          const toothH = zh*0.02*scale + (t%2)*zh*0.01*scale; // Irregular heights
          ctx.beginPath();
          ctx.moveTo(toothX, zh*0.025*scale);
          ctx.lineTo(toothX - zw*0.008*scale, zh*0.025*scale + toothH);
          ctx.lineTo(toothX + zw*0.012*scale, zh*0.025*scale + toothH);
          ctx.closePath();
          ctx.fill();
          // Tooth decay
          ctx.fillStyle = '#665544';
          ctx.beginPath();
          ctx.arc(toothX, zh*0.03*scale + toothH*0.5, zw*0.005*scale, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#bbbb88';
        }
      }
      
      // Blood dripping from mouth
      ctx.fillStyle = bloodColor;
      ctx.beginPath();
      ctx.moveTo(-zw*0.02*scale, zh*0.07*scale);
      ctx.quadraticCurveTo(-zw*0.03*scale, zh*0.1*scale, -zw*0.02*scale, zh*0.12*scale);
      ctx.quadraticCurveTo(-zw*0.01*scale, zh*0.1*scale, -zw*0.02*scale, zh*0.07*scale);
      ctx.fill();
      
      // Facial wounds/scars
      ctx.strokeStyle = bloodColor;
      ctx.lineWidth = 1.5*scale;
      ctx.beginPath();
      ctx.moveTo(zw*0.08*scale, -zh*0.08*scale);
      ctx.lineTo(zw*0.12*scale, zh*0.0*scale);
      ctx.stroke();
      
      if(hpRatio < 0.6) {
        // Cheek wound
        ctx.fillStyle = fleshColor;
        ctx.beginPath();
        ctx.ellipse(zw*0.12*scale, -zh*0.01*scale, zw*0.04*scale, zh*0.03*scale, 0.5, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = bloodColor;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(zw*0.12*scale, -zh*0.01*scale, zw*0.025*scale, zh*0.018*scale, 0.5, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      if(hpRatio < 0.3) {
        // Eye socket wound
        ctx.fillStyle = bloodColor;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.ellipse(-zw*0.06*scale, -zh*0.02*scale, zw*0.05*scale, zh*0.04*scale, -0.3, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      ctx.restore();
      
      // Armor overlay for armored zombie: riveted chestplate, dents and scratches
      if(z.armored) {
        // chestplate base with metallic gradient
        const plateGrd = ctx.createLinearGradient(-zw*0.25*scale, 0, zw*0.25*scale, 0);
        plateGrd.addColorStop(0, '#8f9aa0');
        plateGrd.addColorStop(0.4, '#dfe6ea');
        plateGrd.addColorStop(1, '#8f9aa0');
        ctx.fillStyle = plateGrd;
        ctx.beginPath();
        ctx.roundRect(-zw*0.25*scale, -zh*0.18*scale, zw*0.5*scale, zh*0.4*scale, 6*scale);
        ctx.fill();
        // plate edge stroke
        ctx.strokeStyle = '#40464a';
        ctx.lineWidth = 2*scale;
        ctx.beginPath(); ctx.roundRect(-zw*0.25*scale, -zh*0.18*scale, zw*0.5*scale, zh*0.4*scale, 6*scale); ctx.stroke();

        // rivets
        ctx.fillStyle = '#2a2d2f';
        for(let rx=-1; rx<=1; rx+=2){
          for(let ry=-1; ry<=1; ry++){
            const vx = rx * zw*0.18*scale;
            const vy = ry * zh*0.08*scale + zh*0.03*scale;
            ctx.beginPath(); ctx.arc(vx, vy, 1.8*scale, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#6d6d6d'; ctx.beginPath(); ctx.arc(vx, vy, 0.8*scale, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#2a2d2f';
          }
        }

        // scratches / dents
        ctx.strokeStyle = 'rgba(20,20,20,0.25)'; ctx.lineWidth = 1*scale;
        ctx.beginPath(); ctx.moveTo(-zw*0.06*scale, -zh*0.02*scale); ctx.lineTo(zw*0.14*scale, -zh*0.04*scale); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(zw*0.02*scale, -zh*0.06*scale); ctx.lineTo(zw*0.16*scale, -zh*0.02*scale); ctx.stroke();

        // Dented helmet (shaded, with rim and subtle dents)
        const helmGrd = ctx.createLinearGradient(0, -zh*0.4*scale, 0, -zh*0.12*scale);
        helmGrd.addColorStop(0, '#cfcfcf'); helmGrd.addColorStop(1, '#7a7f85');
        ctx.fillStyle = helmGrd;
        ctx.beginPath(); ctx.ellipse(0, -zh*0.28*scale, zw*0.16*scale, zh*0.14*scale, 0, Math.PI, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#34383b'; ctx.lineWidth = 1.5*scale; ctx.stroke();
        // helmet dents
        ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.beginPath(); ctx.ellipse(-zw*0.06*scale, -zh*0.3*scale, zw*0.03*scale, zh*0.02*scale, -0.2, 0, Math.PI*2); ctx.fill();

        // Dark visor slot with subtle reflection
        ctx.fillStyle = '#0b0b0b'; ctx.beginPath(); ctx.roundRect(-zw*0.12*scale, -zh*0.22*scale, zw*0.24*scale, zh*0.06*scale, 2*scale); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.beginPath(); ctx.roundRect(-zw*0.06*scale, -zh*0.2*scale, zw*0.12*scale, zh*0.02*scale, 1*scale); ctx.fill();

        // subtle rust/blood hints (decorative)
        ctx.fillStyle = 'rgba(100,30,20,0.25)'; ctx.beginPath(); ctx.ellipse(zw*0.12*scale, -zh*0.02*scale, zw*0.05*scale, zh*0.03*scale, 0.3, 0, Math.PI*2); ctx.fill();
      }

      // Bomb zombie: decorative strapped explosive with hazard bands, fuse and pulsing glow
      if(z.bomb) {
        const bombPulse = 0.95 + Math.sin(now/120) * 0.06;
        const bx = 0, by = zh*0.02*scale;
        const br = zw*0.14*scale * bombPulse;

        // Bomb body (dark metal ball)
        const bombGrd = ctx.createRadialGradient(bx - br*0.25, by - br*0.25, br*0.08, bx, by, br);
        bombGrd.addColorStop(0, '#2a2a2a'); bombGrd.addColorStop(0.6, '#0f0f0f'); bombGrd.addColorStop(1, '#000000');
        ctx.fillStyle = bombGrd; ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2); ctx.fill();

        // Metal band / plate behind bomb (for strapped look)
        ctx.save(); ctx.translate(bx, by); ctx.rotate(Math.sin(now/300)*0.03);
        ctx.fillStyle = '#3b3b3b'; ctx.beginPath(); ctx.ellipse(0, 0, br*1.05, br*0.6, 0, 0, Math.PI*2); ctx.fill();
        // create band hole
        ctx.globalCompositeOperation = 'destination-out'; ctx.beginPath(); ctx.ellipse(0, 0, br*0.82, br*0.48, 0, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        // hazard stripes across band
        ctx.save(); ctx.clip(); ctx.rotate(Math.PI/8);
        for(let s=-3;s<=3;s++){
          ctx.fillStyle = (s%2===0) ? '#000' : '#ffd400';
          ctx.fillRect(-br*1.5 + s*br*0.28, -br*0.7, br*0.22, br*1.4);
        }
        ctx.restore(); ctx.restore();

        // Fuse and spark
        ctx.strokeStyle = '#7a4a20'; ctx.lineWidth = 2*scale;
        ctx.beginPath(); ctx.moveTo(bx, by - br*0.7); ctx.quadraticCurveTo(bx+br*0.55, by - br*1.12, bx+br*0.38, by - br*1.3); ctx.stroke();
        const sparkSize = 3 + Math.abs(Math.sin(now/60))*2;
        ctx.fillStyle = `rgba(255,${120 + Math.floor(Math.sin(now/30)*120)},0,0.95)`;
        ctx.beginPath(); ctx.arc(bx+br*0.38, by - br*1.3, sparkSize*scale, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,255,140,0.7)'; ctx.beginPath(); ctx.arc(bx+br*0.38, by - br*1.3, sparkSize*0.5*scale, 0, Math.PI*2); ctx.fill();

        // Warning glow when HP low
        if(z.hp <= (z.maxHp || 1) * 0.5) {
          const wp = Math.sin(now/80)*0.4 + 0.6;
          const glow = ctx.createRadialGradient(bx, by, br*0.2, bx, by, br*1.2);
          glow.addColorStop(0, `rgba(255,80,20,${0.5*wp})`);
          glow.addColorStop(0.4, `rgba(255,70,20,${0.35*wp})`);
          glow.addColorStop(1, 'rgba(255,0,0,0)');
          ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(bx, by, br*1.1, 0, Math.PI*2); ctx.fill();
        }

        // small ticking LED
        const ledAlpha = (Math.sin(now/150)+1)/2*0.95;
        ctx.fillStyle = `rgba(255,120,40,${ledAlpha})`;
        ctx.beginPath(); ctx.arc(bx+br*0.62, by, 2.6*scale, 0, Math.PI*2); ctx.fill();
      }
      
      // Boss aura (darker, more menacing)
      if(z.boss) {
        const auraSize = zw*0.65*scale + Math.sin(now/100)*6;
        const auraGrd = ctx.createRadialGradient(0, 0, zw*0.1*scale, 0, 0, auraSize);
        auraGrd.addColorStop(0, 'rgba(80,0,0,0.35)');
        auraGrd.addColorStop(0.5, 'rgba(50,0,0,0.2)');
        auraGrd.addColorStop(1, 'rgba(30,0,0,0)');
        ctx.fillStyle = auraGrd;
        ctx.beginPath();
        ctx.arc(0, 0, auraSize, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Hypnotized glow
      if(z.hypnotized) {
        const hypnoGlow = ctx.createRadialGradient(0, 0, zw*0.1*scale, 0, 0, zw*0.4*scale);
        hypnoGlow.addColorStop(0, 'rgba(233,30,99,0.35)');
        hypnoGlow.addColorStop(1, 'rgba(233,30,99,0)');
        ctx.fillStyle = hypnoGlow;
        ctx.beginPath();
        ctx.arc(0, 0, zw*0.4*scale, 0, Math.PI*2);
        ctx.fill();
      }

      // Slow tint (ice pea or magnet) - light cyan overlay when recently slowed
      if(z.slowTintUntil && z.slowTintUntil > now){
        const slowGrd = ctx.createRadialGradient(0, 0, zw*0.05*scale, 0, 0, zw*0.5*scale);
        slowGrd.addColorStop(0, 'rgba(178,235,242,0.45)');
        slowGrd.addColorStop(1, 'rgba(178,235,242,0)');
        ctx.fillStyle = slowGrd;
        ctx.beginPath();
        ctx.arc(0, 0, zw*0.5*scale, 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    // Dead zombie drawing - more gruesome
    function draw2DZombieDead(ctx, z, x, y, zw, zh, now) {
      const bossScale = z.boss ? 1.4 : 1;
      const scale = bossScale * 0.8;
      let skinColor = '#4a5c3b';
      let boneColor = '#d8d0c0';
      let bloodColor = '#6b0000';
      
      ctx.save();
      ctx.globalAlpha = z.alpha !== undefined ? z.alpha : 1;
      ctx.translate(x, y + zh*0.1);
      
      if(z.brokenWings && z.row < 2) {
        ctx.rotate(0.6 + (z.rot || 0));
        drawBrokenAngelWings(ctx, 0, -zh*0.1*scale, zw*0.8*scale, zh*0.8*scale, 0.5);
      } else {
        ctx.rotate(1.3 + (z.rot || 0));
      }
      
      ctx.filter = 'saturate(0.3) brightness(0.5)';
      
      // Blood pool under body
      ctx.fillStyle = bloodColor;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.ellipse(zw*0.05*scale, zh*0.15*scale, zw*0.3*scale, zh*0.08*scale, 0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = z.alpha !== undefined ? z.alpha : 1;
      
      // Simplified dead body
      ctx.fillStyle = skinColor;
      // Body
      ctx.beginPath();
      ctx.roundRect(-zw*0.2*scale, -zh*0.1*scale, zw*0.4*scale, zh*0.3*scale, 5*scale);
      ctx.fill();
      
      // Exposed spine
      ctx.fillStyle = boneColor;
      ctx.beginPath();
      ctx.roundRect(-zw*0.02*scale, -zh*0.05*scale, zw*0.04*scale, zh*0.2*scale, 2*scale);
      ctx.fill();
      
      // Head (twisted)
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.ellipse(-zw*0.15*scale, -zh*0.2*scale, zw*0.1*scale, zh*0.08*scale, 0.5, 0, Math.PI*2);
      ctx.fill();
      
      // Dead X eyes
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 2*scale;
      ctx.beginPath();
      ctx.moveTo(-zw*0.18*scale, -zh*0.22*scale);
      ctx.lineTo(-zw*0.14*scale, -zh*0.18*scale);
      ctx.moveTo(-zw*0.14*scale, -zh*0.22*scale);
      ctx.lineTo(-zw*0.18*scale, -zh*0.18*scale);
      ctx.stroke();
      
      // Limbs sprawled
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.roundRect(zw*0.15*scale, -zh*0.05*scale, zw*0.2*scale, zh*0.08*scale, 3*scale);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(-zw*0.35*scale, zh*0.1*scale, zw*0.18*scale, zh*0.07*scale, 3*scale);
      ctx.fill();
      
      // Detached bone
      ctx.fillStyle = boneColor;
      ctx.beginPath();
      ctx.roundRect(zw*0.2*scale, zh*0.08*scale, zw*0.12*scale, zw*0.025*scale, 1*scale);
      ctx.fill();
      
      ctx.filter = 'none';
      ctx.restore();
    }

    ctx.font='28px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; 
    for(const z of zombies){ 
      const x = z.x * CW;
      // Raise zombies in top 2 rows by 20px so they appear higher on screen
      const y = (z.row + 0.5) * CH + (z.row < 2 ? PLANT_ZOMBIE_SHIFT - 20 : 0);
      const now = performance.now();
      // Scale boss size visually
      const bossScale = z.boss ? 1.8 : 1;
      const zw = CW*0.75 * bossScale, zh = CH*1.0 * bossScale;
      
      // Top 2 rows: draw side-view zombie
      const isTopRow = z.row < 2;
      
      if(z.dead){ 
        if(isTopRow){
          draw2DZombieSide(ctx, z, x, y, zw, zh, now, true);
        } else {
          draw2DZombieDead(ctx, z, x, y, zw, zh, now);
        }
      } else {
        if(isTopRow){
          draw2DZombieSide(ctx, z, x, y, zw, zh, now, false);
        } else {
          draw2DZombie(ctx, z, x, y, zw, zh, now);
        }
        
        // Blood drip particles (occasional)
        if(Math.random() < 0.008){
          spawnPlantParticles(x + (Math.random()-0.5)*zw*0.3, y + zh*0.1, '#8b0000', 1);
        }
      }
      
      // Enhanced health bar
      const barW=zw*0.8, barH=7, barX=x-barW/2, barY=y-zh*0.55;
      ctx.fillStyle='rgba(0,0,0,0.6)'; 
      ctx.fillRect(barX-1, barY-1, barW+2, barH+2);
      const maxZ = z.maxHp || 14; 
      const hpPct = Math.max(0, z.hp) / maxZ;
      // Red gradient for zombie HP
      const zHpGrd = ctx.createLinearGradient(barX, 0, barX+barW, 0);
      zHpGrd.addColorStop(0, '#c62828');
      zHpGrd.addColorStop(1, '#b71c1c');
      ctx.fillStyle=zHpGrd;
      ctx.fillRect(barX, barY, barW*hpPct, barH);
    }

    // vignette overlay for mood
    ctx.save(); const vg = ctx.createRadialGradient(W*0.5, H*0.5, H*0.2, W*0.5, H*0.5, H*0.9); vg.addColorStop(0, 'rgba(0,0,0,0)'); vg.addColorStop(1, 'rgba(0,0,0,0.25)'); ctx.fillStyle = vg; ctx.fillRect(0,0,W,H); ctx.restore();
    // draw level-16+ fog overlay (holes punched by placement illumination)
    try{ drawFogOverlay(); }catch(e){ /* ignore if not ready */ }
    ctx.restore();
  }

  function loop(ts){ if(!running) return; const dt = ts - last; last = ts; update(dt); render(); requestAnimationFrame(loop); }
  // debug: log when loop starts
  // loop wrapper removed (debug)

  // controls - resolve elements at runtime and guard against missing buttons
  try{
    const startEl = document.getElementById('start');
    if(startEl) startEl.onclick = ()=>{ if(!running){ initLawnmowers();
      if(levelSpawned === 0 && levelKilled === 0){ currentLevel = 1; }
      levelSpawned = 0; levelKilled = 0; levelTarget = 20 + (currentLevel-1)*10; spawnAcc = 0;
      running=true; gameStartTime = performance.now(); last=performance.now(); try{ menuOverlay.style.display='none'; menuOverlay.classList.remove('show'); }catch(e){} requestAnimationFrame(loop); try{ startMusic(); }catch(e){} } };
    const pauseEl = document.getElementById('pause');
    if(pauseEl) pauseEl.onclick = ()=>{ running = !running; if(running){ last = performance.now(); requestAnimationFrame(loop); try{ startMusic(); }catch(e){} } else { try{ stopMusic(); }catch(e){} } };
    const resetEl = document.getElementById('reset');
    if(resetEl) resetEl.onclick = ()=>{ sun=200; plants=[]; clearFogGrid(); zombies=[]; bullets=[]; particles=[]; running=false; initLawnmowers(); updateUI(); try{ menuOverlay.style.display='flex'; }catch(e){} try{ stopMusic(); }catch(e){};
      // reset level progression
      currentLevel = 1; levelTarget = 20; levelSpawned = 0; levelKilled = 0; spawnAcc = 0;
      // rebuild cards for day mode (level 1)
      rebuildCardsForLevel();
      buildSeedBar();
      try{ stopZombieMoan(); }catch(e){}
      // Hide game over overlay if visible
      const gOver = document.getElementById('gameOverOverlay'); if(gOver) gOver.style.display = 'none';
    };
  }catch(e){ console.error('controls init error', e); }
  
  // Game Over functions
  function showGameOver() {
    const overlay = document.getElementById('gameOverOverlay');
    const title = document.getElementById('gameOverTitle');
    const text = document.getElementById('gameOverText');
    const tryAgain = document.getElementById('tryAgainText');

    title.textContent = t('gameOver');
    text.textContent = t('zombieWin');
    tryAgain.textContent = t('tryAgain') + '?';
    // No restartBtn anymore; reset handled by showGameOverOverlay
    if(typeof showGameOverOverlay === 'function') {
      showGameOverOverlay();
    } else {
      overlay.style.display = 'flex';
    }
    try{ stopMusic(); }catch(e){}
    try{ stopZombieMoan(); }catch(e){}
  }
  
  playBtn.addEventListener('click', (e)=>{ 
    e.stopPropagation();
    initLawnmowers(); // ensure level counters start fresh when entering from menu
    levelSpawned = 0; levelKilled = 0; currentLevel = 1; levelTarget = 20; spawnAcc = 0;
    try{ menuOverlay.style.display='none'; menuOverlay.classList.remove('show'); }catch(e){} 
    running=true; 
    gameStartTime = performance.now(); 
    last=performance.now(); 
    requestAnimationFrame(loop); 
    try{ startMusic(); }catch(e){} 
  });
  
  // How to play button
  const howOverlay = document.getElementById('howOverlay');
  const howBackBtn = document.getElementById('howBackBtn');
  const menuHowBtn = document.getElementById('menuHow');
  
  // Global functions for inline onclick handlers
  window.startGame = function() {
    initLawnmowers();
    levelSpawned = 0; levelKilled = 0; currentLevel = 1; levelTarget = 20; spawnAcc = 0;
    try{ menuOverlay.style.display='none'; }catch(e){ console.error(e); }
    running = true;
    gameStartTime = performance.now();
    last = performance.now();
    requestAnimationFrame(loop);
    try{ startMusic(); }catch(e){}
  };
  
  window.showHowToPlay = function() {
    updateAllTexts();
    howOverlay.style.display = 'flex';
  };
  
  if(howBackBtn) {
    howBackBtn.addEventListener('click', (e)=>{ 
      e.stopPropagation();
      howOverlay.style.display='none'; 
    });
  }

  // Skip level button
  document.getElementById('skipLevel').onclick = ()=>{
    // Trigger level transition immediately (allow even when paused/menu)
    levelKilled = levelTarget; // mark as completed
    zombies = []; // clear all zombies
    doLevelTransition();
  };

  // Speed control button - ensure it exists and attach handler safely
  let speedBtn = document.getElementById('speedBtn');
  const speedLevels = [1, 2, 3, 5];
  let speedIndex = 0;
  if(!speedBtn){
    // ensure ctrlStack exists inside seedBar
    try{
      let stack = document.querySelector('#seedBar .ctrlStack');
      if(!stack){ stack = document.createElement('div'); stack.className='ctrlStack'; seedBar.appendChild(stack); }
      speedBtn = document.createElement('button'); speedBtn.id = 'speedBtn'; speedBtn.textContent = `âš¡ ${gameSpeedMultiplier}x`; speedBtn.style.background = '#ff6b6b';
      stack.appendChild(speedBtn);
    }catch(e){ console.error('Failed to create speedBtn', e); }
  }
  if(speedBtn){
    // Use delegated click handler on document to survive rebuilds of the button element
    document.addEventListener('click', (ev)=>{
      try{
        if(ev.target && ev.target.id === 'speedBtn'){
          speedIndex = (speedIndex + 1) % speedLevels.length;
          gameSpeedMultiplier = speedLevels[speedIndex];
          const sb = document.getElementById('speedBtn'); if(sb) sb.textContent = `âš¡ ${gameSpeedMultiplier}x`;
          if(gameSpeedMultiplier === 1) { if(sb) sb.style.background = '#ff6b6b'; }
          else if(gameSpeedMultiplier === 2) { if(sb) sb.style.background = '#ffa500'; }
          else if(gameSpeedMultiplier === 3) { if(sb) sb.style.background = '#ff4444'; }
          else if(sb) sb.style.background = '#cc0000';
        }
      }catch(err){ console.error(err); }
    });
  } else {
    console.warn('speedBtn unavailable - speed control disabled');
  }

  // Hammer (remove plant) button - create and attach under Skip if missing
  let hammerBtn = document.getElementById('hammerBtn');
  try{
    let stack = document.querySelector('#seedBar .ctrlStack');
    if(!stack){ stack = document.createElement('div'); stack.className='ctrlStack'; seedBar.appendChild(stack); }
    if(!hammerBtn){
      hammerBtn = document.createElement('button'); hammerBtn.id = 'hammerBtn'; hammerBtn.textContent = 'ğŸ”¨'; hammerBtn.title = 'Hammer: click a plant to remove it';
      hammerBtn.style.marginLeft = '8px';
      stack.appendChild(hammerBtn);
    }
    hammerBtn.onclick = ()=>{
      hammerMode = !hammerMode;
      // clear any selected seed while in hammer mode
      if(hammerMode){ selected = null; document.querySelectorAll('.seedCard').forEach(c=>c.classList.remove('selected')); hammerBtn.style.background = '#ffd54f'; canvas.style.cursor = 'crosshair'; }
      else { hammerBtn.style.background = ''; canvas.style.cursor = 'default'; }
    };
  }catch(e){ console.error('Failed to create/attach hammerBtn', e); }

  // next level button
  const nextLevelBtn = document.getElementById('nextLevelBtn');
  function clearPlantsAndResetUI(){ plants = []; bullets = []; particles = []; zombies = []; initLawnmowers(); // reset cooldowns
    clearFogGrid();
    Object.values(cardState).forEach(s=>{ s.cooldownUntil = 0; s.mask.style.display='none'; s.el.classList.remove('disabled'); });
    sun = INITIAL_SUN; updateUI(); }

  function doLevelTransition(){ const overlay = document.getElementById('levelOverlay'); const title = document.getElementById('levelTitle'); const text = document.getElementById('levelText');
    // Prevent advancing past level 20
    if (currentLevel >= 20) {
      // Show win overlay or game over overlay
      running = false;
      overlay.style.display = 'none';
      const winOverlay = document.getElementById('gameOverOverlay');
      if (winOverlay) {
        const title = document.getElementById('gameOverTitle');
        const text = document.getElementById('gameOverText');
        const tryAgain = document.getElementById('tryAgainText');
        const restartBtn = document.getElementById('restartBtn');
        title.textContent = t('gameOver');
        text.textContent = t('congratsWin') || 'You have completed all levels!';
        tryAgain.textContent = t('tryAgain') + '?';
        restartBtn.textContent = 'ğŸ”„ ' + t('tryAgain');
        winOverlay.style.display = 'flex';
      }
      try{ stopMusic(); }catch(e){}
      try{ stopZombieMoan(); }catch(e){}
      return;
    }
    // show animated overlay
    const nextLevel = currentLevel + 1;
    const enteringNight = (currentLevel <= 10 && nextLevel >= 11);
    const enteringDay = (currentLevel >= 11 && nextLevel > 20);
    title.textContent = `Level ${nextLevel}`;
    if(enteringNight){
      text.textContent = `ÄÃªm Ä‘ang Ä‘áº¿n... Level ${nextLevel}`;
    } else {
      text.textContent = `Preparing level ${nextLevel}...`;
    }
    overlay.style.display = 'flex'; setTimeout(()=> overlay.classList.add('show'), 30);
    // play small fanfare
    try{ if(audioCtx.state==='suspended') audioCtx.resume(); playBeep(880,'sine',0.12,0.06); setTimeout(()=>playBeep(660,'sine',0.12,0.06),140); }catch(e){}
    setTimeout(()=>{
      // advance level state
      currentLevel++;
      // For night levels (from level 11 onward) use level-6's zombie count as the base,
      // then add the normal per-level increment (+10) for each level after 11.
      // This makes level 11 equal to level 6, level 12 = level6 + 10, etc.
      if(currentLevel >= 11){
        const level6Target = 20 + (6 - 1) * 10; // 70
        levelTarget = level6Target + (currentLevel - 11) * 10;
      } else {
        levelTarget = 20 + (currentLevel-1)*10;
      }
      levelSpawned = 0; levelKilled = 0; spawnAcc = 0;
      // Rebuild cards based on day/night and unlock new plants
      rebuildCardsForLevel();
      // Show unlock message based on day/night mode
      try{
        const isNight = currentLevel >= 11 && currentLevel <= 20;
        
        if(isNight){
          // Night mode unlock logic
          if(currentLevel === 11){
            hud.textContent = `ğŸŒ™ Cháº¿ Ä‘á»™ Ä‘Ãªm! Sun-shroom & Puff-shroom má»Ÿ khÃ³a!`;
          } else {
            const nightUnlockIdx = currentLevel - 10; // level 12 = index 2, level 13 = index 3, etc.
            if(nightUnlockIdx >= 2 && nightUnlockIdx < ALL_NIGHT_CARDS.length){
              const newPlant = ALL_NIGHT_CARDS[nightUnlockIdx];
              hud.textContent = `MÃ n ${currentLevel}! ${newPlant.name} má»Ÿ khÃ³a!`;
            } else {
              hud.textContent = `MÃ n ${currentLevel}!`;
            }
          }
        } else {
          // Day mode unlock logic
          const dayUnlockIdx = currentLevel; // level 2 = index 2, level 3 = index 3, etc.
          if(dayUnlockIdx >= 2 && dayUnlockIdx < ALL_DAY_CARDS.length){
            const newPlant = ALL_DAY_CARDS[dayUnlockIdx];
            hud.textContent = `MÃ n ${currentLevel}! ${newPlant.name} má»Ÿ khÃ³a!`;
          } else {
            hud.textContent = `MÃ n ${currentLevel}!`;
          }
        }
        
        buildSeedBar(); 
        setTimeout(()=>updateUI(), 200);
      }catch(e){}
      // reset garden: plants, sun, cooldowns
      clearPlantsAndResetUI();
      // hide overlay and resume
      overlay.classList.remove('show'); overlay.style.display='none';
      running = true; last = performance.now(); requestAnimationFrame(loop);
    }, 1000);
  }

  nextLevelBtn.onclick = doLevelTransition;

  // Keyboard handlers: 'r' = reset, 'x' = toggle speed, Space = hold fast
  window.addEventListener('keydown', e=>{
    try{
      if(e.key==='r' || e.key==='R'){
        const rb = document.getElementById('reset'); if(rb) rb.click();
      }
      // Toggle/cycle speed via 'x'
      if(e.key==='x' || e.key==='X'){
        const sb = document.getElementById('speedBtn'); if(sb) sb.click();
      }
      // Hold Space to temporarily speed up
      if((e.key === ' ' || e.code === 'Space') && !_spaceHeld){
        _spaceHeld = true;
        _prevSpeed = gameSpeedMultiplier;
        gameSpeedMultiplier = 3;
        const sb = document.getElementById('speedBtn'); if(sb) sb.textContent = `âš¡ ${gameSpeedMultiplier}x`, sb.style.background = '#ff4444';
      }
    }catch(err){ console.error(err); }
  });
  window.addEventListener('keyup', e=>{
    try{
      if((e.key === ' ' || e.code === 'Space') && _spaceHeld){
        _spaceHeld = false;
        gameSpeedMultiplier = _prevSpeed || 1;
        const sb = document.getElementById('speedBtn'); if(sb){ sb.textContent = `âš¡ ${gameSpeedMultiplier}x`; if(gameSpeedMultiplier===1) sb.style.background='#ff6b6b'; else if(gameSpeedMultiplier===2) sb.style.background='#ffa500'; else if(gameSpeedMultiplier===3) sb.style.background='#ff4444'; else sb.style.background='#cc0000'; }
      }
    }catch(err){ console.error(err); }
  });

  // init
  buildSeedBar(); updateUI(); initLawnmowers();
  // safety: ensure overlays and level state are consistent on load
  try{
    const lvlOverlay = document.getElementById('levelOverlay'); if(lvlOverlay) lvlOverlay.style.display = 'none';
    const nb = document.getElementById('nextLevelBtn'); if(nb) nb.onclick = doLevelTransition;
  }catch(e){}
  // reset core state to a clean start
  running = false; currentLevel = 1; levelTarget = 20; levelSpawned = 0; levelKilled = 0; spawnAcc = 0; sun = INITIAL_SUN; updateUI();

  // end of script
  </script>
</body>
</html>
